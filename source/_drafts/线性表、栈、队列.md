---
title: java中的一些数据结构
author: 0x17
date: 2018-09-04 20:07:00
tag:
---

### 逻辑结构

#### 线性结构

##### 线性表

线性表中分为数组和链表

比较ArrayList与LinkedList的优缺点：

ArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity >> 1)），增大了开销。

LinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。

链表的一些变体：

循环单链表：没有tail指针，head指向当前节点

双向链表：还包含一个previous指针指向之前的节点，最后一个next为null

循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点

优点及应用等用到了再来记

##### 栈

栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）

##### 队列

队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）

##### 哈希表

#### 树型结构

#### 图型结构

#### 集合

如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。

子类在构造方法的第一行隐式的继承了超类的默认无参构造方法

如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法

抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。

子类必须实现抽象父类中的所有方法，否则它也是抽象类

### Java算法基础

#### 算法中时间复杂度的注意事项

#### 计算斐波那契数

1.递归的方式（时间复杂度为O(2<sup>n</sup>))）

```
public static int fib(Long index){
        if(index==0)
            return 0;
        if (index==1)
            return 1;
        else
            //最后都会到0或1
            return fib(index-1)+fib(index-2);
    }
```

2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）

```
public static Long fib(Long index){
        Long f0 = 0L;
        Long f1 = 1L;
        Long f2 = 1L;
        if(index==0)
            return f0;
        if (index==1)
            return f1;
        else if (index==2)
            return f2;
        for(Long i=3L;i<=index;i++){
            f0 = f1;
            f1 = f2;
            f2 = f1 + f0;
        }
        return f2;
    }

```

#### 欧几里得算法求最大公约数

1.普通求法

```
GCD(int m, int n){
    int gcd = 1;
    if(m%n==0)
        return n;
    for(int i=n/2; i>0; i--){
        if(m%i==0&&n%i==0){
            gcd = i;
            break;
        }
    }
    return gcd;
}
```

2.欧几里得方法（辗转相除）

m/n=k...r（k为商，r为余数）

首先要明白的一点是gcd(m,n)=gcd(n,r)

可以证明，设x为m,n的公约数(x能整除n,m)，r=m-nk,所以x也能整除r

### 排序算法

#### 选择排序

#### 插入排序

#### 冒泡排序

#### 归并排序

#### 快速排序

#### 堆排序

#### 桶排序和基数排序

#### 外部排序