---
title: 学习jvm
tags:
---

jvm图解，在网上看到的一张图。

![Please Wait](JVM-Architecture.png)

### Class Loader(类加载器)

### Runtime Data Area(运行时数据区))

运行时内存区包括：程序计数器、JVM栈、本地方法栈、堆、方法区、运行时常量区

#### Program Counter Register(程序计数器)

程序计数器占据一小块内存，作用可以看作是当前线程所执行字节码的行号指示器，执行引擎通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都具有各自的一个程序计数器，方便线程切换时恢复到指定位置。在Java虚拟规范中自这个区域中没有规定OOM异常。

#### JVM栈

JVM栈也是线程私有的，描述的是Java方法执行的内存模型，用于储存局部变量表、操作栈、动态链接、方法出口等信息。每一个方法的调用直至结束对应一个栈帧的入栈和出栈。

局部变量表中存放了Java中的基本数据类型，对象引用（reference类型不等于Object本身，它可以是指向对象起始地址，也可以指向一个代表对象的句柄，或者其他与对象相关的地址）。局部变量表的内存大小在编译期就可知并确定下来，在运行期不会改变它的大小。

当线程请求的栈深度大于虚拟机所允许的深度就会报StackOverflowError异常，比如方法的递归调用。
如果栈动态申请内存时没有足够内存可供申请就会发生OOM异常，比如像一个list中添加巨多数据。

#### Native Method Stack(本地方法栈)

本地方法栈与JVM栈类似，只不过调用的不是.class中的方法而是本地方法，Java中的本地方法描述的是一些更底层的操作，可以是其他语言写的。有的虚拟机（比如HotSpot）直接将JVM栈和本地方法栈合二为一。

#### Heap(堆)

Java堆是虚拟机所管理内存中最大的一块区域，在虚拟机启动时创建，几乎所有的内存实例都在此分配内存，是所有线程共享的。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap).

大多数垃圾收集器都采用分代收集算法，因此Java堆可分为新生代和老年代，细致一些分的话可以分为Eden空间、From Survivor空间、To Survivor空间等。还有可能划分出线程私有的的分配缓冲区(Thread Local Allocation Buffer, TLAB)。

堆的实现既可以是固定大小也可以是可拓展的(通过-Xmx和-Xms控制)。如果堆没有内存完成空间分配，并且无法拓展的时候就会报出OOM异常。

#### 方法区

方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码数据。虽然在Java虚拟机规范中把方法区描述为堆的一个逻辑分区，但是它却有一个别名Non-Heap与堆区分开来。

#### 运行时常量池



### Excution Engine(执行引擎)

### Native Method Interface(本地方法接口)