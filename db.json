{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/about.html","path":"about.html","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/java/Array.class","path":"java/Array.class","modified":0,"renderable":0},{"_id":"source/java/Array.java","path":"java/Array.java","modified":0,"renderable":0},{"_id":"source/java/Car.java","path":"java/Car.java","modified":0,"renderable":0},{"_id":"source/java/Main.class","path":"java/Main.class","modified":0,"renderable":0},{"_id":"source/java/Main.java","path":"java/Main.java","modified":0,"renderable":0},{"_id":"source/java/MaxHeap.class","path":"java/MaxHeap.class","modified":0,"renderable":0},{"_id":"source/java/MaxHeap.java","path":"java/MaxHeap.java","modified":0,"renderable":0},{"_id":"source/java/Test.class","path":"java/Test.class","modified":0,"renderable":0},{"_id":"source/java/Test.java","path":"java/Test.java","modified":0,"renderable":0},{"_id":"themes/purplewe/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"source/java/二分搜索树/BST.java","path":"java/二分搜索树/BST.java","modified":0,"renderable":0},{"_id":"source/java/二分搜索树/BST$Node.class","path":"java/二分搜索树/BST$Node.class","modified":0,"renderable":0},{"_id":"source/java/二分搜索树/BST.class","path":"java/二分搜索树/BST.class","modified":0,"renderable":0},{"_id":"themes/purplewe/source/css/bootstrap-theme.min.css","path":"css/bootstrap-theme.min.css","modified":0,"renderable":1},{"_id":"themes/purplewe/source/css/home.styl","path":"css/home.styl","modified":0,"renderable":1},{"_id":"themes/purplewe/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/purplewe/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/purplewe/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/purplewe/source/font/NotoSansHans-Light.otf","path":"font/NotoSansHans-Light.otf","modified":0,"renderable":1}],"Cache":[{"_id":"source/about.html","hash":"ee566aa2092e1e9eae45dffb8042283e8c024b4c","modified":1558537089447},{"_id":"source/CNAME","hash":"b3a701bb790341093bb516d3b165635380653604","modified":1538707155202},{"_id":"themes/purplewe/_config.yml","hash":"dc7154e5a1b48e2221b075b12b5edc0b353ce1b9","modified":1538707155209},{"_id":"source/_drafts/activiti学习笔记.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558315147706},{"_id":"source/_drafts/我漫长的驾考之旅.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558315147715},{"_id":"source/.vscode/launch.json","hash":"83a81e025ce71b7344dad9ab960b43d48bb6911e","modified":1545299776665},{"_id":"source/_drafts/.js-async.md.swp","hash":"cb1080a704f0fa5b29008ebcbc6f1bbd2c9c59e0","modified":1558315147704},{"_id":"source/_drafts/JVM中的垃圾收集器.md","hash":"6ba1a4dc8047ff6463310de81a5d30aa85542351","modified":1538707155203},{"_id":"source/_drafts/.theBasicOfJavascript.md.swp","hash":"4dde0b12d047e782853d6df65dd5ee1cfbf51d25","modified":1558315147705},{"_id":"source/_drafts/Java中的equals与hashCode.md","hash":"1174fd4082686b8f02d0866c029fa8c78ffccdad","modified":1561689954630},{"_id":"source/_drafts/cpu的发展史.md","hash":"510344836671bad94b393f0fd9b35154bbec21bd","modified":1540649257438},{"_id":"source/_drafts/java中的IO.md","hash":"7c3b0fc30c2c951029c84b52c4d47164f0b515a9","modified":1538707155203},{"_id":"source/_drafts/java并发编程基础.md","hash":"6128ee6c8c527d996c13511d7045924218a9931e","modified":1538707155203},{"_id":"source/_drafts/java反射.md","hash":"f39455c97b3840c5b092414a6dc507163837c771","modified":1559273969327},{"_id":"source/_drafts/java数据结构与算法.md","hash":"7c20a8f99137f4a35957b31b5b4682970906c3fe","modified":1561691561208},{"_id":"source/_drafts/js-async.md","hash":"1faef66c69373551e3778e6606ff17ccd4a62586","modified":1558315147710},{"_id":"source/_drafts/learningReact.md","hash":"a9cc407232ba60c63413967850ce00c62c32f2f6","modified":1558315147711},{"_id":"source/_drafts/theBasicOfJavascript.md","hash":"5f4b6f8cac2fcac9bef98bb5ecf44207c10cb223","modified":1558315147712},{"_id":"source/_drafts/web框架学习.md","hash":"d6b0f312a596f3e9bff7b60e443d1debcd450de2","modified":1538707155204},{"_id":"source/_drafts/vsftpd的使用.md","hash":"e770e0b447042c4b650610d0f0b8b774aea21919","modified":1538707155204},{"_id":"source/_drafts/准备事项.md","hash":"d4972cd52a2f7a7c709b96405f832577ed84a516","modified":1538707155204},{"_id":"source/_drafts/准备及期望.md","hash":"c1009fdc5d04bf4ccd57122ea74b7ece5c6bd0c9","modified":1538707155204},{"_id":"source/_drafts/大学毕业.md","hash":"c16f894e4393ee909b116a6065564031241b1be2","modified":1558797168747},{"_id":"source/_drafts/字符集和编码规则.md","hash":"d6d943231a909b8b7cae63a9fd22a05a48028898","modified":1558315147713},{"_id":"source/_drafts/学习jvm.md","hash":"9590d44d2823c76193987aa6084936ef06a276d4","modified":1539996121468},{"_id":"source/_drafts/学习票据.md","hash":"7ae1bb3d0bca59ae94e5919e282e0966b5cb6dee","modified":1558315147714},{"_id":"source/_drafts/对tomcat的一些理解.md","hash":"3aea5037b54b7b8c848b4abd7b0fc6432f8d6b6c","modified":1561890470042},{"_id":"source/_drafts/杂七杂八.md","hash":"2d52293b60f189036d3ede73bd029eed9bb068a4","modified":1559404149906},{"_id":"source/_drafts/数据结构.md","hash":"4ea08574319eedf0e0976d91d0defa2ef7ead2cc","modified":1558355732025},{"_id":"source/_drafts/每天一点ES6.md","hash":"d35c7a46cd2a07678f1c359870cce5b7241d09a6","modified":1558517223846},{"_id":"source/_drafts/深圳之行.md","hash":"4d2abd491bae96ae31773dacf9ea80ce76a3fa87","modified":1538707155206},{"_id":"source/_drafts/第一次工作体验.md","hash":"b254a2d400c596ba19103d5700c594c0f9567330","modified":1558315147717},{"_id":"source/_drafts/线性表、栈、队列.md","hash":"4c7e2595c1c0cd7fda07f6a486ee834b519b5ecd","modified":1538912160341},{"_id":"source/_drafts/项目开发注意事项.md","hash":"96b7b3e07571cf8ec019def631c68c0273f3fe3f","modified":1538707155206},{"_id":"source/_posts/Markdown学习笔记.md","hash":"4e9640642bed9ad8a14edbbc33cc21b6dfbc8327","modified":1538707155206},{"_id":"source/_drafts/项目关键点.md","hash":"b51ce572bed801933d33565f5858b1139a1adf08","modified":1538707155206},{"_id":"source/_drafts/部署描述符详解.md","hash":"6b24321c0ccf8f021e7ca3207eab3122570ad756","modified":1540648772366},{"_id":"source/_posts/java学习笔记.md","hash":"8841ea30eb8e2e79690833878b10f8e3517eb138","modified":1545654022495},{"_id":"source/_posts/大学毕业.md","hash":"9eb9808fcaa67fed1e490b183af9199c837c6276","modified":1559189533943},{"_id":"source/_posts/实习两个月的感受.md","hash":"c07b8c07d9ff8e449fb55dea7d26048aead5818e","modified":1559187958204},{"_id":"source/_posts/对tomcat的一些理解.md","hash":"99c9a5e10039f42030062a9ae7f60b9109b36390","modified":1561886456865},{"_id":"source/_posts/每天一点ES6.md","hash":"4d6978f97cf7446c2fe085e03b2ce2f259148b21","modified":1558517071149},{"_id":"source/_posts/琐事.md","hash":"41d17cbc8eab28a57a1507b71e5efb25f59859b6","modified":1561977504368},{"_id":"source/_posts/记第一次正式面试.md","hash":"45e9fda50f081c5afc915e55a0325cc78f35d8ca","modified":1545654018327},{"_id":"source/java/Array.class","hash":"1c48b679c51e456849ac9c33cfb22b48e10a9275","modified":1561907089120},{"_id":"source/java/Array.java","hash":"bbb9d96794e3e657d00749d271b044b245ff4f03","modified":1561906843220},{"_id":"source/java/Car.java","hash":"fbcfa0542198a5b598744eb06c23c7d83de8fcce","modified":1540132172375},{"_id":"source/java/Main.class","hash":"35e1944291d1b45505d119473ed20b4ca0587555","modified":1561907585110},{"_id":"source/java/Main.java","hash":"d5ce31fb519dbd1ae56b74fa546568cd647d1406","modified":1561907581079},{"_id":"source/java/MaxHeap.class","hash":"c19ef2ae473aa88a5ea814489caf0747838d680d","modified":1561907097600},{"_id":"source/java/MaxHeap.java","hash":"d73ff7cfbd9ef09c60d96a7fc48130df59c980b6","modified":1561907086602},{"_id":"source/java/Test.class","hash":"fbdcb00c0e1e229e53a21e4c8a01506c8a877719","modified":1559230753694},{"_id":"source/java/Test.java","hash":"8c9d0b4fd60a46c4b2fb2ff5a351512184ee3e6c","modified":1559269239288},{"_id":"themes/purplewe/languages/zh-Hans.yml","hash":"3f742e788063a6ce5a9de64e5264350575425821","modified":1538707155212},{"_id":"themes/purplewe/layout/category.ejs","hash":"3594960c6a1f88af4b167511e5958b43ea1e23b5","modified":1538707155214},{"_id":"themes/purplewe/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1538707155214},{"_id":"themes/purplewe/layout/layout.ejs","hash":"8a7f747baf0a12a7e549a91a8e56bf0ed00fd477","modified":1538707155214},{"_id":"themes/purplewe/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1538707155214},{"_id":"themes/purplewe/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1538707155214},{"_id":"themes/purplewe/source/favicon.ico","hash":"3fa9d50c1d6796a877e269ab65aa6910e1796bd6","modified":1538707155222},{"_id":"source/_drafts/学习jvm/JVM-Architecture.png","hash":"3c715ed33914792f4d20fc681dc2d75986563848","modified":1538707155205},{"_id":"source/_posts/java学习笔记/2018_9_6.gif","hash":"717e1c30f4f6fe3ebefc48d73e45beb220d9e8aa","modified":1538707155208},{"_id":"source/java/二分搜索树/BST.java","hash":"eeaff29f7c13ef69d6c780a05f4e3a4f38a94bfa","modified":1559480734834},{"_id":"source/java/二分搜索树/BST$Node.class","hash":"f19274fc0faf4bb98ff1335af17c6d338f254db7","modified":1559456886669},{"_id":"source/java/二分搜索树/BST.class","hash":"b75c7025b7d19c8ff46e5de28a188288696b6790","modified":1559456886691},{"_id":"themes/purplewe/layout/_partial/afterfooter.ejs","hash":"cb8cc6d6a60de4d9ef41742f19fd97be443a0015","modified":1538707155212},{"_id":"themes/purplewe/layout/_partial/archive.ejs","hash":"46a51755a82e58d25eba77b7273e32f11cbeada6","modified":1558361101262},{"_id":"themes/purplewe/layout/_partial/article.ejs","hash":"8ae819a2bad4b29668a769aa64ed99373fb1dc17","modified":1558361123917},{"_id":"themes/purplewe/layout/_partial/head.ejs","hash":"7c7613eac53b43acce3334e6aeb4bd0d68205cd5","modified":1558410180188},{"_id":"themes/purplewe/layout/_partial/nav.ejs","hash":"09b3b5a2effe112910e8992f87c4f3e44669e6bc","modified":1538707155213},{"_id":"themes/purplewe/source/css/bootstrap-theme.min.css","hash":"cb987aba7ffc59bb8bb3af241b2a032affc2094f","modified":1538707155220},{"_id":"themes/purplewe/source/css/home.styl","hash":"6d0ddcfe61da1605082c69857b4d816701ea2b00","modified":1558409760214},{"_id":"themes/purplewe/source/css/main.styl","hash":"64451513a5afc6ce5dc6edcef218e20055790525","modified":1538707155221},{"_id":"themes/purplewe/source/css/style.css","hash":"2450a6a55a8204449ffab36694231517d8e95a3c","modified":1538707155221},{"_id":"themes/purplewe/source/css/bootstrap.min.css","hash":"e2d2b846e9ea72a1985458a3748aab4e01a8fb3a","modified":1538707155221},{"_id":"themes/purplewe/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1538707155216},{"_id":"themes/purplewe/source/css/_common/components/common.styl","hash":"a01ef95f85700da2d266f0347d5b2eaf19d6bde2","modified":1558411162357},{"_id":"themes/purplewe/source/css/_common/components/components.styl","hash":"c654937f73966ba1fd6ed6874fc71f3b9e430b63","modified":1538707155217},{"_id":"themes/purplewe/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1538707155216},{"_id":"source/_posts/大学毕业/2019-5-25.JPG","hash":"f04b8959a37df7607f5c4185beeaaefe74750c66","modified":1559189876984},{"_id":"themes/purplewe/source/css/_common/components/highlight/theme.styl","hash":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1538707155217},{"_id":"themes/purplewe/source/css/_common/components/highlight/highlight.styl","hash":"7577e5852f313650327008b5babfee91c12c27da","modified":1538707155217},{"_id":"themes/purplewe/source/css/_common/components/pages/archive.styl","hash":"23dd966324937deeccc8f5fa16a6d32e4e46243b","modified":1538707155218},{"_id":"themes/purplewe/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1538707155218},{"_id":"themes/purplewe/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1538707155219},{"_id":"themes/purplewe/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1538707155219},{"_id":"themes/purplewe/source/font/NotoSansHans-Light.otf","hash":"afeca582f0e59191af48779878fb5f04a0ce5d74","modified":1538707155336},{"_id":"public/2019/07/01/琐事/index.html","hash":"a1d8405506f3b4cf56c7685389c3a48141172088","modified":1562851442056},{"_id":"public/2019/05/25/大学毕业/index.html","hash":"9e27cffbc6cb438617c87c0723af7f6b2bdbceac","modified":1562851442057},{"_id":"public/2018/12/24/实习两个月的感受/index.html","hash":"fe67b0793a95651a700114ba4889d4e52012277e","modified":1562851442058},{"_id":"public/2018/05/20/记第一次正式面试/index.html","hash":"723a31497d11f1106f50c2a51cddc4f7a275ee39","modified":1562851442058},{"_id":"public/2019/06/30/对tomcat的一些理解/index.html","hash":"aa1d7cb7e2a3d7a809f7189c9e6de9d769289bb9","modified":1562851442058},{"_id":"public/2018/05/04/Markdown学习笔记/index.html","hash":"d924ab7be50b3bc93b3a3213cdae80570ffee844","modified":1562851442058},{"_id":"public/archives/index.html","hash":"c53b9a804ffff54c44b9ac0ee6762fd9037e93c4","modified":1562851442059},{"_id":"public/archives/2018/index.html","hash":"7409b7161fbf1039186ebe326bd8a062c56440a5","modified":1562851442060},{"_id":"public/archives/2018/05/index.html","hash":"a7044a25d2f0a90d7319da036ad1c4bab5721efd","modified":1562851442060},{"_id":"public/archives/2018/07/index.html","hash":"f1746869d07ec758e022dfbf9f2bc98cb2081171","modified":1562851442060},{"_id":"public/archives/2019/index.html","hash":"4155a22cc92cd002defb2f85c2bd6953f14d744f","modified":1562851442060},{"_id":"public/archives/2019/03/index.html","hash":"973dc2dfafbcbc51c1372614740fd570b3893a3c","modified":1562851442060},{"_id":"public/archives/2019/05/index.html","hash":"2ee002930e139e350714d6e34f5e9e3d41e7b900","modified":1562851442061},{"_id":"public/archives/2019/06/index.html","hash":"edc94deae3703f613d66eb62ca96e5acfd53bb9a","modified":1562851442061},{"_id":"public/index.html","hash":"31abd92b7463404d1c93cc8bd0af08ddf7560469","modified":1562851442061},{"_id":"public/archives/2018/12/index.html","hash":"08d2d5b704fc0c9ad73beeccb10b675a654beb0c","modified":1562851442061},{"_id":"public/2019/03/28/每天一点ES6/index.html","hash":"c9b0a1ee3b3db2c09204933668667c0e364d00fd","modified":1562851442061},{"_id":"public/2018/07/24/java学习笔记/index.html","hash":"f3e528568bb6ac3c0fa826a5a9efa01c596c92e0","modified":1562851442061},{"_id":"public/archives/2019/07/index.html","hash":"0cd88ecf845e8cd4b73ac373630e5bb884f641b8","modified":1562851442070},{"_id":"public/about.html","hash":"ee566aa2092e1e9eae45dffb8042283e8c024b4c","modified":1562851442070},{"_id":"public/CNAME","hash":"b3a701bb790341093bb516d3b165635380653604","modified":1562851442070},{"_id":"public/java/Array.class","hash":"1c48b679c51e456849ac9c33cfb22b48e10a9275","modified":1562851442070},{"_id":"public/java/Array.java","hash":"bbb9d96794e3e657d00749d271b044b245ff4f03","modified":1562851442070},{"_id":"public/java/Car.java","hash":"fbcfa0542198a5b598744eb06c23c7d83de8fcce","modified":1562851442070},{"_id":"public/java/Main.class","hash":"35e1944291d1b45505d119473ed20b4ca0587555","modified":1562851442070},{"_id":"public/java/Main.java","hash":"d5ce31fb519dbd1ae56b74fa546568cd647d1406","modified":1562851442071},{"_id":"public/java/MaxHeap.java","hash":"d73ff7cfbd9ef09c60d96a7fc48130df59c980b6","modified":1562851442071},{"_id":"public/java/Test.class","hash":"fbdcb00c0e1e229e53a21e4c8a01506c8a877719","modified":1562851442071},{"_id":"public/java/Test.java","hash":"8c9d0b4fd60a46c4b2fb2ff5a351512184ee3e6c","modified":1562851442071},{"_id":"public/favicon.ico","hash":"3fa9d50c1d6796a877e269ab65aa6910e1796bd6","modified":1562851442071},{"_id":"public/java/二分搜索树/BST.java","hash":"eeaff29f7c13ef69d6c780a05f4e3a4f38a94bfa","modified":1562851442071},{"_id":"public/java/MaxHeap.class","hash":"c19ef2ae473aa88a5ea814489caf0747838d680d","modified":1562851442071},{"_id":"public/java/二分搜索树/BST$Node.class","hash":"f19274fc0faf4bb98ff1335af17c6d338f254db7","modified":1562851442071},{"_id":"public/java/二分搜索树/BST.class","hash":"b75c7025b7d19c8ff46e5de28a188288696b6790","modified":1562851442071},{"_id":"public/2018/10/20/学习jvm/JVM-Architecture.png","hash":"3c715ed33914792f4d20fc681dc2d75986563848","modified":1562851442071},{"_id":"public/2018/07/24/java学习笔记/2018_9_6.gif","hash":"717e1c30f4f6fe3ebefc48d73e45beb220d9e8aa","modified":1562851442071},{"_id":"public/css/bootstrap-theme.min.css","hash":"cb987aba7ffc59bb8bb3af241b2a032affc2094f","modified":1562851442441},{"_id":"public/css/main.css","hash":"04964cbc80bd9f025de6e46f5e81ae8c8ec5d5de","modified":1562851442441},{"_id":"public/css/home.css","hash":"7e3d1fe474718954f0ab802e5de0599de72b5f02","modified":1562851442441},{"_id":"public/css/style.css","hash":"2450a6a55a8204449ffab36694231517d8e95a3c","modified":1562851442441},{"_id":"public/css/bootstrap.min.css","hash":"e2d2b846e9ea72a1985458a3748aab4e01a8fb3a","modified":1562851442441},{"_id":"public/2019/05/25/大学毕业/2019-5-25.JPG","hash":"f04b8959a37df7607f5c4185beeaaefe74750c66","modified":1562851442456},{"_id":"public/font/NotoSansHans-Light.otf","hash":"afeca582f0e59191af48779878fb5f04a0ce5d74","modified":1562851442512}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"","source":"_drafts/activiti学习笔记.md","raw":"","slug":"activiti学习笔记","published":0,"date":"2019-05-20T01:19:07.706Z","updated":"2019-05-20T01:19:07.706Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9th00007tcydlh8d9a1","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_drafts/我漫长的驾考之旅.md","raw":"","slug":"我漫长的驾考之旅","published":0,"date":"2019-05-20T01:19:07.715Z","updated":"2019-05-20T01:19:07.715Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9tp00017tcy2atocc83","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JVM中的垃圾收集器","_content":"\n### 如何判断对象是否应该回收？\n\nJava垃圾收集器主要工作在堆中，回收对象之前，首先需要判断该对象是否需要回收，那么如何判断一个对象是否应该回收？\n\n#### 引用计数法\n\n给对象添加一个计数器，每当一个地方引用对象时，计数器就进行加一操作，每当一个引用失效，计数器就进行减一操作。这个方法简单，判定效率高，但是它存在对象之间相互引用的问题。比如objA中的属性引用objB，objB中的属性引用objA，那么这两个对象相互引用，就导致GC不能回收这两个对象。不过HotSpot虚拟机不是采用这种算法。\n\n#### 根搜索算法\n\n通过一系列的名为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索过的路径成为引用链，当一个对象到任何一个“GC Roots”都没有引用链相连，就说明这个对象不可用，需要回收了。\n\n可作为GC Roots的对象可包括下列：\n\n1.栈帧中的的本地变量表中的引用的对象\n\n2.方法区中类静态属性引用的对象\n\n3.方法区中常量所引用的对象\n\n4.本地方法栈中JNI的引用的对象\n\n#### finalize()\n\n如果对象到“GC Roots”不可达，也并不会马上回收，会进行一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize方法，如果finalize被覆盖并且没有执行过，那么这个对象会放置在一个名为F-Queue的队列中，有一个低优先级的Finalizer线程去执行，并且只是执行，并不确保能执行结束。如果在此时将该对象与引用链上的任何对象相连，便可让他重新存活，但是记住finalze方法至多只能执行一次。不过这个方法不推荐使用。\n\n### 回收方法区\n\n一般方法区执行垃圾回收是非常少的，回收的效率比较低，这也是为什么方法区也被成为永久代。永久代的垃圾收集主要分为两部分——废弃的常量和无用的类。\n\n只要任何地方都没有引用该常量，那么这个常量就需要被回收了。\n\n判断一个无用的类需要满足以下三个条件\n\n1.内存中不存在任何该类的实例\n\n2.该类的ClassLoader已经被回收\n\n3.无法在任何地方通过反射访问该类的方法\n\n### 垃圾收集算法\n\n#### 标记——清除算法\n\n首先标记出需要回收的对象，在标记完成后同一回收所有被标记的对象，标记过程如同根搜索算法。标记清除是最基本的算法，后续的算法都是根据该算法的缺点进行改进的。\n\n该算法的缺点，一个是效率问题，效率不高；另一个是空间问题，因为该算法会导致大量不连续的空间碎片，这样当程序需要分配较大内存的空间时，就找不到足够的空间。\n\n#### 复制算法\n\n他将内存划分为大小相等的两块，每次使用其中的一块，当这一块内存用满时，就将还存活的对象复制到另一块空的内存中去，然后将这一块空间全部清除，这样就不会产生不连续的内存碎片了，但是这样比较浪费空间，每次都要预留一块空间。\n\n考虑到新生代中大部分的内存是需要回收的，于是Java虚拟机就按8:1:1的比例分配给Eden和两块较小的Survivor，当回收时将Eden和Survivor中还存在的对象一次性拷贝到另一块Survivor中，最后清理Eden和一块Survivor空间，HotSpot默认分配比例是8:1:1。但是我们不能保证存活的对象每次都小于10%，那么当Survivor空间不足时，就需要老年代进行分配担保，也就是将其复制到老年代的内存中。\n\n#### 标记——整理算法\n\n复制算法中存在的缺陷是，我们不想浪费50%的内存空间，那么就需要额外的内存担保，所以老年代一般不推荐使用这种算法。\n\n根据老年代的特点，提出了一种“标记——整理”的算法，标记整理算法几乎与“标记——清除”算法一样，但是后续还会将存活的对象都往一端移动，然后直接清理掉段边界以外的内存。\n\n#### 分代收集算法\n\n新生代中对象存活率低，一般使用复制算法，只需要付出少量存活对象的复制成本。\n\n老年代中对象存活率高，一般使用标记——清除或标记整理——算法。\n\n### 垃圾收集器\n\n![HotSpot中的垃圾收集器]()\nHotSpot中提供了其中作用于不同分代的收集器。不同场景使用不同或不同组合的收集器。\n\nSerial收集器\n\nParNew收集器\n\nParallel Scavenge收集器\n\nSerial Old收集器\n\nParallel Old收集器\n\nCMS收集器\n\nG1收集器","source":"_drafts/JVM中的垃圾收集器.md","raw":"---\ntitle: JVM中的垃圾收集器\ntags:\n---\n\n### 如何判断对象是否应该回收？\n\nJava垃圾收集器主要工作在堆中，回收对象之前，首先需要判断该对象是否需要回收，那么如何判断一个对象是否应该回收？\n\n#### 引用计数法\n\n给对象添加一个计数器，每当一个地方引用对象时，计数器就进行加一操作，每当一个引用失效，计数器就进行减一操作。这个方法简单，判定效率高，但是它存在对象之间相互引用的问题。比如objA中的属性引用objB，objB中的属性引用objA，那么这两个对象相互引用，就导致GC不能回收这两个对象。不过HotSpot虚拟机不是采用这种算法。\n\n#### 根搜索算法\n\n通过一系列的名为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索过的路径成为引用链，当一个对象到任何一个“GC Roots”都没有引用链相连，就说明这个对象不可用，需要回收了。\n\n可作为GC Roots的对象可包括下列：\n\n1.栈帧中的的本地变量表中的引用的对象\n\n2.方法区中类静态属性引用的对象\n\n3.方法区中常量所引用的对象\n\n4.本地方法栈中JNI的引用的对象\n\n#### finalize()\n\n如果对象到“GC Roots”不可达，也并不会马上回收，会进行一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize方法，如果finalize被覆盖并且没有执行过，那么这个对象会放置在一个名为F-Queue的队列中，有一个低优先级的Finalizer线程去执行，并且只是执行，并不确保能执行结束。如果在此时将该对象与引用链上的任何对象相连，便可让他重新存活，但是记住finalze方法至多只能执行一次。不过这个方法不推荐使用。\n\n### 回收方法区\n\n一般方法区执行垃圾回收是非常少的，回收的效率比较低，这也是为什么方法区也被成为永久代。永久代的垃圾收集主要分为两部分——废弃的常量和无用的类。\n\n只要任何地方都没有引用该常量，那么这个常量就需要被回收了。\n\n判断一个无用的类需要满足以下三个条件\n\n1.内存中不存在任何该类的实例\n\n2.该类的ClassLoader已经被回收\n\n3.无法在任何地方通过反射访问该类的方法\n\n### 垃圾收集算法\n\n#### 标记——清除算法\n\n首先标记出需要回收的对象，在标记完成后同一回收所有被标记的对象，标记过程如同根搜索算法。标记清除是最基本的算法，后续的算法都是根据该算法的缺点进行改进的。\n\n该算法的缺点，一个是效率问题，效率不高；另一个是空间问题，因为该算法会导致大量不连续的空间碎片，这样当程序需要分配较大内存的空间时，就找不到足够的空间。\n\n#### 复制算法\n\n他将内存划分为大小相等的两块，每次使用其中的一块，当这一块内存用满时，就将还存活的对象复制到另一块空的内存中去，然后将这一块空间全部清除，这样就不会产生不连续的内存碎片了，但是这样比较浪费空间，每次都要预留一块空间。\n\n考虑到新生代中大部分的内存是需要回收的，于是Java虚拟机就按8:1:1的比例分配给Eden和两块较小的Survivor，当回收时将Eden和Survivor中还存在的对象一次性拷贝到另一块Survivor中，最后清理Eden和一块Survivor空间，HotSpot默认分配比例是8:1:1。但是我们不能保证存活的对象每次都小于10%，那么当Survivor空间不足时，就需要老年代进行分配担保，也就是将其复制到老年代的内存中。\n\n#### 标记——整理算法\n\n复制算法中存在的缺陷是，我们不想浪费50%的内存空间，那么就需要额外的内存担保，所以老年代一般不推荐使用这种算法。\n\n根据老年代的特点，提出了一种“标记——整理”的算法，标记整理算法几乎与“标记——清除”算法一样，但是后续还会将存活的对象都往一端移动，然后直接清理掉段边界以外的内存。\n\n#### 分代收集算法\n\n新生代中对象存活率低，一般使用复制算法，只需要付出少量存活对象的复制成本。\n\n老年代中对象存活率高，一般使用标记——清除或标记整理——算法。\n\n### 垃圾收集器\n\n![HotSpot中的垃圾收集器]()\nHotSpot中提供了其中作用于不同分代的收集器。不同场景使用不同或不同组合的收集器。\n\nSerial收集器\n\nParNew收集器\n\nParallel Scavenge收集器\n\nSerial Old收集器\n\nParallel Old收集器\n\nCMS收集器\n\nG1收集器","slug":"JVM中的垃圾收集器","published":0,"date":"2018-10-05T02:39:15.203Z","updated":"2018-10-05T02:39:15.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9tt00027tcydv6bx72w","content":"<h3 id=\"如何判断对象是否应该回收？\"><a href=\"#如何判断对象是否应该回收？\" class=\"headerlink\" title=\"如何判断对象是否应该回收？\"></a>如何判断对象是否应该回收？</h3><p>Java垃圾收集器主要工作在堆中，回收对象之前，首先需要判断该对象是否需要回收，那么如何判断一个对象是否应该回收？</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>给对象添加一个计数器，每当一个地方引用对象时，计数器就进行加一操作，每当一个引用失效，计数器就进行减一操作。这个方法简单，判定效率高，但是它存在对象之间相互引用的问题。比如objA中的属性引用objB，objB中的属性引用objA，那么这两个对象相互引用，就导致GC不能回收这两个对象。不过HotSpot虚拟机不是采用这种算法。</p>\n<h4 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h4><p>通过一系列的名为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索过的路径成为引用链，当一个对象到任何一个“GC Roots”都没有引用链相连，就说明这个对象不可用，需要回收了。</p>\n<p>可作为GC Roots的对象可包括下列：</p>\n<p>1.栈帧中的的本地变量表中的引用的对象</p>\n<p>2.方法区中类静态属性引用的对象</p>\n<p>3.方法区中常量所引用的对象</p>\n<p>4.本地方法栈中JNI的引用的对象</p>\n<h4 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h4><p>如果对象到“GC Roots”不可达，也并不会马上回收，会进行一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize方法，如果finalize被覆盖并且没有执行过，那么这个对象会放置在一个名为F-Queue的队列中，有一个低优先级的Finalizer线程去执行，并且只是执行，并不确保能执行结束。如果在此时将该对象与引用链上的任何对象相连，便可让他重新存活，但是记住finalze方法至多只能执行一次。不过这个方法不推荐使用。</p>\n<h3 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h3><p>一般方法区执行垃圾回收是非常少的，回收的效率比较低，这也是为什么方法区也被成为永久代。永久代的垃圾收集主要分为两部分——废弃的常量和无用的类。</p>\n<p>只要任何地方都没有引用该常量，那么这个常量就需要被回收了。</p>\n<p>判断一个无用的类需要满足以下三个条件</p>\n<p>1.内存中不存在任何该类的实例</p>\n<p>2.该类的ClassLoader已经被回收</p>\n<p>3.无法在任何地方通过反射访问该类的方法</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"标记——清除算法\"><a href=\"#标记——清除算法\" class=\"headerlink\" title=\"标记——清除算法\"></a>标记——清除算法</h4><p>首先标记出需要回收的对象，在标记完成后同一回收所有被标记的对象，标记过程如同根搜索算法。标记清除是最基本的算法，后续的算法都是根据该算法的缺点进行改进的。</p>\n<p>该算法的缺点，一个是效率问题，效率不高；另一个是空间问题，因为该算法会导致大量不连续的空间碎片，这样当程序需要分配较大内存的空间时，就找不到足够的空间。</p>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p>他将内存划分为大小相等的两块，每次使用其中的一块，当这一块内存用满时，就将还存活的对象复制到另一块空的内存中去，然后将这一块空间全部清除，这样就不会产生不连续的内存碎片了，但是这样比较浪费空间，每次都要预留一块空间。</p>\n<p>考虑到新生代中大部分的内存是需要回收的，于是Java虚拟机就按8:1:1的比例分配给Eden和两块较小的Survivor，当回收时将Eden和Survivor中还存在的对象一次性拷贝到另一块Survivor中，最后清理Eden和一块Survivor空间，HotSpot默认分配比例是8:1:1。但是我们不能保证存活的对象每次都小于10%，那么当Survivor空间不足时，就需要老年代进行分配担保，也就是将其复制到老年代的内存中。</p>\n<h4 id=\"标记——整理算法\"><a href=\"#标记——整理算法\" class=\"headerlink\" title=\"标记——整理算法\"></a>标记——整理算法</h4><p>复制算法中存在的缺陷是，我们不想浪费50%的内存空间，那么就需要额外的内存担保，所以老年代一般不推荐使用这种算法。</p>\n<p>根据老年代的特点，提出了一种“标记——整理”的算法，标记整理算法几乎与“标记——清除”算法一样，但是后续还会将存活的对象都往一端移动，然后直接清理掉段边界以外的内存。</p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><p>新生代中对象存活率低，一般使用复制算法，只需要付出少量存活对象的复制成本。</p>\n<p>老年代中对象存活率高，一般使用标记——清除或标记整理——算法。</p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"/2018/10/05/JVM中的垃圾收集器/\" alt=\"HotSpot中的垃圾收集器\"><br>HotSpot中提供了其中作用于不同分代的收集器。不同场景使用不同或不同组合的收集器。</p>\n<p>Serial收集器</p>\n<p>ParNew收集器</p>\n<p>Parallel Scavenge收集器</p>\n<p>Serial Old收集器</p>\n<p>Parallel Old收集器</p>\n<p>CMS收集器</p>\n<p>G1收集器</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"如何判断对象是否应该回收？\"><a href=\"#如何判断对象是否应该回收？\" class=\"headerlink\" title=\"如何判断对象是否应该回收？\"></a>如何判断对象是否应该回收？</h3><p>Java垃圾收集器主要工作在堆中，回收对象之前，首先需要判断该对象是否需要回收，那么如何判断一个对象是否应该回收？</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>给对象添加一个计数器，每当一个地方引用对象时，计数器就进行加一操作，每当一个引用失效，计数器就进行减一操作。这个方法简单，判定效率高，但是它存在对象之间相互引用的问题。比如objA中的属性引用objB，objB中的属性引用objA，那么这两个对象相互引用，就导致GC不能回收这两个对象。不过HotSpot虚拟机不是采用这种算法。</p>\n<h4 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h4><p>通过一系列的名为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索过的路径成为引用链，当一个对象到任何一个“GC Roots”都没有引用链相连，就说明这个对象不可用，需要回收了。</p>\n<p>可作为GC Roots的对象可包括下列：</p>\n<p>1.栈帧中的的本地变量表中的引用的对象</p>\n<p>2.方法区中类静态属性引用的对象</p>\n<p>3.方法区中常量所引用的对象</p>\n<p>4.本地方法栈中JNI的引用的对象</p>\n<h4 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h4><p>如果对象到“GC Roots”不可达，也并不会马上回收，会进行一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize方法，如果finalize被覆盖并且没有执行过，那么这个对象会放置在一个名为F-Queue的队列中，有一个低优先级的Finalizer线程去执行，并且只是执行，并不确保能执行结束。如果在此时将该对象与引用链上的任何对象相连，便可让他重新存活，但是记住finalze方法至多只能执行一次。不过这个方法不推荐使用。</p>\n<h3 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h3><p>一般方法区执行垃圾回收是非常少的，回收的效率比较低，这也是为什么方法区也被成为永久代。永久代的垃圾收集主要分为两部分——废弃的常量和无用的类。</p>\n<p>只要任何地方都没有引用该常量，那么这个常量就需要被回收了。</p>\n<p>判断一个无用的类需要满足以下三个条件</p>\n<p>1.内存中不存在任何该类的实例</p>\n<p>2.该类的ClassLoader已经被回收</p>\n<p>3.无法在任何地方通过反射访问该类的方法</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"标记——清除算法\"><a href=\"#标记——清除算法\" class=\"headerlink\" title=\"标记——清除算法\"></a>标记——清除算法</h4><p>首先标记出需要回收的对象，在标记完成后同一回收所有被标记的对象，标记过程如同根搜索算法。标记清除是最基本的算法，后续的算法都是根据该算法的缺点进行改进的。</p>\n<p>该算法的缺点，一个是效率问题，效率不高；另一个是空间问题，因为该算法会导致大量不连续的空间碎片，这样当程序需要分配较大内存的空间时，就找不到足够的空间。</p>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p>他将内存划分为大小相等的两块，每次使用其中的一块，当这一块内存用满时，就将还存活的对象复制到另一块空的内存中去，然后将这一块空间全部清除，这样就不会产生不连续的内存碎片了，但是这样比较浪费空间，每次都要预留一块空间。</p>\n<p>考虑到新生代中大部分的内存是需要回收的，于是Java虚拟机就按8:1:1的比例分配给Eden和两块较小的Survivor，当回收时将Eden和Survivor中还存在的对象一次性拷贝到另一块Survivor中，最后清理Eden和一块Survivor空间，HotSpot默认分配比例是8:1:1。但是我们不能保证存活的对象每次都小于10%，那么当Survivor空间不足时，就需要老年代进行分配担保，也就是将其复制到老年代的内存中。</p>\n<h4 id=\"标记——整理算法\"><a href=\"#标记——整理算法\" class=\"headerlink\" title=\"标记——整理算法\"></a>标记——整理算法</h4><p>复制算法中存在的缺陷是，我们不想浪费50%的内存空间，那么就需要额外的内存担保，所以老年代一般不推荐使用这种算法。</p>\n<p>根据老年代的特点，提出了一种“标记——整理”的算法，标记整理算法几乎与“标记——清除”算法一样，但是后续还会将存活的对象都往一端移动，然后直接清理掉段边界以外的内存。</p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><p>新生代中对象存活率低，一般使用复制算法，只需要付出少量存活对象的复制成本。</p>\n<p>老年代中对象存活率高，一般使用标记——清除或标记整理——算法。</p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"/2018/10/05/JVM中的垃圾收集器/\" alt=\"HotSpot中的垃圾收集器\"><br>HotSpot中提供了其中作用于不同分代的收集器。不同场景使用不同或不同组合的收集器。</p>\n<p>Serial收集器</p>\n<p>ParNew收集器</p>\n<p>Parallel Scavenge收集器</p>\n<p>Serial Old收集器</p>\n<p>Parallel Old收集器</p>\n<p>CMS收集器</p>\n<p>G1收集器</p>\n"},{"title":"Java中的equals与hashCode","_content":"\n### equals与==的区别\n\n==：表示的是两个对象的地址是否相等\nequals：在Object中表示的也是两个对象的地址是否相等，但是如果在类中重写了equals方法，那么一般判断的就是两个对象的内容是否相等。\n\n```\nObject中的代码\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n### hascode()\n\nhasCode()方法的作用的获取哈希码，也称为散列码；它实际上是一个int整数。哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()方法定义在Object中，这也就意味着Java中所有对象都有hashCode()这个方法，自定义对象默认的hashCode是根据地址计算的(This is typically implemented by converting the internal address of the object into an integer)。\n\n#### 散列表\n\n散列表也叫字典、关联数组、映射表，里面包含了一个一个条目，条目是由键值对的形式组成。体现的是空间换取时间的一种思想。\n\n#### 散列函数（哈希函数）\n\nkey与散列表下标index的映射关系，但是key一般是很多的，有可能产生多个key对映一个index的情况，这种情况叫做哈希冲突，那么如何解决这种冲突，这是需要了解的重点。\n\n##### 哈希函数的设计\n\n设计原则\n\n一致性：如果a==b，那么hash(a)==hash(b)\n\n高效性：计算高效简便\n\n均匀性：哈希值分布均匀\n\n1.整型\n\n小范围正整数直接使用\n\n小范围负整数进行偏移\n\n大整数取模（模一个素数是为了使结果分布均匀），不过还是需要具体问题具体分析\n\n2.浮点型\n\n转换为整型\n\n3.字符串\n\n也转换为整型（进制转换）\n\n4.复合类型（自定义对象、日期类型等）\n\n##### 如何解决哈希冲突","source":"_drafts/Java中的equals与hashCode.md","raw":"---\ntitle: Java中的equals与hashCode\ntags:\n---\n\n### equals与==的区别\n\n==：表示的是两个对象的地址是否相等\nequals：在Object中表示的也是两个对象的地址是否相等，但是如果在类中重写了equals方法，那么一般判断的就是两个对象的内容是否相等。\n\n```\nObject中的代码\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n### hascode()\n\nhasCode()方法的作用的获取哈希码，也称为散列码；它实际上是一个int整数。哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()方法定义在Object中，这也就意味着Java中所有对象都有hashCode()这个方法，自定义对象默认的hashCode是根据地址计算的(This is typically implemented by converting the internal address of the object into an integer)。\n\n#### 散列表\n\n散列表也叫字典、关联数组、映射表，里面包含了一个一个条目，条目是由键值对的形式组成。体现的是空间换取时间的一种思想。\n\n#### 散列函数（哈希函数）\n\nkey与散列表下标index的映射关系，但是key一般是很多的，有可能产生多个key对映一个index的情况，这种情况叫做哈希冲突，那么如何解决这种冲突，这是需要了解的重点。\n\n##### 哈希函数的设计\n\n设计原则\n\n一致性：如果a==b，那么hash(a)==hash(b)\n\n高效性：计算高效简便\n\n均匀性：哈希值分布均匀\n\n1.整型\n\n小范围正整数直接使用\n\n小范围负整数进行偏移\n\n大整数取模（模一个素数是为了使结果分布均匀），不过还是需要具体问题具体分析\n\n2.浮点型\n\n转换为整型\n\n3.字符串\n\n也转换为整型（进制转换）\n\n4.复合类型（自定义对象、日期类型等）\n\n##### 如何解决哈希冲突","slug":"Java中的equals与hashCode","published":0,"date":"2019-06-28T02:45:54.630Z","updated":"2019-06-28T02:45:54.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9tv00037tcyyr8fd41w","content":"<h3 id=\"equals与-的区别\"><a href=\"#equals与-的区别\" class=\"headerlink\" title=\"equals与==的区别\"></a>equals与==的区别</h3><p>==：表示的是两个对象的地址是否相等<br>equals：在Object中表示的也是两个对象的地址是否相等，但是如果在类中重写了equals方法，那么一般判断的就是两个对象的内容是否相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object中的代码</span><br><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    return (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hascode\"><a href=\"#hascode\" class=\"headerlink\" title=\"hascode()\"></a>hascode()</h3><p>hasCode()方法的作用的获取哈希码，也称为散列码；它实际上是一个int整数。哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()方法定义在Object中，这也就意味着Java中所有对象都有hashCode()这个方法，自定义对象默认的hashCode是根据地址计算的(This is typically implemented by converting the internal address of the object into an integer)。</p>\n<h4 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h4><p>散列表也叫字典、关联数组、映射表，里面包含了一个一个条目，条目是由键值对的形式组成。体现的是空间换取时间的一种思想。</p>\n<h4 id=\"散列函数（哈希函数）\"><a href=\"#散列函数（哈希函数）\" class=\"headerlink\" title=\"散列函数（哈希函数）\"></a>散列函数（哈希函数）</h4><p>key与散列表下标index的映射关系，但是key一般是很多的，有可能产生多个key对映一个index的情况，这种情况叫做哈希冲突，那么如何解决这种冲突，这是需要了解的重点。</p>\n<h5 id=\"哈希函数的设计\"><a href=\"#哈希函数的设计\" class=\"headerlink\" title=\"哈希函数的设计\"></a>哈希函数的设计</h5><p>设计原则</p>\n<p>一致性：如果a==b，那么hash(a)==hash(b)</p>\n<p>高效性：计算高效简便</p>\n<p>均匀性：哈希值分布均匀</p>\n<p>1.整型</p>\n<p>小范围正整数直接使用</p>\n<p>小范围负整数进行偏移</p>\n<p>大整数取模（模一个素数是为了使结果分布均匀），不过还是需要具体问题具体分析</p>\n<p>2.浮点型</p>\n<p>转换为整型</p>\n<p>3.字符串</p>\n<p>也转换为整型（进制转换）</p>\n<p>4.复合类型（自定义对象、日期类型等）</p>\n<h5 id=\"如何解决哈希冲突\"><a href=\"#如何解决哈希冲突\" class=\"headerlink\" title=\"如何解决哈希冲突\"></a>如何解决哈希冲突</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"equals与-的区别\"><a href=\"#equals与-的区别\" class=\"headerlink\" title=\"equals与==的区别\"></a>equals与==的区别</h3><p>==：表示的是两个对象的地址是否相等<br>equals：在Object中表示的也是两个对象的地址是否相等，但是如果在类中重写了equals方法，那么一般判断的就是两个对象的内容是否相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object中的代码</span><br><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    return (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hascode\"><a href=\"#hascode\" class=\"headerlink\" title=\"hascode()\"></a>hascode()</h3><p>hasCode()方法的作用的获取哈希码，也称为散列码；它实际上是一个int整数。哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()方法定义在Object中，这也就意味着Java中所有对象都有hashCode()这个方法，自定义对象默认的hashCode是根据地址计算的(This is typically implemented by converting the internal address of the object into an integer)。</p>\n<h4 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h4><p>散列表也叫字典、关联数组、映射表，里面包含了一个一个条目，条目是由键值对的形式组成。体现的是空间换取时间的一种思想。</p>\n<h4 id=\"散列函数（哈希函数）\"><a href=\"#散列函数（哈希函数）\" class=\"headerlink\" title=\"散列函数（哈希函数）\"></a>散列函数（哈希函数）</h4><p>key与散列表下标index的映射关系，但是key一般是很多的，有可能产生多个key对映一个index的情况，这种情况叫做哈希冲突，那么如何解决这种冲突，这是需要了解的重点。</p>\n<h5 id=\"哈希函数的设计\"><a href=\"#哈希函数的设计\" class=\"headerlink\" title=\"哈希函数的设计\"></a>哈希函数的设计</h5><p>设计原则</p>\n<p>一致性：如果a==b，那么hash(a)==hash(b)</p>\n<p>高效性：计算高效简便</p>\n<p>均匀性：哈希值分布均匀</p>\n<p>1.整型</p>\n<p>小范围正整数直接使用</p>\n<p>小范围负整数进行偏移</p>\n<p>大整数取模（模一个素数是为了使结果分布均匀），不过还是需要具体问题具体分析</p>\n<p>2.浮点型</p>\n<p>转换为整型</p>\n<p>3.字符串</p>\n<p>也转换为整型（进制转换）</p>\n<p>4.复合类型（自定义对象、日期类型等）</p>\n<h5 id=\"如何解决哈希冲突\"><a href=\"#如何解决哈希冲突\" class=\"headerlink\" title=\"如何解决哈希冲突\"></a>如何解决哈希冲突</h5>"},{"title":"cpu的发展历史","author":"0x17","date":"2018-10-27T06:28:00.000Z","_content":"\n## 1971年11月15日，世界上第一块个人微型处理器4004诞生\n\n这是一款4位处理器有45条指令，集成了2000多个晶体管，每秒执行5万条指令，运行速度108KHz,这一发明最先应用于Busicom。4004中第一个4代表的芯片是客户订购的产品编号，后一个4代表此芯片是Intel公司制作的第四个芯片。\n\n## 1972年，8008微型处理器\n\n这款cpu的频率位200KHz，晶体管的总数达到3500个，首次获得了cpu的指令技术。并且于1974年被一款Mark-8的设备采用，Mark-8是第一批家用计算机之一。\n\n## 1974年，具有革命意义的8080微处理器\n\n采用了复杂的指令集以及40管针脚封装\n\n","source":"_drafts/cpu的发展史.md","raw":"---\ntitle: cpu的发展历史\nauthor: '0x17'\ndate: 2018-10-27 14:28:00\n---\n\n## 1971年11月15日，世界上第一块个人微型处理器4004诞生\n\n这是一款4位处理器有45条指令，集成了2000多个晶体管，每秒执行5万条指令，运行速度108KHz,这一发明最先应用于Busicom。4004中第一个4代表的芯片是客户订购的产品编号，后一个4代表此芯片是Intel公司制作的第四个芯片。\n\n## 1972年，8008微型处理器\n\n这款cpu的频率位200KHz，晶体管的总数达到3500个，首次获得了cpu的指令技术。并且于1974年被一款Mark-8的设备采用，Mark-8是第一批家用计算机之一。\n\n## 1974年，具有革命意义的8080微处理器\n\n采用了复杂的指令集以及40管针脚封装\n\n","slug":"cpu的发展史","published":0,"updated":"2018-10-27T14:07:37.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9tx00047tcyfhiiktqa","content":"<h2 id=\"1971年11月15日，世界上第一块个人微型处理器4004诞生\"><a href=\"#1971年11月15日，世界上第一块个人微型处理器4004诞生\" class=\"headerlink\" title=\"1971年11月15日，世界上第一块个人微型处理器4004诞生\"></a>1971年11月15日，世界上第一块个人微型处理器4004诞生</h2><p>这是一款4位处理器有45条指令，集成了2000多个晶体管，每秒执行5万条指令，运行速度108KHz,这一发明最先应用于Busicom。4004中第一个4代表的芯片是客户订购的产品编号，后一个4代表此芯片是Intel公司制作的第四个芯片。</p>\n<h2 id=\"1972年，8008微型处理器\"><a href=\"#1972年，8008微型处理器\" class=\"headerlink\" title=\"1972年，8008微型处理器\"></a>1972年，8008微型处理器</h2><p>这款cpu的频率位200KHz，晶体管的总数达到3500个，首次获得了cpu的指令技术。并且于1974年被一款Mark-8的设备采用，Mark-8是第一批家用计算机之一。</p>\n<h2 id=\"1974年，具有革命意义的8080微处理器\"><a href=\"#1974年，具有革命意义的8080微处理器\" class=\"headerlink\" title=\"1974年，具有革命意义的8080微处理器\"></a>1974年，具有革命意义的8080微处理器</h2><p>采用了复杂的指令集以及40管针脚封装</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1971年11月15日，世界上第一块个人微型处理器4004诞生\"><a href=\"#1971年11月15日，世界上第一块个人微型处理器4004诞生\" class=\"headerlink\" title=\"1971年11月15日，世界上第一块个人微型处理器4004诞生\"></a>1971年11月15日，世界上第一块个人微型处理器4004诞生</h2><p>这是一款4位处理器有45条指令，集成了2000多个晶体管，每秒执行5万条指令，运行速度108KHz,这一发明最先应用于Busicom。4004中第一个4代表的芯片是客户订购的产品编号，后一个4代表此芯片是Intel公司制作的第四个芯片。</p>\n<h2 id=\"1972年，8008微型处理器\"><a href=\"#1972年，8008微型处理器\" class=\"headerlink\" title=\"1972年，8008微型处理器\"></a>1972年，8008微型处理器</h2><p>这款cpu的频率位200KHz，晶体管的总数达到3500个，首次获得了cpu的指令技术。并且于1974年被一款Mark-8的设备采用，Mark-8是第一批家用计算机之一。</p>\n<h2 id=\"1974年，具有革命意义的8080微处理器\"><a href=\"#1974年，具有革命意义的8080微处理器\" class=\"headerlink\" title=\"1974年，具有革命意义的8080微处理器\"></a>1974年，具有革命意义的8080微处理器</h2><p>采用了复杂的指令集以及40管针脚封装</p>\n"},{"title":"java并发编程基础","_content":"","source":"_drafts/java并发编程基础.md","raw":"---\ntitle: java并发编程基础\ntags:\n---\n","slug":"java并发编程基础","published":0,"date":"2018-10-05T02:39:15.203Z","updated":"2018-10-05T02:39:15.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9tz00057tcyu8yr8waq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java反射","author":"二十三画生","date":"2019-03-25T15:11:49.000Z","_content":"\n### java反射基础\n\n通过Java反射可以获得类的属性、方法等等信息，并可以灵活修改。\n\nJava反射可以起到动态加载类的作用，这样类与类之间就不用关联，降低代码的耦合。\n\n### java.lang.Class初探\n\n### java.lang.reflect包初探\n\n### jvm中的类加载器","source":"_drafts/java反射.md","raw":"---\ntitle: java反射\nauthor: 二十三画生\ndate: 2019-03-25 23:11:49\ntags:\n---\n\n### java反射基础\n\n通过Java反射可以获得类的属性、方法等等信息，并可以灵活修改。\n\nJava反射可以起到动态加载类的作用，这样类与类之间就不用关联，降低代码的耦合。\n\n### java.lang.Class初探\n\n### java.lang.reflect包初探\n\n### jvm中的类加载器","slug":"java反射","published":0,"updated":"2019-05-31T03:39:29.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u100067tcyl24pveip","content":"<h3 id=\"java反射基础\"><a href=\"#java反射基础\" class=\"headerlink\" title=\"java反射基础\"></a>java反射基础</h3><p>通过Java反射可以获得类的属性、方法等等信息，并可以灵活修改。</p>\n<p>Java反射可以起到动态加载类的作用，这样类与类之间就不用关联，降低代码的耦合。</p>\n<h3 id=\"java-lang-Class初探\"><a href=\"#java-lang-Class初探\" class=\"headerlink\" title=\"java.lang.Class初探\"></a>java.lang.Class初探</h3><h3 id=\"java-lang-reflect包初探\"><a href=\"#java-lang-reflect包初探\" class=\"headerlink\" title=\"java.lang.reflect包初探\"></a>java.lang.reflect包初探</h3><h3 id=\"jvm中的类加载器\"><a href=\"#jvm中的类加载器\" class=\"headerlink\" title=\"jvm中的类加载器\"></a>jvm中的类加载器</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"java反射基础\"><a href=\"#java反射基础\" class=\"headerlink\" title=\"java反射基础\"></a>java反射基础</h3><p>通过Java反射可以获得类的属性、方法等等信息，并可以灵活修改。</p>\n<p>Java反射可以起到动态加载类的作用，这样类与类之间就不用关联，降低代码的耦合。</p>\n<h3 id=\"java-lang-Class初探\"><a href=\"#java-lang-Class初探\" class=\"headerlink\" title=\"java.lang.Class初探\"></a>java.lang.Class初探</h3><h3 id=\"java-lang-reflect包初探\"><a href=\"#java-lang-reflect包初探\" class=\"headerlink\" title=\"java.lang.reflect包初探\"></a>java.lang.reflect包初探</h3><h3 id=\"jvm中的类加载器\"><a href=\"#jvm中的类加载器\" class=\"headerlink\" title=\"jvm中的类加载器\"></a>jvm中的类加载器</h3>"},{"title":"java数据结构与算法","_content":"\n### 线性结构\n\n#### 线性表\n\n线性表中分为数组和链表\n\n比较ArrayList与LinkedList的优缺点：\n\nArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity >> 1)），增大了开销。\n\nLinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。\n\n链表的一些变体：\n\n循环单链表：没有tail指针，head指向当前节点\n\n双向链表：还包含一个previous指针指向之前的节点，最后一个next为null\n\n循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点\n\n优点及应用等用到了再来记\n\n#### 栈\n\n栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）\n\n#### 队列\n\n队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）\n\n#### 哈希表\n\n### 树型结构\n\n#### 二分搜索树\n\n#### 线段树（区间树）\n\n### 图型结构\n\n### 集合\n\n如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。\n\n子类在构造方法的第一行隐式的继承了超类的默认无参构造方法\n\n如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法\n\n抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。\n\n子类必须实现抽象父类中的所有方法，否则它也是抽象类\n\n### Java算法基础\n\n#### 算法中时间复杂度的注意事项\n\n#### 计算斐波那契数\n\n1.递归的方式（时间复杂度为O(2<sup>n</sup>))）\n\n```\npublic static int fib(Long index){\n        if(index==0)\n            return 0;\n        if (index==1)\n            return 1;\n        else\n            //最后都会到0或1\n            return fib(index-1)+fib(index-2);\n    }\n```\n\n2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）\n\n```\npublic static Long fib(Long index){\n        Long f0 = 0L;\n        Long f1 = 1L;\n        Long f2 = 1L;\n        if(index==0)\n            return f0;\n        if (index==1)\n            return f1;\n        else if (index==2)\n            return f2;\n        for(Long i=3L;i<=index;i++){\n            f0 = f1;\n            f1 = f2;\n            f2 = f1 + f0;\n        }\n        return f2;\n    }\n\n```\n\n#### 欧几里得算法求最大公约数\n\n1.普通求法\n\n```\nGCD(int m, int n){\n    int gcd = 1;\n    if(m%n==0)\n        return n;\n    for(int i=n/2; i>0; i--){\n        if(m%i==0&&n%i==0){\n            gcd = i;\n            break;\n        }\n    }\n    return gcd;\n}\n```\n\n2.欧几里得方法（辗转相除）\n\nm/n=k...r（k为商，r为余数）\n\n首先要明白的一点是gcd(m,n)=gcd(n,r)\n\n可以证明，设x为m,n的公约数，r=m-nk,能整除m,n的数，那一定也能整除r。\n\n```\npublic static int gcd(int m,int n){\n        if(m%n==0)\n            return n;\n        else{\n            return gcd(n, m%n);\n        }\n    }\n```\n\n### 排序算法\n\n#### 选择排序\n\n\n\n#### 插入排序\n\n#### 冒泡排序\n\n#### 归并排序\n\n#### 快速排序\n\n#### 堆排序\n\n#### 桶排序和基数排序\n\n#### 外部排序","source":"_drafts/java数据结构与算法.md","raw":"---\ntitle: java数据结构与算法\ntags:\n---\n\n### 线性结构\n\n#### 线性表\n\n线性表中分为数组和链表\n\n比较ArrayList与LinkedList的优缺点：\n\nArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity >> 1)），增大了开销。\n\nLinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。\n\n链表的一些变体：\n\n循环单链表：没有tail指针，head指向当前节点\n\n双向链表：还包含一个previous指针指向之前的节点，最后一个next为null\n\n循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点\n\n优点及应用等用到了再来记\n\n#### 栈\n\n栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）\n\n#### 队列\n\n队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）\n\n#### 哈希表\n\n### 树型结构\n\n#### 二分搜索树\n\n#### 线段树（区间树）\n\n### 图型结构\n\n### 集合\n\n如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。\n\n子类在构造方法的第一行隐式的继承了超类的默认无参构造方法\n\n如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法\n\n抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。\n\n子类必须实现抽象父类中的所有方法，否则它也是抽象类\n\n### Java算法基础\n\n#### 算法中时间复杂度的注意事项\n\n#### 计算斐波那契数\n\n1.递归的方式（时间复杂度为O(2<sup>n</sup>))）\n\n```\npublic static int fib(Long index){\n        if(index==0)\n            return 0;\n        if (index==1)\n            return 1;\n        else\n            //最后都会到0或1\n            return fib(index-1)+fib(index-2);\n    }\n```\n\n2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）\n\n```\npublic static Long fib(Long index){\n        Long f0 = 0L;\n        Long f1 = 1L;\n        Long f2 = 1L;\n        if(index==0)\n            return f0;\n        if (index==1)\n            return f1;\n        else if (index==2)\n            return f2;\n        for(Long i=3L;i<=index;i++){\n            f0 = f1;\n            f1 = f2;\n            f2 = f1 + f0;\n        }\n        return f2;\n    }\n\n```\n\n#### 欧几里得算法求最大公约数\n\n1.普通求法\n\n```\nGCD(int m, int n){\n    int gcd = 1;\n    if(m%n==0)\n        return n;\n    for(int i=n/2; i>0; i--){\n        if(m%i==0&&n%i==0){\n            gcd = i;\n            break;\n        }\n    }\n    return gcd;\n}\n```\n\n2.欧几里得方法（辗转相除）\n\nm/n=k...r（k为商，r为余数）\n\n首先要明白的一点是gcd(m,n)=gcd(n,r)\n\n可以证明，设x为m,n的公约数，r=m-nk,能整除m,n的数，那一定也能整除r。\n\n```\npublic static int gcd(int m,int n){\n        if(m%n==0)\n            return n;\n        else{\n            return gcd(n, m%n);\n        }\n    }\n```\n\n### 排序算法\n\n#### 选择排序\n\n\n\n#### 插入排序\n\n#### 冒泡排序\n\n#### 归并排序\n\n#### 快速排序\n\n#### 堆排序\n\n#### 桶排序和基数排序\n\n#### 外部排序","slug":"java数据结构与算法","published":0,"date":"2019-06-28T03:12:41.208Z","updated":"2019-06-28T03:12:41.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u200077tcy55pocvu7","content":"<h3 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h3><h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><p>线性表中分为数组和链表</p>\n<p>比较ArrayList与LinkedList的优缺点：</p>\n<p>ArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)），增大了开销。</p>\n<p>LinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。</p>\n<p>链表的一些变体：</p>\n<p>循环单链表：没有tail指针，head指向当前节点</p>\n<p>双向链表：还包含一个previous指针指向之前的节点，最后一个next为null</p>\n<p>循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点</p>\n<p>优点及应用等用到了再来记</p>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）</p>\n<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）</p>\n<h4 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h4><h3 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"树型结构\"></a>树型结构</h3><h4 id=\"二分搜索树\"><a href=\"#二分搜索树\" class=\"headerlink\" title=\"二分搜索树\"></a>二分搜索树</h4><h4 id=\"线段树（区间树）\"><a href=\"#线段树（区间树）\" class=\"headerlink\" title=\"线段树（区间树）\"></a>线段树（区间树）</h4><h3 id=\"图型结构\"><a href=\"#图型结构\" class=\"headerlink\" title=\"图型结构\"></a>图型结构</h3><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。</p>\n<p>子类在构造方法的第一行隐式的继承了超类的默认无参构造方法</p>\n<p>如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法</p>\n<p>抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。</p>\n<p>子类必须实现抽象父类中的所有方法，否则它也是抽象类</p>\n<h3 id=\"Java算法基础\"><a href=\"#Java算法基础\" class=\"headerlink\" title=\"Java算法基础\"></a>Java算法基础</h3><h4 id=\"算法中时间复杂度的注意事项\"><a href=\"#算法中时间复杂度的注意事项\" class=\"headerlink\" title=\"算法中时间复杂度的注意事项\"></a>算法中时间复杂度的注意事项</h4><h4 id=\"计算斐波那契数\"><a href=\"#计算斐波那契数\" class=\"headerlink\" title=\"计算斐波那契数\"></a>计算斐波那契数</h4><p>1.递归的方式（时间复杂度为O(2<sup>n</sup>))）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int fib(Long index)&#123;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            //最后都会到0或1</span><br><span class=\"line\">            return fib(index-1)+fib(index-2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Long fib(Long index)&#123;</span><br><span class=\"line\">        Long f0 = 0L;</span><br><span class=\"line\">        Long f1 = 1L;</span><br><span class=\"line\">        Long f2 = 1L;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return f0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return f1;</span><br><span class=\"line\">        else if (index==2)</span><br><span class=\"line\">            return f2;</span><br><span class=\"line\">        for(Long i=3L;i&lt;=index;i++)&#123;</span><br><span class=\"line\">            f0 = f1;</span><br><span class=\"line\">            f1 = f2;</span><br><span class=\"line\">            f2 = f1 + f0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return f2;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"欧几里得算法求最大公约数\"><a href=\"#欧几里得算法求最大公约数\" class=\"headerlink\" title=\"欧几里得算法求最大公约数\"></a>欧几里得算法求最大公约数</h4><p>1.普通求法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GCD(int m, int n)&#123;</span><br><span class=\"line\">    int gcd = 1;</span><br><span class=\"line\">    if(m%n==0)</span><br><span class=\"line\">        return n;</span><br><span class=\"line\">    for(int i=n/2; i&gt;0; i--)&#123;</span><br><span class=\"line\">        if(m%i==0&amp;&amp;n%i==0)&#123;</span><br><span class=\"line\">            gcd = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return gcd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.欧几里得方法（辗转相除）</p>\n<p>m/n=k…r（k为商，r为余数）</p>\n<p>首先要明白的一点是gcd(m,n)=gcd(n,r)</p>\n<p>可以证明，设x为m,n的公约数，r=m-nk,能整除m,n的数，那一定也能整除r。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int gcd(int m,int n)&#123;</span><br><span class=\"line\">        if(m%n==0)</span><br><span class=\"line\">            return n;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            return gcd(n, m%n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"桶排序和基数排序\"><a href=\"#桶排序和基数排序\" class=\"headerlink\" title=\"桶排序和基数排序\"></a>桶排序和基数排序</h4><h4 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h3><h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><p>线性表中分为数组和链表</p>\n<p>比较ArrayList与LinkedList的优缺点：</p>\n<p>ArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)），增大了开销。</p>\n<p>LinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。</p>\n<p>链表的一些变体：</p>\n<p>循环单链表：没有tail指针，head指向当前节点</p>\n<p>双向链表：还包含一个previous指针指向之前的节点，最后一个next为null</p>\n<p>循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点</p>\n<p>优点及应用等用到了再来记</p>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）</p>\n<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）</p>\n<h4 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h4><h3 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"树型结构\"></a>树型结构</h3><h4 id=\"二分搜索树\"><a href=\"#二分搜索树\" class=\"headerlink\" title=\"二分搜索树\"></a>二分搜索树</h4><h4 id=\"线段树（区间树）\"><a href=\"#线段树（区间树）\" class=\"headerlink\" title=\"线段树（区间树）\"></a>线段树（区间树）</h4><h3 id=\"图型结构\"><a href=\"#图型结构\" class=\"headerlink\" title=\"图型结构\"></a>图型结构</h3><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。</p>\n<p>子类在构造方法的第一行隐式的继承了超类的默认无参构造方法</p>\n<p>如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法</p>\n<p>抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。</p>\n<p>子类必须实现抽象父类中的所有方法，否则它也是抽象类</p>\n<h3 id=\"Java算法基础\"><a href=\"#Java算法基础\" class=\"headerlink\" title=\"Java算法基础\"></a>Java算法基础</h3><h4 id=\"算法中时间复杂度的注意事项\"><a href=\"#算法中时间复杂度的注意事项\" class=\"headerlink\" title=\"算法中时间复杂度的注意事项\"></a>算法中时间复杂度的注意事项</h4><h4 id=\"计算斐波那契数\"><a href=\"#计算斐波那契数\" class=\"headerlink\" title=\"计算斐波那契数\"></a>计算斐波那契数</h4><p>1.递归的方式（时间复杂度为O(2<sup>n</sup>))）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int fib(Long index)&#123;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            //最后都会到0或1</span><br><span class=\"line\">            return fib(index-1)+fib(index-2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Long fib(Long index)&#123;</span><br><span class=\"line\">        Long f0 = 0L;</span><br><span class=\"line\">        Long f1 = 1L;</span><br><span class=\"line\">        Long f2 = 1L;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return f0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return f1;</span><br><span class=\"line\">        else if (index==2)</span><br><span class=\"line\">            return f2;</span><br><span class=\"line\">        for(Long i=3L;i&lt;=index;i++)&#123;</span><br><span class=\"line\">            f0 = f1;</span><br><span class=\"line\">            f1 = f2;</span><br><span class=\"line\">            f2 = f1 + f0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return f2;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"欧几里得算法求最大公约数\"><a href=\"#欧几里得算法求最大公约数\" class=\"headerlink\" title=\"欧几里得算法求最大公约数\"></a>欧几里得算法求最大公约数</h4><p>1.普通求法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GCD(int m, int n)&#123;</span><br><span class=\"line\">    int gcd = 1;</span><br><span class=\"line\">    if(m%n==0)</span><br><span class=\"line\">        return n;</span><br><span class=\"line\">    for(int i=n/2; i&gt;0; i--)&#123;</span><br><span class=\"line\">        if(m%i==0&amp;&amp;n%i==0)&#123;</span><br><span class=\"line\">            gcd = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return gcd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.欧几里得方法（辗转相除）</p>\n<p>m/n=k…r（k为商，r为余数）</p>\n<p>首先要明白的一点是gcd(m,n)=gcd(n,r)</p>\n<p>可以证明，设x为m,n的公约数，r=m-nk,能整除m,n的数，那一定也能整除r。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int gcd(int m,int n)&#123;</span><br><span class=\"line\">        if(m%n==0)</span><br><span class=\"line\">            return n;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            return gcd(n, m%n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"桶排序和基数排序\"><a href=\"#桶排序和基数排序\" class=\"headerlink\" title=\"桶排序和基数排序\"></a>桶排序和基数排序</h4><h4 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h4>"},{"title":"javascript中的异步","author":"peng","date":"2019-03-28T16:00:00.000Z","_content":"\n### js为什么要有异步\n\njs是单线程的，也就是说程序的执行\n\n### 异步实现原理\n\n### 常用的异步操作\n\n","source":"_drafts/js-async.md","raw":"---\ntitle: javascript中的异步\nauthor: 'peng'\ndate: 2019-03-29\n---\n\n### js为什么要有异步\n\njs是单线程的，也就是说程序的执行\n\n### 异步实现原理\n\n### 常用的异步操作\n\n","slug":"js-async","published":0,"updated":"2019-05-20T01:19:07.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u400087tcyyf34upmq","content":"<h3 id=\"js为什么要有异步\"><a href=\"#js为什么要有异步\" class=\"headerlink\" title=\"js为什么要有异步\"></a>js为什么要有异步</h3><p>js是单线程的，也就是说程序的执行</p>\n<h3 id=\"异步实现原理\"><a href=\"#异步实现原理\" class=\"headerlink\" title=\"异步实现原理\"></a>异步实现原理</h3><h3 id=\"常用的异步操作\"><a href=\"#常用的异步操作\" class=\"headerlink\" title=\"常用的异步操作\"></a>常用的异步操作</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js为什么要有异步\"><a href=\"#js为什么要有异步\" class=\"headerlink\" title=\"js为什么要有异步\"></a>js为什么要有异步</h3><p>js是单线程的，也就是说程序的执行</p>\n<h3 id=\"异步实现原理\"><a href=\"#异步实现原理\" class=\"headerlink\" title=\"异步实现原理\"></a>异步实现原理</h3><h3 id=\"常用的异步操作\"><a href=\"#常用的异步操作\" class=\"headerlink\" title=\"常用的异步操作\"></a>常用的异步操作</h3>"},{"title":"学习react","author":"0x17","date":"2018-03-25T16:00:00.000Z","_content":"\n### redux基本原则\n\n1.唯一数据源。状态数据应该只储存到唯一的一个store上，如果状态数据分散在多个数据源上，可能会造成数据的冗余，影响数据的一致性。\n\n2.保持状态只读。不能直接修改状态，如果要修改的话需要通过dispatch一个action对象来完成，并且修改并不是直接修改store的值，而是生成一个newStore给redux，由redux来进行状态的更新。\n\n3.数据改变只能通过纯函数完成。这里的纯函数指的就是reducer，满足纯函数的条件是函数的返回只由函数的输入决定，并且执行过程中不会产生副作用。\n\n### 构建react项目前需考虑的事项\n\n1.代码文件的组织结构。\n\n2.确定模块边界。\n\n3.store状态树的设计。\n","source":"_drafts/learningReact.md","raw":"---\ntitle: 学习react\nauthor: '0x17'\ndate: 2018-03-26\n---\n\n### redux基本原则\n\n1.唯一数据源。状态数据应该只储存到唯一的一个store上，如果状态数据分散在多个数据源上，可能会造成数据的冗余，影响数据的一致性。\n\n2.保持状态只读。不能直接修改状态，如果要修改的话需要通过dispatch一个action对象来完成，并且修改并不是直接修改store的值，而是生成一个newStore给redux，由redux来进行状态的更新。\n\n3.数据改变只能通过纯函数完成。这里的纯函数指的就是reducer，满足纯函数的条件是函数的返回只由函数的输入决定，并且执行过程中不会产生副作用。\n\n### 构建react项目前需考虑的事项\n\n1.代码文件的组织结构。\n\n2.确定模块边界。\n\n3.store状态树的设计。\n","slug":"learningReact","published":0,"updated":"2019-05-20T01:19:07.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u500097tcynud5ngzh","content":"<h3 id=\"redux基本原则\"><a href=\"#redux基本原则\" class=\"headerlink\" title=\"redux基本原则\"></a>redux基本原则</h3><p>1.唯一数据源。状态数据应该只储存到唯一的一个store上，如果状态数据分散在多个数据源上，可能会造成数据的冗余，影响数据的一致性。</p>\n<p>2.保持状态只读。不能直接修改状态，如果要修改的话需要通过dispatch一个action对象来完成，并且修改并不是直接修改store的值，而是生成一个newStore给redux，由redux来进行状态的更新。</p>\n<p>3.数据改变只能通过纯函数完成。这里的纯函数指的就是reducer，满足纯函数的条件是函数的返回只由函数的输入决定，并且执行过程中不会产生副作用。</p>\n<h3 id=\"构建react项目前需考虑的事项\"><a href=\"#构建react项目前需考虑的事项\" class=\"headerlink\" title=\"构建react项目前需考虑的事项\"></a>构建react项目前需考虑的事项</h3><p>1.代码文件的组织结构。</p>\n<p>2.确定模块边界。</p>\n<p>3.store状态树的设计。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"redux基本原则\"><a href=\"#redux基本原则\" class=\"headerlink\" title=\"redux基本原则\"></a>redux基本原则</h3><p>1.唯一数据源。状态数据应该只储存到唯一的一个store上，如果状态数据分散在多个数据源上，可能会造成数据的冗余，影响数据的一致性。</p>\n<p>2.保持状态只读。不能直接修改状态，如果要修改的话需要通过dispatch一个action对象来完成，并且修改并不是直接修改store的值，而是生成一个newStore给redux，由redux来进行状态的更新。</p>\n<p>3.数据改变只能通过纯函数完成。这里的纯函数指的就是reducer，满足纯函数的条件是函数的返回只由函数的输入决定，并且执行过程中不会产生副作用。</p>\n<h3 id=\"构建react项目前需考虑的事项\"><a href=\"#构建react项目前需考虑的事项\" class=\"headerlink\" title=\"构建react项目前需考虑的事项\"></a>构建react项目前需考虑的事项</h3><p>1.代码文件的组织结构。</p>\n<p>2.确定模块边界。</p>\n<p>3.store状态树的设计。</p>\n"},{"title":"Javascript基础","author":"0x17","date":"2019-03-26T16:00:00.000Z","_content":"\n### 解构运算符、拓展运算符、rest运算符\n\n解构运算符：作用是快速获取对象或数组中的元素。\n\n```\n变量名与结构对象属性名不一致\nvar obj = {\n    name: 'Jack',\n    sex: 'male',\n    age: 18\n};\nvar {name: nickname, sex: gender} = obj;\nconsole.log(nickname + ' is a ' + gender);\n\n对象嵌套数组解构\nobj = {\n    name: 'chris',\n    sex: 'male',\n    age: [1, 2, 3]\n}\n\n{name, sex, age: [a, b, c]} = obj;\nconsole.log(c);\n\n对象嵌套对象属性名重复时解构\nvar obj = {\n    name: 'chris',\n    sex: 'male',\n    age: 26,\n    son: {\n        name: '大熊',\n        sex: 'male',\n        age: 1\n        }\n    };\n    //赋值解构\nvar {name: fathername, son: {name, sex, age}} = obj;\nconsole.log(fathername); //chris\nconsole.log(name);\n\n变量值互换\nvar a = 1,\n    b = 2;\n\nvar [b, a] = [a, b];\nconsole.log(a + ' ' + b);\n\n字符串解构\nvar str = 'hello';\nvar [a, b, c, d, e] = str;\nconsole.log(a + ' '  + b);//a b\n``` \n\n拓展运算符：把数组或对象展开成由逗号隔开的值\n\n```\n深拷贝\nvar a = [1, 2];\nvar b = a;\nvar c = [...a];\nconsole.log(a === b);//true\nconsole.log(a === c);//false\n\n字符串转数组\nvar str = 'hello';\nvar exstr = [...str];\nconsole.log(exstr);//['h', 'e', 'l', 'l', 'o']\n```\n\nrest运算符：作用与拓展运算符相反\n","source":"_drafts/theBasicOfJavascript.md","raw":"---\ntitle: Javascript基础\nauthor: '0x17'\ndate: 2019-03-27\n---\n\n### 解构运算符、拓展运算符、rest运算符\n\n解构运算符：作用是快速获取对象或数组中的元素。\n\n```\n变量名与结构对象属性名不一致\nvar obj = {\n    name: 'Jack',\n    sex: 'male',\n    age: 18\n};\nvar {name: nickname, sex: gender} = obj;\nconsole.log(nickname + ' is a ' + gender);\n\n对象嵌套数组解构\nobj = {\n    name: 'chris',\n    sex: 'male',\n    age: [1, 2, 3]\n}\n\n{name, sex, age: [a, b, c]} = obj;\nconsole.log(c);\n\n对象嵌套对象属性名重复时解构\nvar obj = {\n    name: 'chris',\n    sex: 'male',\n    age: 26,\n    son: {\n        name: '大熊',\n        sex: 'male',\n        age: 1\n        }\n    };\n    //赋值解构\nvar {name: fathername, son: {name, sex, age}} = obj;\nconsole.log(fathername); //chris\nconsole.log(name);\n\n变量值互换\nvar a = 1,\n    b = 2;\n\nvar [b, a] = [a, b];\nconsole.log(a + ' ' + b);\n\n字符串解构\nvar str = 'hello';\nvar [a, b, c, d, e] = str;\nconsole.log(a + ' '  + b);//a b\n``` \n\n拓展运算符：把数组或对象展开成由逗号隔开的值\n\n```\n深拷贝\nvar a = [1, 2];\nvar b = a;\nvar c = [...a];\nconsole.log(a === b);//true\nconsole.log(a === c);//false\n\n字符串转数组\nvar str = 'hello';\nvar exstr = [...str];\nconsole.log(exstr);//['h', 'e', 'l', 'l', 'o']\n```\n\nrest运算符：作用与拓展运算符相反\n","slug":"theBasicOfJavascript","published":0,"updated":"2019-05-20T01:19:07.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u6000a7tcyiu4s54sk","content":"<h3 id=\"解构运算符、拓展运算符、rest运算符\"><a href=\"#解构运算符、拓展运算符、rest运算符\" class=\"headerlink\" title=\"解构运算符、拓展运算符、rest运算符\"></a>解构运算符、拓展运算符、rest运算符</h3><p>解构运算符：作用是快速获取对象或数组中的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名与结构对象属性名不一致</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;Jack&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: 18</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var &#123;name: nickname, sex: gender&#125; = obj;</span><br><span class=\"line\">console.log(nickname + &apos; is a &apos; + gender);</span><br><span class=\"line\"></span><br><span class=\"line\">对象嵌套数组解构</span><br><span class=\"line\">obj = &#123;</span><br><span class=\"line\">    name: &apos;chris&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: [1, 2, 3]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;name, sex, age: [a, b, c]&#125; = obj;</span><br><span class=\"line\">console.log(c);</span><br><span class=\"line\"></span><br><span class=\"line\">对象嵌套对象属性名重复时解构</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;chris&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: 26,</span><br><span class=\"line\">    son: &#123;</span><br><span class=\"line\">        name: &apos;大熊&apos;,</span><br><span class=\"line\">        sex: &apos;male&apos;,</span><br><span class=\"line\">        age: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //赋值解构</span><br><span class=\"line\">var &#123;name: fathername, son: &#123;name, sex, age&#125;&#125; = obj;</span><br><span class=\"line\">console.log(fathername); //chris</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\"></span><br><span class=\"line\">变量值互换</span><br><span class=\"line\">var a = 1,</span><br><span class=\"line\">    b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">var [b, a] = [a, b];</span><br><span class=\"line\">console.log(a + &apos; &apos; + b);</span><br><span class=\"line\"></span><br><span class=\"line\">字符串解构</span><br><span class=\"line\">var str = &apos;hello&apos;;</span><br><span class=\"line\">var [a, b, c, d, e] = str;</span><br><span class=\"line\">console.log(a + &apos; &apos;  + b);//a b</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">拓展运算符：把数组或对象展开成由逗号隔开的值</span><br></pre></td></tr></table></figure>\n<p>深拷贝<br>var a = [1, 2];<br>var b = a;<br>var c = […a];<br>console.log(a === b);//true<br>console.log(a === c);//false</p>\n<p>字符串转数组<br>var str = ‘hello’;<br>var exstr = […str];<br>console.log(exstr);//[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]<br><code>`</code></p>\n<p>rest运算符：作用与拓展运算符相反</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"解构运算符、拓展运算符、rest运算符\"><a href=\"#解构运算符、拓展运算符、rest运算符\" class=\"headerlink\" title=\"解构运算符、拓展运算符、rest运算符\"></a>解构运算符、拓展运算符、rest运算符</h3><p>解构运算符：作用是快速获取对象或数组中的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名与结构对象属性名不一致</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;Jack&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: 18</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var &#123;name: nickname, sex: gender&#125; = obj;</span><br><span class=\"line\">console.log(nickname + &apos; is a &apos; + gender);</span><br><span class=\"line\"></span><br><span class=\"line\">对象嵌套数组解构</span><br><span class=\"line\">obj = &#123;</span><br><span class=\"line\">    name: &apos;chris&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: [1, 2, 3]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;name, sex, age: [a, b, c]&#125; = obj;</span><br><span class=\"line\">console.log(c);</span><br><span class=\"line\"></span><br><span class=\"line\">对象嵌套对象属性名重复时解构</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;chris&apos;,</span><br><span class=\"line\">    sex: &apos;male&apos;,</span><br><span class=\"line\">    age: 26,</span><br><span class=\"line\">    son: &#123;</span><br><span class=\"line\">        name: &apos;大熊&apos;,</span><br><span class=\"line\">        sex: &apos;male&apos;,</span><br><span class=\"line\">        age: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //赋值解构</span><br><span class=\"line\">var &#123;name: fathername, son: &#123;name, sex, age&#125;&#125; = obj;</span><br><span class=\"line\">console.log(fathername); //chris</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\"></span><br><span class=\"line\">变量值互换</span><br><span class=\"line\">var a = 1,</span><br><span class=\"line\">    b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">var [b, a] = [a, b];</span><br><span class=\"line\">console.log(a + &apos; &apos; + b);</span><br><span class=\"line\"></span><br><span class=\"line\">字符串解构</span><br><span class=\"line\">var str = &apos;hello&apos;;</span><br><span class=\"line\">var [a, b, c, d, e] = str;</span><br><span class=\"line\">console.log(a + &apos; &apos;  + b);//a b</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">拓展运算符：把数组或对象展开成由逗号隔开的值</span><br></pre></td></tr></table></figure>\n<p>深拷贝<br>var a = [1, 2];<br>var b = a;<br>var c = […a];<br>console.log(a === b);//true<br>console.log(a === c);//false</p>\n<p>字符串转数组<br>var str = ‘hello’;<br>var exstr = […str];<br>console.log(exstr);//[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]<br><code>`</code></p>\n<p>rest运算符：作用与拓展运算符相反</p>\n"},{"title":"Javaweb","_content":"\n### Spring框架\n\nSpring是一个开源项目，是一个基于IOC和AOP的的框架。它解决的是业务逻辑层和其他各层松耦合的问题，因此它将面向接口的编程思想贯穿整个系统应用。\n\n#### DI与IOC\n\n#### AOP\n\n### mvc设计模式\n\nmvc是模型(model)\n\n### servlet\n\n狭义上来说servlet是一个接口，其内部定义了五个方法。广义上来说它是所有实现这个接口的类，它只有在servlet容器中才能真正工作，也就是tomcat服务器中，tomcat管理servlet的生命周期，tomcat监听tcp端口，接受http请求，然后将请求交由相应的servlet处理。","source":"_drafts/web框架学习.md","raw":"---\ntitle: Javaweb\ntags:\n---\n\n### Spring框架\n\nSpring是一个开源项目，是一个基于IOC和AOP的的框架。它解决的是业务逻辑层和其他各层松耦合的问题，因此它将面向接口的编程思想贯穿整个系统应用。\n\n#### DI与IOC\n\n#### AOP\n\n### mvc设计模式\n\nmvc是模型(model)\n\n### servlet\n\n狭义上来说servlet是一个接口，其内部定义了五个方法。广义上来说它是所有实现这个接口的类，它只有在servlet容器中才能真正工作，也就是tomcat服务器中，tomcat管理servlet的生命周期，tomcat监听tcp端口，接受http请求，然后将请求交由相应的servlet处理。","slug":"web框架学习","published":0,"date":"2018-10-05T02:39:15.204Z","updated":"2018-10-05T02:39:15.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9u8000b7tcy6pb6mho9","content":"<h3 id=\"Spring框架\"><a href=\"#Spring框架\" class=\"headerlink\" title=\"Spring框架\"></a>Spring框架</h3><p>Spring是一个开源项目，是一个基于IOC和AOP的的框架。它解决的是业务逻辑层和其他各层松耦合的问题，因此它将面向接口的编程思想贯穿整个系统应用。</p>\n<h4 id=\"DI与IOC\"><a href=\"#DI与IOC\" class=\"headerlink\" title=\"DI与IOC\"></a>DI与IOC</h4><h4 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h4><h3 id=\"mvc设计模式\"><a href=\"#mvc设计模式\" class=\"headerlink\" title=\"mvc设计模式\"></a>mvc设计模式</h3><p>mvc是模型(model)</p>\n<h3 id=\"servlet\"><a href=\"#servlet\" class=\"headerlink\" title=\"servlet\"></a>servlet</h3><p>狭义上来说servlet是一个接口，其内部定义了五个方法。广义上来说它是所有实现这个接口的类，它只有在servlet容器中才能真正工作，也就是tomcat服务器中，tomcat管理servlet的生命周期，tomcat监听tcp端口，接受http请求，然后将请求交由相应的servlet处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Spring框架\"><a href=\"#Spring框架\" class=\"headerlink\" title=\"Spring框架\"></a>Spring框架</h3><p>Spring是一个开源项目，是一个基于IOC和AOP的的框架。它解决的是业务逻辑层和其他各层松耦合的问题，因此它将面向接口的编程思想贯穿整个系统应用。</p>\n<h4 id=\"DI与IOC\"><a href=\"#DI与IOC\" class=\"headerlink\" title=\"DI与IOC\"></a>DI与IOC</h4><h4 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h4><h3 id=\"mvc设计模式\"><a href=\"#mvc设计模式\" class=\"headerlink\" title=\"mvc设计模式\"></a>mvc设计模式</h3><p>mvc是模型(model)</p>\n<h3 id=\"servlet\"><a href=\"#servlet\" class=\"headerlink\" title=\"servlet\"></a>servlet</h3><p>狭义上来说servlet是一个接口，其内部定义了五个方法。广义上来说它是所有实现这个接口的类，它只有在servlet容器中才能真正工作，也就是tomcat服务器中，tomcat管理servlet的生命周期，tomcat监听tcp端口，接受http请求，然后将请求交由相应的servlet处理。</p>\n"},{"title":"vsftpd的使用","author":23,"date":"2018-08-03T11:10:00.000Z","tag":null,"_content":"\n### FTP\n\nFTP的全称是文件传输协议，用于Internet上控制文件双向传输，同时它也是一种应用，不同操作系用具有不同的FTP应用，他们都遵守同一种协议传输文件，FTP命令端口是21，数据传输端口是20。\n\n\nFTP的传输方式有两种：ASCII、二进制（区别是一种以字节流的形式传输，一种以二进制流的形式传输）\n\n\nFTP支持的两种模式：\n\n1.PORT方式，主动方式：FTP客户端首先通过21端口建立连接，通过这个端口的连接向FTP服务器发送命令，命令中包含了客户端使用那个端口接受数据。发送数据时，FTP服务器通过20端口向客户端指定端口建立连接用来发送数据。\n\n2.PASV方式，被动方式：FTP接受客户端发送请求数据的命令后，打开一个临时端口（大于1023小于65535）并通知客户端进行连接，然后这这个连接上传输数据。\n\n注意：一般客户端主机都有防火墙，因此通过PORT方式传输数据会被防火墙拦截。如果客户端没有公网IP,此时必须用PASV方式。","source":"_drafts/vsftpd的使用.md","raw":"---\ntitle: vsftpd的使用\nauthor: 0x17\ndate: 2018-08-03 19:10:00\ntag:\n---\n\n### FTP\n\nFTP的全称是文件传输协议，用于Internet上控制文件双向传输，同时它也是一种应用，不同操作系用具有不同的FTP应用，他们都遵守同一种协议传输文件，FTP命令端口是21，数据传输端口是20。\n\n\nFTP的传输方式有两种：ASCII、二进制（区别是一种以字节流的形式传输，一种以二进制流的形式传输）\n\n\nFTP支持的两种模式：\n\n1.PORT方式，主动方式：FTP客户端首先通过21端口建立连接，通过这个端口的连接向FTP服务器发送命令，命令中包含了客户端使用那个端口接受数据。发送数据时，FTP服务器通过20端口向客户端指定端口建立连接用来发送数据。\n\n2.PASV方式，被动方式：FTP接受客户端发送请求数据的命令后，打开一个临时端口（大于1023小于65535）并通知客户端进行连接，然后这这个连接上传输数据。\n\n注意：一般客户端主机都有防火墙，因此通过PORT方式传输数据会被防火墙拦截。如果客户端没有公网IP,此时必须用PASV方式。","slug":"vsftpd的使用","published":0,"updated":"2018-10-05T02:39:15.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ua000c7tcyb95hoxeq","content":"<h3 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h3><p>FTP的全称是文件传输协议，用于Internet上控制文件双向传输，同时它也是一种应用，不同操作系用具有不同的FTP应用，他们都遵守同一种协议传输文件，FTP命令端口是21，数据传输端口是20。</p>\n<p>FTP的传输方式有两种：ASCII、二进制（区别是一种以字节流的形式传输，一种以二进制流的形式传输）</p>\n<p>FTP支持的两种模式：</p>\n<p>1.PORT方式，主动方式：FTP客户端首先通过21端口建立连接，通过这个端口的连接向FTP服务器发送命令，命令中包含了客户端使用那个端口接受数据。发送数据时，FTP服务器通过20端口向客户端指定端口建立连接用来发送数据。</p>\n<p>2.PASV方式，被动方式：FTP接受客户端发送请求数据的命令后，打开一个临时端口（大于1023小于65535）并通知客户端进行连接，然后这这个连接上传输数据。</p>\n<p>注意：一般客户端主机都有防火墙，因此通过PORT方式传输数据会被防火墙拦截。如果客户端没有公网IP,此时必须用PASV方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h3><p>FTP的全称是文件传输协议，用于Internet上控制文件双向传输，同时它也是一种应用，不同操作系用具有不同的FTP应用，他们都遵守同一种协议传输文件，FTP命令端口是21，数据传输端口是20。</p>\n<p>FTP的传输方式有两种：ASCII、二进制（区别是一种以字节流的形式传输，一种以二进制流的形式传输）</p>\n<p>FTP支持的两种模式：</p>\n<p>1.PORT方式，主动方式：FTP客户端首先通过21端口建立连接，通过这个端口的连接向FTP服务器发送命令，命令中包含了客户端使用那个端口接受数据。发送数据时，FTP服务器通过20端口向客户端指定端口建立连接用来发送数据。</p>\n<p>2.PASV方式，被动方式：FTP接受客户端发送请求数据的命令后，打开一个临时端口（大于1023小于65535）并通知客户端进行连接，然后这这个连接上传输数据。</p>\n<p>注意：一般客户端主机都有防火墙，因此通过PORT方式传输数据会被防火墙拦截。如果客户端没有公网IP,此时必须用PASV方式。</p>\n"},{"title":"大四上学期实习准备事项","author":23,"tag":null,"_content":"\n### 面试准备\n\n先准备好项目，再准备好复习面试题目。虽然现在已经面好一家，但是万一不符合预期，可以临时准备面试其他公司。\n\n9.17-9.25：完成项目一，科目四准备一下\n\n9.26-10.5：完善项目二\n\n10.6-10.9：面试题刷一刷\n\n### 进程与线程\n\n#### 进程与线程的区别\n\n#### 进程间的通信\n\n### 存储\n\n硬盘->内存->缓存->寄存器\n\n#### 寻址空间","source":"_drafts/准备事项.md","raw":"---\ntitle: 大四上学期实习准备事项\nauthor: 0x17\ntag:\n---\n\n### 面试准备\n\n先准备好项目，再准备好复习面试题目。虽然现在已经面好一家，但是万一不符合预期，可以临时准备面试其他公司。\n\n9.17-9.25：完成项目一，科目四准备一下\n\n9.26-10.5：完善项目二\n\n10.6-10.9：面试题刷一刷\n\n### 进程与线程\n\n#### 进程与线程的区别\n\n#### 进程间的通信\n\n### 存储\n\n硬盘->内存->缓存->寄存器\n\n#### 寻址空间","slug":"准备事项","published":0,"date":"2018-10-05T02:39:15.204Z","updated":"2018-10-05T02:39:15.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9uc000d7tcyo50y640k","content":"<h3 id=\"面试准备\"><a href=\"#面试准备\" class=\"headerlink\" title=\"面试准备\"></a>面试准备</h3><p>先准备好项目，再准备好复习面试题目。虽然现在已经面好一家，但是万一不符合预期，可以临时准备面试其他公司。</p>\n<p>9.17-9.25：完成项目一，科目四准备一下</p>\n<p>9.26-10.5：完善项目二</p>\n<p>10.6-10.9：面试题刷一刷</p>\n<h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><h4 id=\"进程与线程的区别\"><a href=\"#进程与线程的区别\" class=\"headerlink\" title=\"进程与线程的区别\"></a>进程与线程的区别</h4><h4 id=\"进程间的通信\"><a href=\"#进程间的通信\" class=\"headerlink\" title=\"进程间的通信\"></a>进程间的通信</h4><h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><p>硬盘-&gt;内存-&gt;缓存-&gt;寄存器</p>\n<h4 id=\"寻址空间\"><a href=\"#寻址空间\" class=\"headerlink\" title=\"寻址空间\"></a>寻址空间</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"面试准备\"><a href=\"#面试准备\" class=\"headerlink\" title=\"面试准备\"></a>面试准备</h3><p>先准备好项目，再准备好复习面试题目。虽然现在已经面好一家，但是万一不符合预期，可以临时准备面试其他公司。</p>\n<p>9.17-9.25：完成项目一，科目四准备一下</p>\n<p>9.26-10.5：完善项目二</p>\n<p>10.6-10.9：面试题刷一刷</p>\n<h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><h4 id=\"进程与线程的区别\"><a href=\"#进程与线程的区别\" class=\"headerlink\" title=\"进程与线程的区别\"></a>进程与线程的区别</h4><h4 id=\"进程间的通信\"><a href=\"#进程间的通信\" class=\"headerlink\" title=\"进程间的通信\"></a>进程间的通信</h4><h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><p>硬盘-&gt;内存-&gt;缓存-&gt;寄存器</p>\n<h4 id=\"寻址空间\"><a href=\"#寻址空间\" class=\"headerlink\" title=\"寻址空间\"></a>寻址空间</h4>"},{"title":"java中的IO","_content":"","source":"_drafts/java中的IO.md","raw":"---\ntitle: java中的IO\ntags:\n---\n","slug":"java中的IO","published":0,"date":"2018-10-05T02:39:15.203Z","updated":"2018-10-05T02:39:15.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ud000e7tcyk3llxvuq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"准备及期望","_content":"\n### 准备物品\n\n1.入职材料（照片、省份证正反复印件、学生证复印件、体检报告（胸透、肝功能、血常规）、中国银行银行卡）\n\n2.视频硬盘\n\n3.两本书（算法和计算机网络）\n\n4.耳机\n\n5.e-book\n\n6.指甲剪、梳子、剃须刀\n\n### 期望\n\n#### 基础技能的提升\n\n看学习视频\n\n深入学习Linux系统原理\n\n系统了解计算机网络\n\n#### 收获实际工作经验\n\n了解到公司中项目开发的流程及分工\n\n项目开发中如何沟通协作\n\n优化自己工作的代码\n\n#### 最终期望\n\n能在明年初找到一家更好的公司","source":"_drafts/准备及期望.md","raw":"---\ntitle: 准备及期望\ntags:\n---\n\n### 准备物品\n\n1.入职材料（照片、省份证正反复印件、学生证复印件、体检报告（胸透、肝功能、血常规）、中国银行银行卡）\n\n2.视频硬盘\n\n3.两本书（算法和计算机网络）\n\n4.耳机\n\n5.e-book\n\n6.指甲剪、梳子、剃须刀\n\n### 期望\n\n#### 基础技能的提升\n\n看学习视频\n\n深入学习Linux系统原理\n\n系统了解计算机网络\n\n#### 收获实际工作经验\n\n了解到公司中项目开发的流程及分工\n\n项目开发中如何沟通协作\n\n优化自己工作的代码\n\n#### 最终期望\n\n能在明年初找到一家更好的公司","slug":"准备及期望","published":0,"date":"2018-10-05T02:39:15.204Z","updated":"2018-10-05T02:39:15.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ul000f7tcygevoc0z9","content":"<h3 id=\"准备物品\"><a href=\"#准备物品\" class=\"headerlink\" title=\"准备物品\"></a>准备物品</h3><p>1.入职材料（照片、省份证正反复印件、学生证复印件、体检报告（胸透、肝功能、血常规）、中国银行银行卡）</p>\n<p>2.视频硬盘</p>\n<p>3.两本书（算法和计算机网络）</p>\n<p>4.耳机</p>\n<p>5.e-book</p>\n<p>6.指甲剪、梳子、剃须刀</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><h4 id=\"基础技能的提升\"><a href=\"#基础技能的提升\" class=\"headerlink\" title=\"基础技能的提升\"></a>基础技能的提升</h4><p>看学习视频</p>\n<p>深入学习Linux系统原理</p>\n<p>系统了解计算机网络</p>\n<h4 id=\"收获实际工作经验\"><a href=\"#收获实际工作经验\" class=\"headerlink\" title=\"收获实际工作经验\"></a>收获实际工作经验</h4><p>了解到公司中项目开发的流程及分工</p>\n<p>项目开发中如何沟通协作</p>\n<p>优化自己工作的代码</p>\n<h4 id=\"最终期望\"><a href=\"#最终期望\" class=\"headerlink\" title=\"最终期望\"></a>最终期望</h4><p>能在明年初找到一家更好的公司</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"准备物品\"><a href=\"#准备物品\" class=\"headerlink\" title=\"准备物品\"></a>准备物品</h3><p>1.入职材料（照片、省份证正反复印件、学生证复印件、体检报告（胸透、肝功能、血常规）、中国银行银行卡）</p>\n<p>2.视频硬盘</p>\n<p>3.两本书（算法和计算机网络）</p>\n<p>4.耳机</p>\n<p>5.e-book</p>\n<p>6.指甲剪、梳子、剃须刀</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><h4 id=\"基础技能的提升\"><a href=\"#基础技能的提升\" class=\"headerlink\" title=\"基础技能的提升\"></a>基础技能的提升</h4><p>看学习视频</p>\n<p>深入学习Linux系统原理</p>\n<p>系统了解计算机网络</p>\n<h4 id=\"收获实际工作经验\"><a href=\"#收获实际工作经验\" class=\"headerlink\" title=\"收获实际工作经验\"></a>收获实际工作经验</h4><p>了解到公司中项目开发的流程及分工</p>\n<p>项目开发中如何沟通协作</p>\n<p>优化自己工作的代码</p>\n<h4 id=\"最终期望\"><a href=\"#最终期望\" class=\"headerlink\" title=\"最终期望\"></a>最终期望</h4><p>能在明年初找到一家更好的公司</p>\n"},{"title":"大学毕业","author":23,"_content":"\n![Please Wait](2019-5-25.jpg)\n","source":"_drafts/大学毕业.md","raw":"---\ntitle: 大学毕业\nauthor: 0x17\ntags:\n---\n\n![Please Wait](2019-5-25.jpg)\n","slug":"大学毕业","published":0,"date":"2019-05-25T15:12:48.747Z","updated":"2019-05-25T15:12:48.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9um000g7tcy3548w0eo","content":"<p><img src=\"/2019/05/25/大学毕业/2019-5-25.jpg\" alt=\"Please Wait\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/05/25/大学毕业/2019-5-25.jpg\" alt=\"Please Wait\"></p>\n"},{"title":"字符集和编码规则","autho":"peng","date":"2019-03-30T16:00:00.000Z","_content":"\n### ASCII(ISO-646)\n\nASCII(American Standard Code for Information Interchange)是由美国标准化组织(ANSI)发布的第一个计算机字符集，后成为国际标准ISO-646。\n这个字符集用7位来表示包括95个可显字符和33个控制字符。\n\n### UCS-4与UCS-2\n\nUCS(Universal Multiple-Octet Coded Character Set)是一个可以容纳世界上所有文字符号的字符集，标准为ISO-10646。这个字符集用四个字节来表示字符，第一个字节表示组，由7位表示128个组；第二个字节表示面，有256个面，但是每面包含256*256-2个码位，因为每面最后两个码位保留，**保留原因暂不知**，第三个字节表示行，第四个字节表示格。IOS-10646标准的0组0面称为BMP，去掉头两位可以转换为两个字节编码的UCS-2。\n\n### Unicode与UTF-8\n\nUnicode是字符集。\nUTF-8(Unicode Transformation Format)是编码规则。\n\n字符集：位每一个字符分配唯一的ID（码位/码点），可以理解位将字符数字化。\n编码规则：将码位转换位字节序列的规则，可以理解为对每个码位重新编码，更好的存储和传输。\n\nUnicode广义上来说可以是一个标准，包括一个Unicode字符集以及一系列编码规则（UTF-8,UTF-16...）。\nUTF-8是一套一8位为一个编码单位的可变长编码，可将一个码位编码1~4个字节。\n","source":"_drafts/字符集和编码规则.md","raw":"---\ntitle: 字符集和编码规则\nautho: 'peng'\ndate: 2019-03-31\n---\n\n### ASCII(ISO-646)\n\nASCII(American Standard Code for Information Interchange)是由美国标准化组织(ANSI)发布的第一个计算机字符集，后成为国际标准ISO-646。\n这个字符集用7位来表示包括95个可显字符和33个控制字符。\n\n### UCS-4与UCS-2\n\nUCS(Universal Multiple-Octet Coded Character Set)是一个可以容纳世界上所有文字符号的字符集，标准为ISO-10646。这个字符集用四个字节来表示字符，第一个字节表示组，由7位表示128个组；第二个字节表示面，有256个面，但是每面包含256*256-2个码位，因为每面最后两个码位保留，**保留原因暂不知**，第三个字节表示行，第四个字节表示格。IOS-10646标准的0组0面称为BMP，去掉头两位可以转换为两个字节编码的UCS-2。\n\n### Unicode与UTF-8\n\nUnicode是字符集。\nUTF-8(Unicode Transformation Format)是编码规则。\n\n字符集：位每一个字符分配唯一的ID（码位/码点），可以理解位将字符数字化。\n编码规则：将码位转换位字节序列的规则，可以理解为对每个码位重新编码，更好的存储和传输。\n\nUnicode广义上来说可以是一个标准，包括一个Unicode字符集以及一系列编码规则（UTF-8,UTF-16...）。\nUTF-8是一套一8位为一个编码单位的可变长编码，可将一个码位编码1~4个字节。\n","slug":"字符集和编码规则","published":0,"updated":"2019-05-20T01:19:07.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9un000h7tcywtd43gi3","content":"<h3 id=\"ASCII-ISO-646\"><a href=\"#ASCII-ISO-646\" class=\"headerlink\" title=\"ASCII(ISO-646)\"></a>ASCII(ISO-646)</h3><p>ASCII(American Standard Code for Information Interchange)是由美国标准化组织(ANSI)发布的第一个计算机字符集，后成为国际标准ISO-646。<br>这个字符集用7位来表示包括95个可显字符和33个控制字符。</p>\n<h3 id=\"UCS-4与UCS-2\"><a href=\"#UCS-4与UCS-2\" class=\"headerlink\" title=\"UCS-4与UCS-2\"></a>UCS-4与UCS-2</h3><p>UCS(Universal Multiple-Octet Coded Character Set)是一个可以容纳世界上所有文字符号的字符集，标准为ISO-10646。这个字符集用四个字节来表示字符，第一个字节表示组，由7位表示128个组；第二个字节表示面，有256个面，但是每面包含256*256-2个码位，因为每面最后两个码位保留，<strong>保留原因暂不知</strong>，第三个字节表示行，第四个字节表示格。IOS-10646标准的0组0面称为BMP，去掉头两位可以转换为两个字节编码的UCS-2。</p>\n<h3 id=\"Unicode与UTF-8\"><a href=\"#Unicode与UTF-8\" class=\"headerlink\" title=\"Unicode与UTF-8\"></a>Unicode与UTF-8</h3><p>Unicode是字符集。<br>UTF-8(Unicode Transformation Format)是编码规则。</p>\n<p>字符集：位每一个字符分配唯一的ID（码位/码点），可以理解位将字符数字化。<br>编码规则：将码位转换位字节序列的规则，可以理解为对每个码位重新编码，更好的存储和传输。</p>\n<p>Unicode广义上来说可以是一个标准，包括一个Unicode字符集以及一系列编码规则（UTF-8,UTF-16…）。<br>UTF-8是一套一8位为一个编码单位的可变长编码，可将一个码位编码1~4个字节。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ASCII-ISO-646\"><a href=\"#ASCII-ISO-646\" class=\"headerlink\" title=\"ASCII(ISO-646)\"></a>ASCII(ISO-646)</h3><p>ASCII(American Standard Code for Information Interchange)是由美国标准化组织(ANSI)发布的第一个计算机字符集，后成为国际标准ISO-646。<br>这个字符集用7位来表示包括95个可显字符和33个控制字符。</p>\n<h3 id=\"UCS-4与UCS-2\"><a href=\"#UCS-4与UCS-2\" class=\"headerlink\" title=\"UCS-4与UCS-2\"></a>UCS-4与UCS-2</h3><p>UCS(Universal Multiple-Octet Coded Character Set)是一个可以容纳世界上所有文字符号的字符集，标准为ISO-10646。这个字符集用四个字节来表示字符，第一个字节表示组，由7位表示128个组；第二个字节表示面，有256个面，但是每面包含256*256-2个码位，因为每面最后两个码位保留，<strong>保留原因暂不知</strong>，第三个字节表示行，第四个字节表示格。IOS-10646标准的0组0面称为BMP，去掉头两位可以转换为两个字节编码的UCS-2。</p>\n<h3 id=\"Unicode与UTF-8\"><a href=\"#Unicode与UTF-8\" class=\"headerlink\" title=\"Unicode与UTF-8\"></a>Unicode与UTF-8</h3><p>Unicode是字符集。<br>UTF-8(Unicode Transformation Format)是编码规则。</p>\n<p>字符集：位每一个字符分配唯一的ID（码位/码点），可以理解位将字符数字化。<br>编码规则：将码位转换位字节序列的规则，可以理解为对每个码位重新编码，更好的存储和传输。</p>\n<p>Unicode广义上来说可以是一个标准，包括一个Unicode字符集以及一系列编码规则（UTF-8,UTF-16…）。<br>UTF-8是一套一8位为一个编码单位的可变长编码，可将一个码位编码1~4个字节。</p>\n"},{"title":"学习jvm","_content":"\njvm图解，在网上看到的一张图。\n\n![Please Wait](JVM-Architecture.png)\n\n### Class Loader(类加载器)\n\n### Runtime Data Area(运行时数据区))\n\n运行时内存区包括：程序计数器、JVM栈、本地方法栈、堆、方法区、运行时常量区\n\n#### Program Counter Register(程序计数器)\n\n程序计数器占据一小块内存，作用可以看作是当前线程所执行字节码的行号指示器，执行引擎通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都具有各自的一个程序计数器，方便线程切换时恢复到指定位置。在Java虚拟规范中自这个区域中没有规定OOM异常。\n\n#### JVM栈\n\nJVM栈也是线程私有的，描述的是Java方法执行的内存模型，用于储存局部变量表、操作栈、动态链接、方法出口等信息。每一个方法的调用直至结束对应一个栈帧的入栈和出栈。\n\n局部变量表中存放了Java中的基本数据类型，对象引用（reference类型不等于Object本身，它可以是指向对象起始地址，也可以指向一个代表对象的句柄，或者其他与对象相关的地址）。局部变量表的内存大小在编译期就可知并确定下来，在运行期不会改变它的大小。\n\n当线程请求的栈深度大于虚拟机所允许的深度就会报StackOverflowError异常，比如方法的递归调用。\n如果栈动态申请内存时没有足够内存可供申请就会发生OOM异常，比如像一个list中添加巨多数据。\n\n#### Native Method Stack(本地方法栈)\n\n本地方法栈与JVM栈类似，只不过调用的不是.class中的方法而是本地方法，Java中的本地方法描述的是一些更底层的操作，可以是其他语言写的。有的虚拟机（比如HotSpot）直接将JVM栈和本地方法栈合二为一。\n\n#### Heap(堆)\n\nJava堆是虚拟机所管理内存中最大的一块区域，在虚拟机启动时创建，几乎所有的内存实例都在此分配内存，是所有线程共享的。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap).\n\n大多数垃圾收集器都采用分代收集算法，因此Java堆可分为新生代和老年代，细致一些分的话可以分为Eden空间、From Survivor空间、To Survivor空间等。还有可能划分出线程私有的的分配缓冲区(Thread Local Allocation Buffer, TLAB)。\n\n堆的实现既可以是固定大小也可以是可拓展的(通过-Xmx和-Xms控制)。如果堆没有内存完成空间分配，并且无法拓展的时候就会报出OOM异常。\n\n#### 方法区\n\na方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码数据。虽然在Java虚拟机规范中把方法区描述为堆的一个逻辑分区，但是它却有一个别名Non-Heap与堆区分开来。\n\n#### 运行时常量池\n\n\n\n### Excution Engine(执行引擎)\n\n### Native Method Interface(本地方法接口)\n","source":"_drafts/学习jvm.md","raw":"---\ntitle: 学习jvm\ntags:\n---\n\njvm图解，在网上看到的一张图。\n\n![Please Wait](JVM-Architecture.png)\n\n### Class Loader(类加载器)\n\n### Runtime Data Area(运行时数据区))\n\n运行时内存区包括：程序计数器、JVM栈、本地方法栈、堆、方法区、运行时常量区\n\n#### Program Counter Register(程序计数器)\n\n程序计数器占据一小块内存，作用可以看作是当前线程所执行字节码的行号指示器，执行引擎通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都具有各自的一个程序计数器，方便线程切换时恢复到指定位置。在Java虚拟规范中自这个区域中没有规定OOM异常。\n\n#### JVM栈\n\nJVM栈也是线程私有的，描述的是Java方法执行的内存模型，用于储存局部变量表、操作栈、动态链接、方法出口等信息。每一个方法的调用直至结束对应一个栈帧的入栈和出栈。\n\n局部变量表中存放了Java中的基本数据类型，对象引用（reference类型不等于Object本身，它可以是指向对象起始地址，也可以指向一个代表对象的句柄，或者其他与对象相关的地址）。局部变量表的内存大小在编译期就可知并确定下来，在运行期不会改变它的大小。\n\n当线程请求的栈深度大于虚拟机所允许的深度就会报StackOverflowError异常，比如方法的递归调用。\n如果栈动态申请内存时没有足够内存可供申请就会发生OOM异常，比如像一个list中添加巨多数据。\n\n#### Native Method Stack(本地方法栈)\n\n本地方法栈与JVM栈类似，只不过调用的不是.class中的方法而是本地方法，Java中的本地方法描述的是一些更底层的操作，可以是其他语言写的。有的虚拟机（比如HotSpot）直接将JVM栈和本地方法栈合二为一。\n\n#### Heap(堆)\n\nJava堆是虚拟机所管理内存中最大的一块区域，在虚拟机启动时创建，几乎所有的内存实例都在此分配内存，是所有线程共享的。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap).\n\n大多数垃圾收集器都采用分代收集算法，因此Java堆可分为新生代和老年代，细致一些分的话可以分为Eden空间、From Survivor空间、To Survivor空间等。还有可能划分出线程私有的的分配缓冲区(Thread Local Allocation Buffer, TLAB)。\n\n堆的实现既可以是固定大小也可以是可拓展的(通过-Xmx和-Xms控制)。如果堆没有内存完成空间分配，并且无法拓展的时候就会报出OOM异常。\n\n#### 方法区\n\na方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码数据。虽然在Java虚拟机规范中把方法区描述为堆的一个逻辑分区，但是它却有一个别名Non-Heap与堆区分开来。\n\n#### 运行时常量池\n\n\n\n### Excution Engine(执行引擎)\n\n### Native Method Interface(本地方法接口)\n","slug":"学习jvm","published":0,"date":"2018-10-20T00:42:01.468Z","updated":"2018-10-20T00:42:01.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9up000i7tcyc66j1nmv","content":"<p>jvm图解，在网上看到的一张图。</p>\n<p><img src=\"/2018/10/20/学习jvm/JVM-Architecture.png\" alt=\"Please Wait\"></p>\n<h3 id=\"Class-Loader-类加载器\"><a href=\"#Class-Loader-类加载器\" class=\"headerlink\" title=\"Class Loader(类加载器)\"></a>Class Loader(类加载器)</h3><h3 id=\"Runtime-Data-Area-运行时数据区\"><a href=\"#Runtime-Data-Area-运行时数据区\" class=\"headerlink\" title=\"Runtime Data Area(运行时数据区))\"></a>Runtime Data Area(运行时数据区))</h3><p>运行时内存区包括：程序计数器、JVM栈、本地方法栈、堆、方法区、运行时常量区</p>\n<h4 id=\"Program-Counter-Register-程序计数器\"><a href=\"#Program-Counter-Register-程序计数器\" class=\"headerlink\" title=\"Program Counter Register(程序计数器)\"></a>Program Counter Register(程序计数器)</h4><p>程序计数器占据一小块内存，作用可以看作是当前线程所执行字节码的行号指示器，执行引擎通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都具有各自的一个程序计数器，方便线程切换时恢复到指定位置。在Java虚拟规范中自这个区域中没有规定OOM异常。</p>\n<h4 id=\"JVM栈\"><a href=\"#JVM栈\" class=\"headerlink\" title=\"JVM栈\"></a>JVM栈</h4><p>JVM栈也是线程私有的，描述的是Java方法执行的内存模型，用于储存局部变量表、操作栈、动态链接、方法出口等信息。每一个方法的调用直至结束对应一个栈帧的入栈和出栈。</p>\n<p>局部变量表中存放了Java中的基本数据类型，对象引用（reference类型不等于Object本身，它可以是指向对象起始地址，也可以指向一个代表对象的句柄，或者其他与对象相关的地址）。局部变量表的内存大小在编译期就可知并确定下来，在运行期不会改变它的大小。</p>\n<p>当线程请求的栈深度大于虚拟机所允许的深度就会报StackOverflowError异常，比如方法的递归调用。<br>如果栈动态申请内存时没有足够内存可供申请就会发生OOM异常，比如像一个list中添加巨多数据。</p>\n<h4 id=\"Native-Method-Stack-本地方法栈\"><a href=\"#Native-Method-Stack-本地方法栈\" class=\"headerlink\" title=\"Native Method Stack(本地方法栈)\"></a>Native Method Stack(本地方法栈)</h4><p>本地方法栈与JVM栈类似，只不过调用的不是.class中的方法而是本地方法，Java中的本地方法描述的是一些更底层的操作，可以是其他语言写的。有的虚拟机（比如HotSpot）直接将JVM栈和本地方法栈合二为一。</p>\n<h4 id=\"Heap-堆\"><a href=\"#Heap-堆\" class=\"headerlink\" title=\"Heap(堆)\"></a>Heap(堆)</h4><p>Java堆是虚拟机所管理内存中最大的一块区域，在虚拟机启动时创建，几乎所有的内存实例都在此分配内存，是所有线程共享的。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap).</p>\n<p>大多数垃圾收集器都采用分代收集算法，因此Java堆可分为新生代和老年代，细致一些分的话可以分为Eden空间、From Survivor空间、To Survivor空间等。还有可能划分出线程私有的的分配缓冲区(Thread Local Allocation Buffer, TLAB)。</p>\n<p>堆的实现既可以是固定大小也可以是可拓展的(通过-Xmx和-Xms控制)。如果堆没有内存完成空间分配，并且无法拓展的时候就会报出OOM异常。</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>a方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码数据。虽然在Java虚拟机规范中把方法区描述为堆的一个逻辑分区，但是它却有一个别名Non-Heap与堆区分开来。</p>\n<h4 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h4><h3 id=\"Excution-Engine-执行引擎\"><a href=\"#Excution-Engine-执行引擎\" class=\"headerlink\" title=\"Excution Engine(执行引擎)\"></a>Excution Engine(执行引擎)</h3><h3 id=\"Native-Method-Interface-本地方法接口\"><a href=\"#Native-Method-Interface-本地方法接口\" class=\"headerlink\" title=\"Native Method Interface(本地方法接口)\"></a>Native Method Interface(本地方法接口)</h3>","site":{"data":{}},"excerpt":"","more":"<p>jvm图解，在网上看到的一张图。</p>\n<p><img src=\"/2018/10/20/学习jvm/JVM-Architecture.png\" alt=\"Please Wait\"></p>\n<h3 id=\"Class-Loader-类加载器\"><a href=\"#Class-Loader-类加载器\" class=\"headerlink\" title=\"Class Loader(类加载器)\"></a>Class Loader(类加载器)</h3><h3 id=\"Runtime-Data-Area-运行时数据区\"><a href=\"#Runtime-Data-Area-运行时数据区\" class=\"headerlink\" title=\"Runtime Data Area(运行时数据区))\"></a>Runtime Data Area(运行时数据区))</h3><p>运行时内存区包括：程序计数器、JVM栈、本地方法栈、堆、方法区、运行时常量区</p>\n<h4 id=\"Program-Counter-Register-程序计数器\"><a href=\"#Program-Counter-Register-程序计数器\" class=\"headerlink\" title=\"Program Counter Register(程序计数器)\"></a>Program Counter Register(程序计数器)</h4><p>程序计数器占据一小块内存，作用可以看作是当前线程所执行字节码的行号指示器，执行引擎通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都具有各自的一个程序计数器，方便线程切换时恢复到指定位置。在Java虚拟规范中自这个区域中没有规定OOM异常。</p>\n<h4 id=\"JVM栈\"><a href=\"#JVM栈\" class=\"headerlink\" title=\"JVM栈\"></a>JVM栈</h4><p>JVM栈也是线程私有的，描述的是Java方法执行的内存模型，用于储存局部变量表、操作栈、动态链接、方法出口等信息。每一个方法的调用直至结束对应一个栈帧的入栈和出栈。</p>\n<p>局部变量表中存放了Java中的基本数据类型，对象引用（reference类型不等于Object本身，它可以是指向对象起始地址，也可以指向一个代表对象的句柄，或者其他与对象相关的地址）。局部变量表的内存大小在编译期就可知并确定下来，在运行期不会改变它的大小。</p>\n<p>当线程请求的栈深度大于虚拟机所允许的深度就会报StackOverflowError异常，比如方法的递归调用。<br>如果栈动态申请内存时没有足够内存可供申请就会发生OOM异常，比如像一个list中添加巨多数据。</p>\n<h4 id=\"Native-Method-Stack-本地方法栈\"><a href=\"#Native-Method-Stack-本地方法栈\" class=\"headerlink\" title=\"Native Method Stack(本地方法栈)\"></a>Native Method Stack(本地方法栈)</h4><p>本地方法栈与JVM栈类似，只不过调用的不是.class中的方法而是本地方法，Java中的本地方法描述的是一些更底层的操作，可以是其他语言写的。有的虚拟机（比如HotSpot）直接将JVM栈和本地方法栈合二为一。</p>\n<h4 id=\"Heap-堆\"><a href=\"#Heap-堆\" class=\"headerlink\" title=\"Heap(堆)\"></a>Heap(堆)</h4><p>Java堆是虚拟机所管理内存中最大的一块区域，在虚拟机启动时创建，几乎所有的内存实例都在此分配内存，是所有线程共享的。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap).</p>\n<p>大多数垃圾收集器都采用分代收集算法，因此Java堆可分为新生代和老年代，细致一些分的话可以分为Eden空间、From Survivor空间、To Survivor空间等。还有可能划分出线程私有的的分配缓冲区(Thread Local Allocation Buffer, TLAB)。</p>\n<p>堆的实现既可以是固定大小也可以是可拓展的(通过-Xmx和-Xms控制)。如果堆没有内存完成空间分配，并且无法拓展的时候就会报出OOM异常。</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>a方法区用于存储类的信息、常量、静态变量、即时编译器编译后的代码数据。虽然在Java虚拟机规范中把方法区描述为堆的一个逻辑分区，但是它却有一个别名Non-Heap与堆区分开来。</p>\n<h4 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h4><h3 id=\"Excution-Engine-执行引擎\"><a href=\"#Excution-Engine-执行引擎\" class=\"headerlink\" title=\"Excution Engine(执行引擎)\"></a>Excution Engine(执行引擎)</h3><h3 id=\"Native-Method-Interface-本地方法接口\"><a href=\"#Native-Method-Interface-本地方法接口\" class=\"headerlink\" title=\"Native Method Interface(本地方法接口)\"></a>Native Method Interface(本地方法接口)</h3>"},{"_content":"### 一般纳税人\n\n一般纳税人指的是年应征增值税销售额超过财政部规定的小规模纳税人标准的企业和企业性单位。一般纳税人的特点是增值税进项税额可以抵扣销项税额。\n\n### 小规模纳税人\n\n### 年应税销售额\n","source":"_drafts/学习票据.md","raw":"### 一般纳税人\n\n一般纳税人指的是年应征增值税销售额超过财政部规定的小规模纳税人标准的企业和企业性单位。一般纳税人的特点是增值税进项税额可以抵扣销项税额。\n\n### 小规模纳税人\n\n### 年应税销售额\n","slug":"学习票据","published":0,"date":"2019-05-20T01:19:07.714Z","updated":"2019-05-20T01:19:07.714Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9uq000j7tcykulqp7c0","content":"<h3 id=\"一般纳税人\"><a href=\"#一般纳税人\" class=\"headerlink\" title=\"一般纳税人\"></a>一般纳税人</h3><p>一般纳税人指的是年应征增值税销售额超过财政部规定的小规模纳税人标准的企业和企业性单位。一般纳税人的特点是增值税进项税额可以抵扣销项税额。</p>\n<h3 id=\"小规模纳税人\"><a href=\"#小规模纳税人\" class=\"headerlink\" title=\"小规模纳税人\"></a>小规模纳税人</h3><h3 id=\"年应税销售额\"><a href=\"#年应税销售额\" class=\"headerlink\" title=\"年应税销售额\"></a>年应税销售额</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一般纳税人\"><a href=\"#一般纳税人\" class=\"headerlink\" title=\"一般纳税人\"></a>一般纳税人</h3><p>一般纳税人指的是年应征增值税销售额超过财政部规定的小规模纳税人标准的企业和企业性单位。一般纳税人的特点是增值税进项税额可以抵扣销项税额。</p>\n<h3 id=\"小规模纳税人\"><a href=\"#小规模纳税人\" class=\"headerlink\" title=\"小规模纳税人\"></a>小规模纳税人</h3><h3 id=\"年应税销售额\"><a href=\"#年应税销售额\" class=\"headerlink\" title=\"年应税销售额\"></a>年应税销售额</h3>"},{"title":"对tomcat的一些理解.md","_content":"\n### 架构分析\n\n### 源码分析\n\n以tomcat８源码在windows环境下为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。\n\n```bat\nset \"CATALINA_HOME=%CURRENT_DIR%\"\nset \"EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat\"\ncall \"%EXECUTABLE%\" start %CMD_LINE_ARGS% \n\n```\n\n然后是执行catalina.bat文件，首先校验CATALINA_HOME是否存在，并设置CATALINA_BASE的值\n\n#### CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。\n\nCATALINA_HOME在startup.bat进行设置，CATALINA_BASE在catalina.bat中进行设置。\nCATALINA_HOME可以看作是指向tomcat的安装目录，CATALINA_BASE可以看作是指向tomcat的工作目录。当一台服务器下运行多个tomcat实例时，而我们又不想安装多个tomcat时，就可以创建多个tomcat工作目录，工作目录包含conf、logs、temp、webapps、work和shared目录，每一个tomcat实例的CATALINA_HOME指向安装目录，CATALINA_BASE指向当前实例的工作目录。\n\n### 问题\n\n#### 为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？","source":"_drafts/对tomcat的一些理解.md","raw":"---\ntitle: 对tomcat的一些理解.md\ntags:\n---\n\n### 架构分析\n\n### 源码分析\n\n以tomcat８源码在windows环境下为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。\n\n```bat\nset \"CATALINA_HOME=%CURRENT_DIR%\"\nset \"EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat\"\ncall \"%EXECUTABLE%\" start %CMD_LINE_ARGS% \n\n```\n\n然后是执行catalina.bat文件，首先校验CATALINA_HOME是否存在，并设置CATALINA_BASE的值\n\n#### CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。\n\nCATALINA_HOME在startup.bat进行设置，CATALINA_BASE在catalina.bat中进行设置。\nCATALINA_HOME可以看作是指向tomcat的安装目录，CATALINA_BASE可以看作是指向tomcat的工作目录。当一台服务器下运行多个tomcat实例时，而我们又不想安装多个tomcat时，就可以创建多个tomcat工作目录，工作目录包含conf、logs、temp、webapps、work和shared目录，每一个tomcat实例的CATALINA_HOME指向安装目录，CATALINA_BASE指向当前实例的工作目录。\n\n### 问题\n\n#### 为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？","slug":"对tomcat的一些理解","published":0,"date":"2019-06-30T10:27:50.042Z","updated":"2019-06-30T10:27:50.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ur000k7tcyaew6omob","content":"<h3 id=\"架构分析\"><a href=\"#架构分析\" class=\"headerlink\" title=\"架构分析\"></a>架构分析</h3><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>以tomcat８源码在windows环境下为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> \"CATALINA_HOME=<span class=\"variable\">%CURRENT_DIR%</span>\"</span><br><span class=\"line\"><span class=\"built_in\">set</span> \"EXECUTABLE=<span class=\"variable\">%CATALINA_HOME%</span>\\bin\\catalina.bat\"</span><br><span class=\"line\"><span class=\"keyword\">call</span> \"<span class=\"variable\">%EXECUTABLE%</span>\" <span class=\"built_in\">start</span> <span class=\"variable\">%CMD_LINE_ARGS%</span></span><br></pre></td></tr></table></figure>\n<p>然后是执行catalina.bat文件，首先校验CATALINA_HOME是否存在，并设置CATALINA_BASE的值</p>\n<h4 id=\"CATALINA-HOME与CATALINA-BASE表示什么，他们有什么区别。\"><a href=\"#CATALINA-HOME与CATALINA-BASE表示什么，他们有什么区别。\" class=\"headerlink\" title=\"CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。\"></a>CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。</h4><p>CATALINA_HOME在startup.bat进行设置，CATALINA_BASE在catalina.bat中进行设置。<br>CATALINA_HOME可以看作是指向tomcat的安装目录，CATALINA_BASE可以看作是指向tomcat的工作目录。当一台服务器下运行多个tomcat实例时，而我们又不想安装多个tomcat时，就可以创建多个tomcat工作目录，工作目录包含conf、logs、temp、webapps、work和shared目录，每一个tomcat实例的CATALINA_HOME指向安装目录，CATALINA_BASE指向当前实例的工作目录。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\"><a href=\"#为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\" class=\"headerlink\" title=\"为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\"></a>为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"架构分析\"><a href=\"#架构分析\" class=\"headerlink\" title=\"架构分析\"></a>架构分析</h3><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>以tomcat８源码在windows环境下为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> \"CATALINA_HOME=<span class=\"variable\">%CURRENT_DIR%</span>\"</span><br><span class=\"line\"><span class=\"built_in\">set</span> \"EXECUTABLE=<span class=\"variable\">%CATALINA_HOME%</span>\\bin\\catalina.bat\"</span><br><span class=\"line\"><span class=\"keyword\">call</span> \"<span class=\"variable\">%EXECUTABLE%</span>\" <span class=\"built_in\">start</span> <span class=\"variable\">%CMD_LINE_ARGS%</span></span><br></pre></td></tr></table></figure>\n<p>然后是执行catalina.bat文件，首先校验CATALINA_HOME是否存在，并设置CATALINA_BASE的值</p>\n<h4 id=\"CATALINA-HOME与CATALINA-BASE表示什么，他们有什么区别。\"><a href=\"#CATALINA-HOME与CATALINA-BASE表示什么，他们有什么区别。\" class=\"headerlink\" title=\"CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。\"></a>CATALINA_HOME与CATALINA_BASE表示什么，他们有什么区别。</h4><p>CATALINA_HOME在startup.bat进行设置，CATALINA_BASE在catalina.bat中进行设置。<br>CATALINA_HOME可以看作是指向tomcat的安装目录，CATALINA_BASE可以看作是指向tomcat的工作目录。当一台服务器下运行多个tomcat实例时，而我们又不想安装多个tomcat时，就可以创建多个tomcat工作目录，工作目录包含conf、logs、temp、webapps、work和shared目录，每一个tomcat实例的CATALINA_HOME指向安装目录，CATALINA_BASE指向当前实例的工作目录。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\"><a href=\"#为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\" class=\"headerlink\" title=\"为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？\"></a>为什么tomcat启动脚本要分startup和catalina，直接写在一个文件中启动不行吗？</h4>"},{"title":"杂七杂八","author":23,"date":"2018-07-08T12:07:00.000Z","tag":null,"_content":"\n### 编码\n\nASCII是美国信息交换标准代码，是单字节编码系统。\n\n*标准ASCII码*使用七位二进制数（最高位为0）来表示所有英文字母，数字0-9，标点符号，以及一些特殊控制字符,一共127个\n\n*拓展ASCII码*使用后128位来表示一些图形符号，希腊字母等\n\n### 字节流与字符流\n\n### jar包与war包\n\njar包中包含的是class文件和一些配置文件\n\nwar包可以看作是web项目的一个模块，其中还包含了WEB-INF文件夹，可以直接在容器中运行\n\n-----------------------------\ncontext可以看做是上下文、环境，是由内存开辟的一块隔离空间。这个空间中存在一些共享的信息，通过context的一个全局对象进行保存，那么就可以通过这个全局对象访问这块空间的一些全局信息。\n\nload-on-startup的值为自然数时，表示servlet在容器启动的时候就加载了，值越小加载的优先级越高。当load-on-startup的值为负数的时候，会对servlet产生什么影响呢？servlet类就不会随着容器启动加载，当访问到该servlet时才会加载，这样第一个访问该servlet时就会产生一定的延迟。一个应用中会存在多个servlet，那么为什么不直接在容器启动时就直接固定写所有servlet都加载呢，还要该属性呢？","source":"_drafts/杂七杂八.md","raw":"---\ntitle: 杂七杂八\nauthor: 0x17\ndate: 2018-07-08 20:07:00\ntag:\n---\n\n### 编码\n\nASCII是美国信息交换标准代码，是单字节编码系统。\n\n*标准ASCII码*使用七位二进制数（最高位为0）来表示所有英文字母，数字0-9，标点符号，以及一些特殊控制字符,一共127个\n\n*拓展ASCII码*使用后128位来表示一些图形符号，希腊字母等\n\n### 字节流与字符流\n\n### jar包与war包\n\njar包中包含的是class文件和一些配置文件\n\nwar包可以看作是web项目的一个模块，其中还包含了WEB-INF文件夹，可以直接在容器中运行\n\n-----------------------------\ncontext可以看做是上下文、环境，是由内存开辟的一块隔离空间。这个空间中存在一些共享的信息，通过context的一个全局对象进行保存，那么就可以通过这个全局对象访问这块空间的一些全局信息。\n\nload-on-startup的值为自然数时，表示servlet在容器启动的时候就加载了，值越小加载的优先级越高。当load-on-startup的值为负数的时候，会对servlet产生什么影响呢？servlet类就不会随着容器启动加载，当访问到该servlet时才会加载，这样第一个访问该servlet时就会产生一定的延迟。一个应用中会存在多个servlet，那么为什么不直接在容器启动时就直接固定写所有servlet都加载呢，还要该属性呢？","slug":"杂七杂八","published":0,"updated":"2019-06-01T15:49:09.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ut000l7tcyif31byf1","content":"<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>ASCII是美国信息交换标准代码，是单字节编码系统。</p>\n<p><em>标准ASCII码</em>使用七位二进制数（最高位为0）来表示所有英文字母，数字0-9，标点符号，以及一些特殊控制字符,一共127个</p>\n<p><em>拓展ASCII码</em>使用后128位来表示一些图形符号，希腊字母等</p>\n<h3 id=\"字节流与字符流\"><a href=\"#字节流与字符流\" class=\"headerlink\" title=\"字节流与字符流\"></a>字节流与字符流</h3><h3 id=\"jar包与war包\"><a href=\"#jar包与war包\" class=\"headerlink\" title=\"jar包与war包\"></a>jar包与war包</h3><p>jar包中包含的是class文件和一些配置文件</p>\n<p>war包可以看作是web项目的一个模块，其中还包含了WEB-INF文件夹，可以直接在容器中运行</p>\n<hr>\n<p>context可以看做是上下文、环境，是由内存开辟的一块隔离空间。这个空间中存在一些共享的信息，通过context的一个全局对象进行保存，那么就可以通过这个全局对象访问这块空间的一些全局信息。</p>\n<p>load-on-startup的值为自然数时，表示servlet在容器启动的时候就加载了，值越小加载的优先级越高。当load-on-startup的值为负数的时候，会对servlet产生什么影响呢？servlet类就不会随着容器启动加载，当访问到该servlet时才会加载，这样第一个访问该servlet时就会产生一定的延迟。一个应用中会存在多个servlet，那么为什么不直接在容器启动时就直接固定写所有servlet都加载呢，还要该属性呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>ASCII是美国信息交换标准代码，是单字节编码系统。</p>\n<p><em>标准ASCII码</em>使用七位二进制数（最高位为0）来表示所有英文字母，数字0-9，标点符号，以及一些特殊控制字符,一共127个</p>\n<p><em>拓展ASCII码</em>使用后128位来表示一些图形符号，希腊字母等</p>\n<h3 id=\"字节流与字符流\"><a href=\"#字节流与字符流\" class=\"headerlink\" title=\"字节流与字符流\"></a>字节流与字符流</h3><h3 id=\"jar包与war包\"><a href=\"#jar包与war包\" class=\"headerlink\" title=\"jar包与war包\"></a>jar包与war包</h3><p>jar包中包含的是class文件和一些配置文件</p>\n<p>war包可以看作是web项目的一个模块，其中还包含了WEB-INF文件夹，可以直接在容器中运行</p>\n<hr>\n<p>context可以看做是上下文、环境，是由内存开辟的一块隔离空间。这个空间中存在一些共享的信息，通过context的一个全局对象进行保存，那么就可以通过这个全局对象访问这块空间的一些全局信息。</p>\n<p>load-on-startup的值为自然数时，表示servlet在容器启动的时候就加载了，值越小加载的优先级越高。当load-on-startup的值为负数的时候，会对servlet产生什么影响呢？servlet类就不会随着容器启动加载，当访问到该servlet时才会加载，这样第一个访问该servlet时就会产生一定的延迟。一个应用中会存在多个servlet，那么为什么不直接在容器启动时就直接固定写所有servlet都加载呢，还要该属性呢？</p>\n"},{"title":"数据结构","author":"0x17","date":"2018-05-04T09:04:53.000Z","_content":"\n## 链表\n\n优点：真正的动态，不需要处理固定容量的问题\n\n缺点：丢失了随机访问的能力 ","source":"_drafts/数据结构.md","raw":"---\ntitle: 数据结构\nauthor: \"0x17\"\ndate: 2018-05-04 17:04:53\ntags:\n---\n\n## 链表\n\n优点：真正的动态，不需要处理固定容量的问题\n\n缺点：丢失了随机访问的能力 ","slug":"数据结构","published":0,"updated":"2019-05-20T12:35:32.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9uu000m7tcy5xdxogph","content":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>优点：真正的动态，不需要处理固定容量的问题</p>\n<p>缺点：丢失了随机访问的能力 </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>优点：真正的动态，不需要处理固定容量的问题</p>\n<p>缺点：丢失了随机访问的能力 </p>\n"},{"author":"0x17","date":"2018-10-23T16:00:00.000Z","tag":null,"_content":"\n## 上海前两周体验\n\n故地重游的感受\n\n工作体验\n工资少、事情多、工作无趣、对技能毫无提升\n生活体验\n\n快递\n\n","source":"_drafts/第一次工作体验.md","raw":"---\nauthor: \"0x17\"\ndate: 2018/10/24\ntag:\n---\n\n## 上海前两周体验\n\n故地重游的感受\n\n工作体验\n工资少、事情多、工作无趣、对技能毫无提升\n生活体验\n\n快递\n\n","slug":"第一次工作体验","published":0,"updated":"2019-05-20T01:19:07.717Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9uw000n7tcyr1ac3jyh","content":"<h2 id=\"上海前两周体验\"><a href=\"#上海前两周体验\" class=\"headerlink\" title=\"上海前两周体验\"></a>上海前两周体验</h2><p>故地重游的感受</p>\n<p>工作体验<br>工资少、事情多、工作无趣、对技能毫无提升<br>生活体验</p>\n<p>快递</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"上海前两周体验\"><a href=\"#上海前两周体验\" class=\"headerlink\" title=\"上海前两周体验\"></a>上海前两周体验</h2><p>故地重游的感受</p>\n<p>工作体验<br>工资少、事情多、工作无趣、对技能毫无提升<br>生活体验</p>\n<p>快递</p>\n"},{"title":"深圳之行","author":23,"date":"2018-07-08T12:07:00.000Z","tag":null,"_content":"\n### 深圳我要来了\n\n这个暑假选择去深圳，去深圳的目的是为了去实训，实训的概念就是免费帮别人打工，然后别人教你实际工作中项目开发的经验。一方面学校要计算这个实践学分，另一方面也可以体验大城市的这种工作生活氛围。其实这个暑假有三种选择，第一个是考研，然而我早早决定了放弃考研；第二个是参加实习，通过第一次面试的失败，我的第二次面试成功了，这份实习工作也还算可以，但是由于我想和同学一起去深圳看看，提前适应工作氛围，为秋招做准备，所以最终还是选择了实训。\n\n### 出发前\n\n7.4号从家来到学校，在学校住一晚上，准备7.5号出发去深圳。以前从西站到学校都是坐708转520公交车，这次是坐地铁转214路公交，感觉这种方式确实更省时、更方便。来到学校在204寝室玩了半个下午，晚上买了些面包和饮料到火车上吃。\n\n### 坐车中\n\n7.5号上午早早起床，坐上学校的大巴去西站坐高铁去深圳，同行的同学中本班同学最多，还有两位女生（被称为高冷F4中的两位）。两位大巴司机（新手和老手）互相吹牛，感觉挺有趣的。走的是环城高速，很快就到了西站。在西站等了一会便坐上了高铁，这是我第一次坐高铁，高铁给我的第一感觉就是干净，这点比较重要，给人的第一感很好，然后感觉高铁又快又稳，并且高铁的噪音比较小。我坐在F坐，也就是靠窗的座位，旁边坐了一位女生，应该也是一位大学生，她在火车上好像是在出一张日文测试的卷子，这是她给我的印象。我大部分时间都在看窗外或者睡觉，沿途的景色确实不错，我经过了一个又一个的乡村，虽然很普通但是又各具特色。比如很符合大杂居，小聚居的特点。有的一两间房坐落在一大片树林中（我喜欢这种环境，就和那个爱心庄园一样，虽然这种环境居住的话可能会有很多不方便的地方），有的村庄房屋错落拥挤，朝向也不一致，各具特点（居住在这种环境中，邻里之间互相帮忙，生活比较方便，但是感觉很乱很挤）。这天是阴天，一路来到深圳，还是挺疲惫的。\n\n### 到达深圳\n\n达到深圳后坐上大巴来到安排住的地方，我被分到四人间。其他同学有的分到6人间，有的分到8人间，相比之下我们算是比较幸运的，因为深圳的这种出租房都是极小的，也就十来平米，住这么多人，洗漱什么的都不大方便，如果这么大的寝室住一两个人还是不错的。当天晚上去了沃尔玛买了些生活用品，沿途的房价也是让我看到了贫富的差距有多大。\n\n### 吐槽\n\n1.负责人效率极低，组织同学做什么事都会拖延，或者找不出好的方法，浪费了很多时间。\n\n2.深圳消费很高，平均一天吃饭要花30多块钱，想想在学校30块钱一天可以吃的有多爽。\n\n3.住的地方本来想吐槽的，但是一对比其他同学，感觉自己住的还不错。\n\n4.深圳这边饭菜口味不适和，太淡了。\n\n5.深圳地铁很挤，想想以后就有可能要这样挤地铁该有多心累啊。\n\n### 第五天\n今天牙疼好了许多，中午和下午也各吃了些食物。今天听到了一个笑话**win10也太不稳定了吧，尤其是盗版**哈哈哈","source":"_drafts/深圳之行.md","raw":"---\ntitle: 深圳之行\nauthor: 0x17\ndate: 2018-07-08 20:07:00\ntag:\n---\n\n### 深圳我要来了\n\n这个暑假选择去深圳，去深圳的目的是为了去实训，实训的概念就是免费帮别人打工，然后别人教你实际工作中项目开发的经验。一方面学校要计算这个实践学分，另一方面也可以体验大城市的这种工作生活氛围。其实这个暑假有三种选择，第一个是考研，然而我早早决定了放弃考研；第二个是参加实习，通过第一次面试的失败，我的第二次面试成功了，这份实习工作也还算可以，但是由于我想和同学一起去深圳看看，提前适应工作氛围，为秋招做准备，所以最终还是选择了实训。\n\n### 出发前\n\n7.4号从家来到学校，在学校住一晚上，准备7.5号出发去深圳。以前从西站到学校都是坐708转520公交车，这次是坐地铁转214路公交，感觉这种方式确实更省时、更方便。来到学校在204寝室玩了半个下午，晚上买了些面包和饮料到火车上吃。\n\n### 坐车中\n\n7.5号上午早早起床，坐上学校的大巴去西站坐高铁去深圳，同行的同学中本班同学最多，还有两位女生（被称为高冷F4中的两位）。两位大巴司机（新手和老手）互相吹牛，感觉挺有趣的。走的是环城高速，很快就到了西站。在西站等了一会便坐上了高铁，这是我第一次坐高铁，高铁给我的第一感觉就是干净，这点比较重要，给人的第一感很好，然后感觉高铁又快又稳，并且高铁的噪音比较小。我坐在F坐，也就是靠窗的座位，旁边坐了一位女生，应该也是一位大学生，她在火车上好像是在出一张日文测试的卷子，这是她给我的印象。我大部分时间都在看窗外或者睡觉，沿途的景色确实不错，我经过了一个又一个的乡村，虽然很普通但是又各具特色。比如很符合大杂居，小聚居的特点。有的一两间房坐落在一大片树林中（我喜欢这种环境，就和那个爱心庄园一样，虽然这种环境居住的话可能会有很多不方便的地方），有的村庄房屋错落拥挤，朝向也不一致，各具特点（居住在这种环境中，邻里之间互相帮忙，生活比较方便，但是感觉很乱很挤）。这天是阴天，一路来到深圳，还是挺疲惫的。\n\n### 到达深圳\n\n达到深圳后坐上大巴来到安排住的地方，我被分到四人间。其他同学有的分到6人间，有的分到8人间，相比之下我们算是比较幸运的，因为深圳的这种出租房都是极小的，也就十来平米，住这么多人，洗漱什么的都不大方便，如果这么大的寝室住一两个人还是不错的。当天晚上去了沃尔玛买了些生活用品，沿途的房价也是让我看到了贫富的差距有多大。\n\n### 吐槽\n\n1.负责人效率极低，组织同学做什么事都会拖延，或者找不出好的方法，浪费了很多时间。\n\n2.深圳消费很高，平均一天吃饭要花30多块钱，想想在学校30块钱一天可以吃的有多爽。\n\n3.住的地方本来想吐槽的，但是一对比其他同学，感觉自己住的还不错。\n\n4.深圳这边饭菜口味不适和，太淡了。\n\n5.深圳地铁很挤，想想以后就有可能要这样挤地铁该有多心累啊。\n\n### 第五天\n今天牙疼好了许多，中午和下午也各吃了些食物。今天听到了一个笑话**win10也太不稳定了吧，尤其是盗版**哈哈哈","slug":"深圳之行","published":0,"updated":"2018-10-05T02:39:15.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9ux000o7tcy55v652k5","content":"<h3 id=\"深圳我要来了\"><a href=\"#深圳我要来了\" class=\"headerlink\" title=\"深圳我要来了\"></a>深圳我要来了</h3><p>这个暑假选择去深圳，去深圳的目的是为了去实训，实训的概念就是免费帮别人打工，然后别人教你实际工作中项目开发的经验。一方面学校要计算这个实践学分，另一方面也可以体验大城市的这种工作生活氛围。其实这个暑假有三种选择，第一个是考研，然而我早早决定了放弃考研；第二个是参加实习，通过第一次面试的失败，我的第二次面试成功了，这份实习工作也还算可以，但是由于我想和同学一起去深圳看看，提前适应工作氛围，为秋招做准备，所以最终还是选择了实训。</p>\n<h3 id=\"出发前\"><a href=\"#出发前\" class=\"headerlink\" title=\"出发前\"></a>出发前</h3><p>7.4号从家来到学校，在学校住一晚上，准备7.5号出发去深圳。以前从西站到学校都是坐708转520公交车，这次是坐地铁转214路公交，感觉这种方式确实更省时、更方便。来到学校在204寝室玩了半个下午，晚上买了些面包和饮料到火车上吃。</p>\n<h3 id=\"坐车中\"><a href=\"#坐车中\" class=\"headerlink\" title=\"坐车中\"></a>坐车中</h3><p>7.5号上午早早起床，坐上学校的大巴去西站坐高铁去深圳，同行的同学中本班同学最多，还有两位女生（被称为高冷F4中的两位）。两位大巴司机（新手和老手）互相吹牛，感觉挺有趣的。走的是环城高速，很快就到了西站。在西站等了一会便坐上了高铁，这是我第一次坐高铁，高铁给我的第一感觉就是干净，这点比较重要，给人的第一感很好，然后感觉高铁又快又稳，并且高铁的噪音比较小。我坐在F坐，也就是靠窗的座位，旁边坐了一位女生，应该也是一位大学生，她在火车上好像是在出一张日文测试的卷子，这是她给我的印象。我大部分时间都在看窗外或者睡觉，沿途的景色确实不错，我经过了一个又一个的乡村，虽然很普通但是又各具特色。比如很符合大杂居，小聚居的特点。有的一两间房坐落在一大片树林中（我喜欢这种环境，就和那个爱心庄园一样，虽然这种环境居住的话可能会有很多不方便的地方），有的村庄房屋错落拥挤，朝向也不一致，各具特点（居住在这种环境中，邻里之间互相帮忙，生活比较方便，但是感觉很乱很挤）。这天是阴天，一路来到深圳，还是挺疲惫的。</p>\n<h3 id=\"到达深圳\"><a href=\"#到达深圳\" class=\"headerlink\" title=\"到达深圳\"></a>到达深圳</h3><p>达到深圳后坐上大巴来到安排住的地方，我被分到四人间。其他同学有的分到6人间，有的分到8人间，相比之下我们算是比较幸运的，因为深圳的这种出租房都是极小的，也就十来平米，住这么多人，洗漱什么的都不大方便，如果这么大的寝室住一两个人还是不错的。当天晚上去了沃尔玛买了些生活用品，沿途的房价也是让我看到了贫富的差距有多大。</p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><p>1.负责人效率极低，组织同学做什么事都会拖延，或者找不出好的方法，浪费了很多时间。</p>\n<p>2.深圳消费很高，平均一天吃饭要花30多块钱，想想在学校30块钱一天可以吃的有多爽。</p>\n<p>3.住的地方本来想吐槽的，但是一对比其他同学，感觉自己住的还不错。</p>\n<p>4.深圳这边饭菜口味不适和，太淡了。</p>\n<p>5.深圳地铁很挤，想想以后就有可能要这样挤地铁该有多心累啊。</p>\n<h3 id=\"第五天\"><a href=\"#第五天\" class=\"headerlink\" title=\"第五天\"></a>第五天</h3><p>今天牙疼好了许多，中午和下午也各吃了些食物。今天听到了一个笑话<strong>win10也太不稳定了吧，尤其是盗版</strong>哈哈哈</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"深圳我要来了\"><a href=\"#深圳我要来了\" class=\"headerlink\" title=\"深圳我要来了\"></a>深圳我要来了</h3><p>这个暑假选择去深圳，去深圳的目的是为了去实训，实训的概念就是免费帮别人打工，然后别人教你实际工作中项目开发的经验。一方面学校要计算这个实践学分，另一方面也可以体验大城市的这种工作生活氛围。其实这个暑假有三种选择，第一个是考研，然而我早早决定了放弃考研；第二个是参加实习，通过第一次面试的失败，我的第二次面试成功了，这份实习工作也还算可以，但是由于我想和同学一起去深圳看看，提前适应工作氛围，为秋招做准备，所以最终还是选择了实训。</p>\n<h3 id=\"出发前\"><a href=\"#出发前\" class=\"headerlink\" title=\"出发前\"></a>出发前</h3><p>7.4号从家来到学校，在学校住一晚上，准备7.5号出发去深圳。以前从西站到学校都是坐708转520公交车，这次是坐地铁转214路公交，感觉这种方式确实更省时、更方便。来到学校在204寝室玩了半个下午，晚上买了些面包和饮料到火车上吃。</p>\n<h3 id=\"坐车中\"><a href=\"#坐车中\" class=\"headerlink\" title=\"坐车中\"></a>坐车中</h3><p>7.5号上午早早起床，坐上学校的大巴去西站坐高铁去深圳，同行的同学中本班同学最多，还有两位女生（被称为高冷F4中的两位）。两位大巴司机（新手和老手）互相吹牛，感觉挺有趣的。走的是环城高速，很快就到了西站。在西站等了一会便坐上了高铁，这是我第一次坐高铁，高铁给我的第一感觉就是干净，这点比较重要，给人的第一感很好，然后感觉高铁又快又稳，并且高铁的噪音比较小。我坐在F坐，也就是靠窗的座位，旁边坐了一位女生，应该也是一位大学生，她在火车上好像是在出一张日文测试的卷子，这是她给我的印象。我大部分时间都在看窗外或者睡觉，沿途的景色确实不错，我经过了一个又一个的乡村，虽然很普通但是又各具特色。比如很符合大杂居，小聚居的特点。有的一两间房坐落在一大片树林中（我喜欢这种环境，就和那个爱心庄园一样，虽然这种环境居住的话可能会有很多不方便的地方），有的村庄房屋错落拥挤，朝向也不一致，各具特点（居住在这种环境中，邻里之间互相帮忙，生活比较方便，但是感觉很乱很挤）。这天是阴天，一路来到深圳，还是挺疲惫的。</p>\n<h3 id=\"到达深圳\"><a href=\"#到达深圳\" class=\"headerlink\" title=\"到达深圳\"></a>到达深圳</h3><p>达到深圳后坐上大巴来到安排住的地方，我被分到四人间。其他同学有的分到6人间，有的分到8人间，相比之下我们算是比较幸运的，因为深圳的这种出租房都是极小的，也就十来平米，住这么多人，洗漱什么的都不大方便，如果这么大的寝室住一两个人还是不错的。当天晚上去了沃尔玛买了些生活用品，沿途的房价也是让我看到了贫富的差距有多大。</p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><p>1.负责人效率极低，组织同学做什么事都会拖延，或者找不出好的方法，浪费了很多时间。</p>\n<p>2.深圳消费很高，平均一天吃饭要花30多块钱，想想在学校30块钱一天可以吃的有多爽。</p>\n<p>3.住的地方本来想吐槽的，但是一对比其他同学，感觉自己住的还不错。</p>\n<p>4.深圳这边饭菜口味不适和，太淡了。</p>\n<p>5.深圳地铁很挤，想想以后就有可能要这样挤地铁该有多心累啊。</p>\n<h3 id=\"第五天\"><a href=\"#第五天\" class=\"headerlink\" title=\"第五天\"></a>第五天</h3><p>今天牙疼好了许多，中午和下午也各吃了些食物。今天听到了一个笑话<strong>win10也太不稳定了吧，尤其是盗版</strong>哈哈哈</p>\n"},{"title":"每天一点es6","author":"peng","date":"2019-03-27T16:00:00.000Z","_content":"\n### 块级作用域\n\n#### 为什么需要块级作用域\n\nes5中只有块级作用域和函数作用域，这会产生某些不合理的场景。\n\n```\n场景一\nvar a = 'test'\n\nfunction f(){\n    console.log(a);\n    if(true){\n        var a = 'test1';\n    }\n}\nf() // undefined\n本来调用f()希望得到的结果是test,但是由于函数f内的a变量提升到该函数的顶部，导致输出的a为undefined。\n\n场景二\nfunction f(){\n    for(var i = 0; i < 10; i++){}\n}\ni // 10\n循环中计数的循环变量泄露为上一层作用域的变量。\n```\n\n#### es6中的块级作用域\n\nes6中的let的出现实际为JavaScript增加了块级作用域\n\n```\nfunction f1(){\n    let n = 5;\n    if(true){\n        let n = 10;\n    }\n    console.log(n) // 5\n}\n这表明外层块级作用域不受内层块级作用域的影响。\n\n(function(){\n...\n}())\n\n{\n...\n}\n块级作用域的出现实际上使得自执行函数不再必要了。\n```\n\n### let命令\n\nlet命令：let命令用来声明的变量，其声明的变量只在其所在的代码块中有效。\n\n#### 用法\n\n```\nes5中的作用域只有函数作用域和全局作用域，在函数体中使用var定义的变量，会被提到函数开始处进行定义，作用域为整个函数。\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n    a[i] = function () {\n        console.log(i);\n    };\n  }\na[6](); // 10\ni; // 10\n因为for循环并不是一个函数体，所以for循环中定义的变量的作用域是其所在的函数体，所以这里的i的输出是10，而a[6]()的输出为10是因为i一直保存的是值引用，所以显示10.\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n     a[i] = function () {\n        console.log(i);\n     };\n  }\na[6](); // 6\n因为let声明的变量只在块级作用域中生效，每一个循环都会产生一个新的作用域。\n\nfor(let i = 0; i < 3; i++){\n    let i = 'abc';\n    console.log(i);\n}\n// abc\n// abc\n// abc\n实际上在这里,整个for循环有两个作用域，设置循环变量的部分为父作用域，循环体那部分为子作用域。因为这个循环执行了三次，父作用域没有受到子作用域的影响。\n```\n\n#### 不存在变量提升\n\n变量提升：指的是变量可以在变量声明前使用该变量，但是会输出undefined。\n\n为了纠正这种情况，使用let声明的变量不可以在变量声明前使用，否则会报错。\n\n```\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n#### 暂时性死区\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的，该现象称为“暂时性死区”(temporal dead zone)\n\n```\nx = 'a';\nlet x = 'b';\n会报错：该变量未定义\n\ntypeof x; //报错\nlet x = 'a';\ntypeof undeclear_var // undefined\n会使得typeof操作符的使用不再安全\n\nvar x = x //undefined\nlet x = x //报错\n```\n\n#### 不允许重复声明\n\n在同一块级作用域中不允许重复声明变量。\n\n```\nfunction f(args){\n    let args;\n} //报错\n\nfunction f1(args){\n    {\n    let args;\n    }\n} //不报错\n```\n\n### const命令\n\nconst声明的变量指向的地址所保存的数据不可变，一旦声明后就不可以修改，一旦声明就要初始化。\n\nconst与let一样，只在声明的块级作用域中有效，并且声明的常量也不可以提升，同样存在暂时性死区。\n\n```\nconst a = {};\na.property = 1; //不报错\na = {}; //报错 \n只要保证a变量指向地址保存的数据不改变就不会报错\n\nfunction f(obj){\n    Object.freeze(obj);\n    Object.keys(obj).forEach((key) => {\n        if(typeof obj[key] === 'object'){\n            f(obj[key]);\n        }\n    })\n}\n```\n\n### 变量的解构赋值\n\n实际上可以看作一种模式匹配。\n\n#### 数组的解构赋值\n\n```\nlet [foo] = [];\nlet [bar, foo] = [1];\nfoo // undefined\n解构不成功就会返回undefined。\n\nlet [x, y] = [1, 2, 3];\n不完全解构。\n\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n会报错，因为等号右边是不可便利的结构。\n\nlet [x, y = 'b'] = ['a', undefined];\n// x='a', y='b' 只有对应的位置严格等于(===)undefined，默认值才会生效。\n```\n\n#### 对象的解构赋值\n\n```\nlet {foo, bar} = {foo: \"aaa\", bar: \"bbb\"};\nlet {foo: foo, bar: bar} = {foo: \"aaa\", bar: \"bbb\"};\nlet {foo: baz} = {foo: \"aaa\", bar: \"bbb\"} // baz->\"aaa\" foo->报错\nlet {foo} = {bar: \"bbb'} //解构失败 foo->undefined\n解构赋值的键其实是匹配的模式，而值才是指向真正的值。\n\nvar {x = 3} = {x: undefined};\nx // 3\nvar {x = 3} = {x: null};\nx // null\n默认值的生效条件是对应匹配的值为undefined。\n\nlet arr = [1, 2, 3];\nlet {0: first, [arr.length - 1]: last} = arr;\nfirst // 1\nlast // 3\n数组可以进行对象属性的结构，**数组本质是特殊的对象**\n```\n\n#### 字符串的解构赋值\n\n```\nlet {length: len} = 'hello';\nlen //5\nString类中有个length属性与之匹配。\n```\n#### 数值和布尔值的解构赋值\n\n```\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n如果等号右边是数值或者布尔值，则会转为包装对象\n\nlet { prop: x } = undefined; // TypeError\nlet { prop: y } = null; // TypeError\nundefined和null无法转为对象。\n```\n\n#### 函数参数的解构赋值\n\n```\nfunction f({x = 0, y = 0} = {}) {\n    return [x, y];\n}\nf({x: 3, y: 3}); // [3, 8]\nf({x: 3}); // [3, 0]\nf({}); // [0, 0]\nf(); // [0, 0]\n\nfunction f({x, y} = {x: 0, y: 0}) {\n    return [x, y];\n}\nf({x: 3, y: 3}); // [3, 8]\nf({x: 3}); // [3, undefined]\nf({}); // [undefined, undefined]\nf(); // [0, 0]\n注意上面两种情况的比较。\n\n[1, undefined, 3].map((x = 'yes') => x);\n// [1, 'yes', 3]\n```\n### 函数的扩展\n\n\n","source":"_drafts/每天一点ES6.md","raw":"---\ntitle: 每天一点es6\nauthor: 'peng'\ndate: 2019-03-28\n---\n\n### 块级作用域\n\n#### 为什么需要块级作用域\n\nes5中只有块级作用域和函数作用域，这会产生某些不合理的场景。\n\n```\n场景一\nvar a = 'test'\n\nfunction f(){\n    console.log(a);\n    if(true){\n        var a = 'test1';\n    }\n}\nf() // undefined\n本来调用f()希望得到的结果是test,但是由于函数f内的a变量提升到该函数的顶部，导致输出的a为undefined。\n\n场景二\nfunction f(){\n    for(var i = 0; i < 10; i++){}\n}\ni // 10\n循环中计数的循环变量泄露为上一层作用域的变量。\n```\n\n#### es6中的块级作用域\n\nes6中的let的出现实际为JavaScript增加了块级作用域\n\n```\nfunction f1(){\n    let n = 5;\n    if(true){\n        let n = 10;\n    }\n    console.log(n) // 5\n}\n这表明外层块级作用域不受内层块级作用域的影响。\n\n(function(){\n...\n}())\n\n{\n...\n}\n块级作用域的出现实际上使得自执行函数不再必要了。\n```\n\n### let命令\n\nlet命令：let命令用来声明的变量，其声明的变量只在其所在的代码块中有效。\n\n#### 用法\n\n```\nes5中的作用域只有函数作用域和全局作用域，在函数体中使用var定义的变量，会被提到函数开始处进行定义，作用域为整个函数。\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n    a[i] = function () {\n        console.log(i);\n    };\n  }\na[6](); // 10\ni; // 10\n因为for循环并不是一个函数体，所以for循环中定义的变量的作用域是其所在的函数体，所以这里的i的输出是10，而a[6]()的输出为10是因为i一直保存的是值引用，所以显示10.\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n     a[i] = function () {\n        console.log(i);\n     };\n  }\na[6](); // 6\n因为let声明的变量只在块级作用域中生效，每一个循环都会产生一个新的作用域。\n\nfor(let i = 0; i < 3; i++){\n    let i = 'abc';\n    console.log(i);\n}\n// abc\n// abc\n// abc\n实际上在这里,整个for循环有两个作用域，设置循环变量的部分为父作用域，循环体那部分为子作用域。因为这个循环执行了三次，父作用域没有受到子作用域的影响。\n```\n\n#### 不存在变量提升\n\n变量提升：指的是变量可以在变量声明前使用该变量，但是会输出undefined。\n\n为了纠正这种情况，使用let声明的变量不可以在变量声明前使用，否则会报错。\n\n```\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n#### 暂时性死区\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的，该现象称为“暂时性死区”(temporal dead zone)\n\n```\nx = 'a';\nlet x = 'b';\n会报错：该变量未定义\n\ntypeof x; //报错\nlet x = 'a';\ntypeof undeclear_var // undefined\n会使得typeof操作符的使用不再安全\n\nvar x = x //undefined\nlet x = x //报错\n```\n\n#### 不允许重复声明\n\n在同一块级作用域中不允许重复声明变量。\n\n```\nfunction f(args){\n    let args;\n} //报错\n\nfunction f1(args){\n    {\n    let args;\n    }\n} //不报错\n```\n\n### const命令\n\nconst声明的变量指向的地址所保存的数据不可变，一旦声明后就不可以修改，一旦声明就要初始化。\n\nconst与let一样，只在声明的块级作用域中有效，并且声明的常量也不可以提升，同样存在暂时性死区。\n\n```\nconst a = {};\na.property = 1; //不报错\na = {}; //报错 \n只要保证a变量指向地址保存的数据不改变就不会报错\n\nfunction f(obj){\n    Object.freeze(obj);\n    Object.keys(obj).forEach((key) => {\n        if(typeof obj[key] === 'object'){\n            f(obj[key]);\n        }\n    })\n}\n```\n\n### 变量的解构赋值\n\n实际上可以看作一种模式匹配。\n\n#### 数组的解构赋值\n\n```\nlet [foo] = [];\nlet [bar, foo] = [1];\nfoo // undefined\n解构不成功就会返回undefined。\n\nlet [x, y] = [1, 2, 3];\n不完全解构。\n\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n会报错，因为等号右边是不可便利的结构。\n\nlet [x, y = 'b'] = ['a', undefined];\n// x='a', y='b' 只有对应的位置严格等于(===)undefined，默认值才会生效。\n```\n\n#### 对象的解构赋值\n\n```\nlet {foo, bar} = {foo: \"aaa\", bar: \"bbb\"};\nlet {foo: foo, bar: bar} = {foo: \"aaa\", bar: \"bbb\"};\nlet {foo: baz} = {foo: \"aaa\", bar: \"bbb\"} // baz->\"aaa\" foo->报错\nlet {foo} = {bar: \"bbb'} //解构失败 foo->undefined\n解构赋值的键其实是匹配的模式，而值才是指向真正的值。\n\nvar {x = 3} = {x: undefined};\nx // 3\nvar {x = 3} = {x: null};\nx // null\n默认值的生效条件是对应匹配的值为undefined。\n\nlet arr = [1, 2, 3];\nlet {0: first, [arr.length - 1]: last} = arr;\nfirst // 1\nlast // 3\n数组可以进行对象属性的结构，**数组本质是特殊的对象**\n```\n\n#### 字符串的解构赋值\n\n```\nlet {length: len} = 'hello';\nlen //5\nString类中有个length属性与之匹配。\n```\n#### 数值和布尔值的解构赋值\n\n```\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n如果等号右边是数值或者布尔值，则会转为包装对象\n\nlet { prop: x } = undefined; // TypeError\nlet { prop: y } = null; // TypeError\nundefined和null无法转为对象。\n```\n\n#### 函数参数的解构赋值\n\n```\nfunction f({x = 0, y = 0} = {}) {\n    return [x, y];\n}\nf({x: 3, y: 3}); // [3, 8]\nf({x: 3}); // [3, 0]\nf({}); // [0, 0]\nf(); // [0, 0]\n\nfunction f({x, y} = {x: 0, y: 0}) {\n    return [x, y];\n}\nf({x: 3, y: 3}); // [3, 8]\nf({x: 3}); // [3, undefined]\nf({}); // [undefined, undefined]\nf(); // [0, 0]\n注意上面两种情况的比较。\n\n[1, undefined, 3].map((x = 'yes') => x);\n// [1, 'yes', 3]\n```\n### 函数的扩展\n\n\n","slug":"每天一点ES6","published":0,"updated":"2019-05-22T09:27:03.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9uy000p7tcy2c6tqaph","content":"<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><h4 id=\"为什么需要块级作用域\"><a href=\"#为什么需要块级作用域\" class=\"headerlink\" title=\"为什么需要块级作用域\"></a>为什么需要块级作用域</h4><p>es5中只有块级作用域和函数作用域，这会产生某些不合理的场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">场景一</span><br><span class=\"line\">var a = &apos;test&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    if(true)&#123;</span><br><span class=\"line\">        var a = &apos;test1&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() // undefined</span><br><span class=\"line\">本来调用f()希望得到的结果是test,但是由于函数f内的a变量提升到该函数的顶部，导致输出的a为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">场景二</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    for(var i = 0; i &lt; 10; i++)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">i // 10</span><br><span class=\"line\">循环中计数的循环变量泄露为上一层作用域的变量。</span><br></pre></td></tr></table></figure>\n<h4 id=\"es6中的块级作用域\"><a href=\"#es6中的块级作用域\" class=\"headerlink\" title=\"es6中的块级作用域\"></a>es6中的块级作用域</h4><p>es6中的let的出现实际为JavaScript增加了块级作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;</span><br><span class=\"line\">    let n = 5;</span><br><span class=\"line\">    if(true)&#123;</span><br><span class=\"line\">        let n = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(n) // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">这表明外层块级作用域不受内层块级作用域的影响。</span><br><span class=\"line\"></span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">块级作用域的出现实际上使得自执行函数不再必要了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h3><p>let命令：let命令用来声明的变量，其声明的变量只在其所在的代码块中有效。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">es5中的作用域只有函数作用域和全局作用域，在函数体中使用var定义的变量，会被提到函数开始处进行定义，作用域为整个函数。</span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    a[i] = function () &#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">a[6](); // 10</span><br><span class=\"line\">i; // 10</span><br><span class=\"line\">因为for循环并不是一个函数体，所以for循环中定义的变量的作用域是其所在的函数体，所以这里的i的输出是10，而a[6]()的输出为10是因为i一直保存的是值引用，所以显示10.</span><br><span class=\"line\"></span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">     a[i] = function () &#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">a[6](); // 6</span><br><span class=\"line\">因为let声明的变量只在块级作用域中生效，每一个循环都会产生一个新的作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">for(let i = 0; i &lt; 3; i++)&#123;</span><br><span class=\"line\">    let i = &apos;abc&apos;;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// abc</span><br><span class=\"line\">// abc</span><br><span class=\"line\">// abc</span><br><span class=\"line\">实际上在这里,整个for循环有两个作用域，设置循环变量的部分为父作用域，循环体那部分为子作用域。因为这个循环执行了三次，父作用域没有受到子作用域的影响。</span><br></pre></td></tr></table></figure>\n<h4 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h4><p>变量提升：指的是变量可以在变量声明前使用该变量，但是会输出undefined。</p>\n<p>为了纠正这种情况，使用let声明的变量不可以在变量声明前使用，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var 的情况</span><br><span class=\"line\">console.log(foo); // 输出undefined</span><br><span class=\"line\">var foo = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// let 的情况</span><br><span class=\"line\">console.log(bar); // 报错ReferenceError</span><br><span class=\"line\">let bar = 2;</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h4><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的，该现象称为“暂时性死区”(temporal dead zone)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = &apos;a&apos;;</span><br><span class=\"line\">let x = &apos;b&apos;;</span><br><span class=\"line\">会报错：该变量未定义</span><br><span class=\"line\"></span><br><span class=\"line\">typeof x; //报错</span><br><span class=\"line\">let x = &apos;a&apos;;</span><br><span class=\"line\">typeof undeclear_var // undefined</span><br><span class=\"line\">会使得typeof操作符的使用不再安全</span><br><span class=\"line\"></span><br><span class=\"line\">var x = x //undefined</span><br><span class=\"line\">let x = x //报错</span><br></pre></td></tr></table></figure>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p>在同一块级作用域中不允许重复声明变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(args)&#123;</span><br><span class=\"line\">    let args;</span><br><span class=\"line\">&#125; //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function f1(args)&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    let args;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; //不报错</span><br></pre></td></tr></table></figure>\n<h3 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h3><p>const声明的变量指向的地址所保存的数据不可变，一旦声明后就不可以修改，一旦声明就要初始化。</p>\n<p>const与let一样，只在声明的块级作用域中有效，并且声明的常量也不可以提升，同样存在暂时性死区。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;;</span><br><span class=\"line\">a.property = 1; //不报错</span><br><span class=\"line\">a = &#123;&#125;; //报错 </span><br><span class=\"line\">只要保证a变量指向地址保存的数据不改变就不会报错</span><br><span class=\"line\"></span><br><span class=\"line\">function f(obj)&#123;</span><br><span class=\"line\">    Object.freeze(obj);</span><br><span class=\"line\">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">        if(typeof obj[key] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            f(obj[key]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h3><p>实际上可以看作一种模式匹配。</p>\n<h4 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = [];</span><br><span class=\"line\">let [bar, foo] = [1];</span><br><span class=\"line\">foo // undefined</span><br><span class=\"line\">解构不成功就会返回undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y] = [1, 2, 3];</span><br><span class=\"line\">不完全解构。</span><br><span class=\"line\"></span><br><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br><span class=\"line\">会报错，因为等号右边是不可便利的结构。</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];</span><br><span class=\"line\">// x=&apos;a&apos;, y=&apos;b&apos; 只有对应的位置严格等于(===)undefined，默认值才会生效。</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo, bar&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;;</span><br><span class=\"line\">let &#123;foo: foo, bar: bar&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;;</span><br><span class=\"line\">let &#123;foo: baz&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125; // baz-&gt;&quot;aaa&quot; foo-&gt;报错</span><br><span class=\"line\">let &#123;foo&#125; = &#123;bar: &quot;bbb&apos;&#125; //解构失败 foo-&gt;undefined</span><br><span class=\"line\">解构赋值的键其实是匹配的模式，而值才是指向真正的值。</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class=\"line\">x // 3</span><br><span class=\"line\">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class=\"line\">x // null</span><br><span class=\"line\">默认值的生效条件是对应匹配的值为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [1, 2, 3];</span><br><span class=\"line\">let &#123;0: first, [arr.length - 1]: last&#125; = arr;</span><br><span class=\"line\">first // 1</span><br><span class=\"line\">last // 3</span><br><span class=\"line\">数组可以进行对象属性的结构，**数组本质是特殊的对象**</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;length: len&#125; = &apos;hello&apos;;</span><br><span class=\"line\">len //5</span><br><span class=\"line\">String类中有个length属性与之匹配。</span><br></pre></td></tr></table></figure>\n<h4 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;toString: s&#125; = 123;</span><br><span class=\"line\">s === Number.prototype.toString // true</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;toString: s&#125; = true;</span><br><span class=\"line\">s === Boolean.prototype.toString // true</span><br><span class=\"line\">如果等号右边是数值或者布尔值，则会转为包装对象</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class=\"line\">let &#123; prop: y &#125; = null; // TypeError</span><br><span class=\"line\">undefined和null无法转为对象。</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class=\"line\">    return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123;x: 3, y: 3&#125;); // [3, 8]</span><br><span class=\"line\">f(&#123;x: 3&#125;); // [3, 0]</span><br><span class=\"line\">f(&#123;&#125;); // [0, 0]</span><br><span class=\"line\">f(); // [0, 0]</span><br><span class=\"line\"></span><br><span class=\"line\">function f(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123;</span><br><span class=\"line\">    return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123;x: 3, y: 3&#125;); // [3, 8]</span><br><span class=\"line\">f(&#123;x: 3&#125;); // [3, undefined]</span><br><span class=\"line\">f(&#123;&#125;); // [undefined, undefined]</span><br><span class=\"line\">f(); // [0, 0]</span><br><span class=\"line\">注意上面两种情况的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class=\"line\">// [1, &apos;yes&apos;, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><h4 id=\"为什么需要块级作用域\"><a href=\"#为什么需要块级作用域\" class=\"headerlink\" title=\"为什么需要块级作用域\"></a>为什么需要块级作用域</h4><p>es5中只有块级作用域和函数作用域，这会产生某些不合理的场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">场景一</span><br><span class=\"line\">var a = &apos;test&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    if(true)&#123;</span><br><span class=\"line\">        var a = &apos;test1&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() // undefined</span><br><span class=\"line\">本来调用f()希望得到的结果是test,但是由于函数f内的a变量提升到该函数的顶部，导致输出的a为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">场景二</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    for(var i = 0; i &lt; 10; i++)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">i // 10</span><br><span class=\"line\">循环中计数的循环变量泄露为上一层作用域的变量。</span><br></pre></td></tr></table></figure>\n<h4 id=\"es6中的块级作用域\"><a href=\"#es6中的块级作用域\" class=\"headerlink\" title=\"es6中的块级作用域\"></a>es6中的块级作用域</h4><p>es6中的let的出现实际为JavaScript增加了块级作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;</span><br><span class=\"line\">    let n = 5;</span><br><span class=\"line\">    if(true)&#123;</span><br><span class=\"line\">        let n = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(n) // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">这表明外层块级作用域不受内层块级作用域的影响。</span><br><span class=\"line\"></span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">块级作用域的出现实际上使得自执行函数不再必要了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h3><p>let命令：let命令用来声明的变量，其声明的变量只在其所在的代码块中有效。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">es5中的作用域只有函数作用域和全局作用域，在函数体中使用var定义的变量，会被提到函数开始处进行定义，作用域为整个函数。</span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    a[i] = function () &#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">a[6](); // 10</span><br><span class=\"line\">i; // 10</span><br><span class=\"line\">因为for循环并不是一个函数体，所以for循环中定义的变量的作用域是其所在的函数体，所以这里的i的输出是10，而a[6]()的输出为10是因为i一直保存的是值引用，所以显示10.</span><br><span class=\"line\"></span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">     a[i] = function () &#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">a[6](); // 6</span><br><span class=\"line\">因为let声明的变量只在块级作用域中生效，每一个循环都会产生一个新的作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">for(let i = 0; i &lt; 3; i++)&#123;</span><br><span class=\"line\">    let i = &apos;abc&apos;;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// abc</span><br><span class=\"line\">// abc</span><br><span class=\"line\">// abc</span><br><span class=\"line\">实际上在这里,整个for循环有两个作用域，设置循环变量的部分为父作用域，循环体那部分为子作用域。因为这个循环执行了三次，父作用域没有受到子作用域的影响。</span><br></pre></td></tr></table></figure>\n<h4 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h4><p>变量提升：指的是变量可以在变量声明前使用该变量，但是会输出undefined。</p>\n<p>为了纠正这种情况，使用let声明的变量不可以在变量声明前使用，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var 的情况</span><br><span class=\"line\">console.log(foo); // 输出undefined</span><br><span class=\"line\">var foo = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// let 的情况</span><br><span class=\"line\">console.log(bar); // 报错ReferenceError</span><br><span class=\"line\">let bar = 2;</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h4><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的，该现象称为“暂时性死区”(temporal dead zone)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = &apos;a&apos;;</span><br><span class=\"line\">let x = &apos;b&apos;;</span><br><span class=\"line\">会报错：该变量未定义</span><br><span class=\"line\"></span><br><span class=\"line\">typeof x; //报错</span><br><span class=\"line\">let x = &apos;a&apos;;</span><br><span class=\"line\">typeof undeclear_var // undefined</span><br><span class=\"line\">会使得typeof操作符的使用不再安全</span><br><span class=\"line\"></span><br><span class=\"line\">var x = x //undefined</span><br><span class=\"line\">let x = x //报错</span><br></pre></td></tr></table></figure>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p>在同一块级作用域中不允许重复声明变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(args)&#123;</span><br><span class=\"line\">    let args;</span><br><span class=\"line\">&#125; //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function f1(args)&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    let args;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; //不报错</span><br></pre></td></tr></table></figure>\n<h3 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h3><p>const声明的变量指向的地址所保存的数据不可变，一旦声明后就不可以修改，一旦声明就要初始化。</p>\n<p>const与let一样，只在声明的块级作用域中有效，并且声明的常量也不可以提升，同样存在暂时性死区。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;;</span><br><span class=\"line\">a.property = 1; //不报错</span><br><span class=\"line\">a = &#123;&#125;; //报错 </span><br><span class=\"line\">只要保证a变量指向地址保存的数据不改变就不会报错</span><br><span class=\"line\"></span><br><span class=\"line\">function f(obj)&#123;</span><br><span class=\"line\">    Object.freeze(obj);</span><br><span class=\"line\">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">        if(typeof obj[key] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            f(obj[key]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h3><p>实际上可以看作一种模式匹配。</p>\n<h4 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = [];</span><br><span class=\"line\">let [bar, foo] = [1];</span><br><span class=\"line\">foo // undefined</span><br><span class=\"line\">解构不成功就会返回undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y] = [1, 2, 3];</span><br><span class=\"line\">不完全解构。</span><br><span class=\"line\"></span><br><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br><span class=\"line\">会报错，因为等号右边是不可便利的结构。</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];</span><br><span class=\"line\">// x=&apos;a&apos;, y=&apos;b&apos; 只有对应的位置严格等于(===)undefined，默认值才会生效。</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo, bar&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;;</span><br><span class=\"line\">let &#123;foo: foo, bar: bar&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;;</span><br><span class=\"line\">let &#123;foo: baz&#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125; // baz-&gt;&quot;aaa&quot; foo-&gt;报错</span><br><span class=\"line\">let &#123;foo&#125; = &#123;bar: &quot;bbb&apos;&#125; //解构失败 foo-&gt;undefined</span><br><span class=\"line\">解构赋值的键其实是匹配的模式，而值才是指向真正的值。</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class=\"line\">x // 3</span><br><span class=\"line\">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class=\"line\">x // null</span><br><span class=\"line\">默认值的生效条件是对应匹配的值为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [1, 2, 3];</span><br><span class=\"line\">let &#123;0: first, [arr.length - 1]: last&#125; = arr;</span><br><span class=\"line\">first // 1</span><br><span class=\"line\">last // 3</span><br><span class=\"line\">数组可以进行对象属性的结构，**数组本质是特殊的对象**</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;length: len&#125; = &apos;hello&apos;;</span><br><span class=\"line\">len //5</span><br><span class=\"line\">String类中有个length属性与之匹配。</span><br></pre></td></tr></table></figure>\n<h4 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;toString: s&#125; = 123;</span><br><span class=\"line\">s === Number.prototype.toString // true</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;toString: s&#125; = true;</span><br><span class=\"line\">s === Boolean.prototype.toString // true</span><br><span class=\"line\">如果等号右边是数值或者布尔值，则会转为包装对象</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class=\"line\">let &#123; prop: y &#125; = null; // TypeError</span><br><span class=\"line\">undefined和null无法转为对象。</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class=\"line\">    return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123;x: 3, y: 3&#125;); // [3, 8]</span><br><span class=\"line\">f(&#123;x: 3&#125;); // [3, 0]</span><br><span class=\"line\">f(&#123;&#125;); // [0, 0]</span><br><span class=\"line\">f(); // [0, 0]</span><br><span class=\"line\"></span><br><span class=\"line\">function f(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123;</span><br><span class=\"line\">    return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123;x: 3, y: 3&#125;); // [3, 8]</span><br><span class=\"line\">f(&#123;x: 3&#125;); // [3, undefined]</span><br><span class=\"line\">f(&#123;&#125;); // [undefined, undefined]</span><br><span class=\"line\">f(); // [0, 0]</span><br><span class=\"line\">注意上面两种情况的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class=\"line\">// [1, &apos;yes&apos;, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h3>"},{"title":"java中的一些数据结构","author":23,"date":"2018-09-04T12:07:00.000Z","tag":null,"_content":"\n### 逻辑结构\n\n#### 线性结构\n\n##### 线性表\n\n线性表中分为数组和链表\n\n比较ArrayList与LinkedList的优缺点：\n\nArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity >> 1)），增大了开销。\n\nLinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。\n\n链表的一些变体：\n\n循环单链表：没有tail指针，head指向当前节点\n\n双向链表：还包含一个previous指针指向之前的节点，最后一个next为null\n\n循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点\n\n优点及应用等用到了再来记\n\n##### 栈\n\n栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）\n\n##### 队列\n\n队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）\n\n##### 哈希表\n\n#### 树型结构\n\n#### 图型结构\n\n#### 集合\n\n如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。\n\n子类在构造方法的第一行隐式的继承了超类的默认无参构造方法\n\n如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法\n\n抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。\n\n子类必须实现抽象父类中的所有方法，否则它也是抽象类\n\n### Java算法基础\n\n#### 算法中时间复杂度的注意事项\n\n#### 计算斐波那契数\n\n1.递归的方式（时间复杂度为O(2<sup>n</sup>))）\n\n```\npublic static int fib(Long index){\n        if(index==0)\n            return 0;\n        if (index==1)\n            return 1;\n        else\n            //最后都会到0或1\n            return fib(index-1)+fib(index-2);\n    }\n```\n\n2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）\n\n```\npublic static Long fib(Long index){\n        Long f0 = 0L;\n        Long f1 = 1L;\n        Long f2 = 1L;\n        if(index==0)\n            return f0;\n        if (index==1)\n            return f1;\n        else if (index==2)\n            return f2;\n        for(Long i=3L;i<=index;i++){\n            f0 = f1;\n            f1 = f2;\n            f2 = f1 + f0;\n        }\n        return f2;\n    }\n\n```\n\n#### 欧几里得算法求最大公约数\n\n1.普通求法\n\n```\nGCD(int m, int n){\n    int gcd = 1;\n    if(m%n==0)\n        return n;\n    for(int i=n/2; i>0; i--){\n        if(m%i==0&&n%i==0){\n            gcd = i;\n            break;\n        }\n    }\n    return gcd;\n}\n```\n\n2.欧几里得方法（辗转相除）\n\nm/n=k...r（k为商，r为余数）\n\n首先要明白的一点是gcd(m,n)=gcd(n,r)\n\n可以证明，设x为m,n的公约数(x能整除n,m)，r=m-nk,所以x也能整除r\n\n### 排序算法\n\n#### 选择排序\n\n#### 插入排序\n\n#### 冒泡排序\n\n#### 归并排序\n\n#### 快速排序\n\n#### 堆排序\n\n#### 桶排序和基数排序\n\n#### 外部排序","source":"_drafts/线性表、栈、队列.md","raw":"---\ntitle: java中的一些数据结构\nauthor: 0x17\ndate: 2018-09-04 20:07:00\ntag:\n---\n\n### 逻辑结构\n\n#### 线性结构\n\n##### 线性表\n\n线性表中分为数组和链表\n\n比较ArrayList与LinkedList的优缺点：\n\nArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity >> 1)），增大了开销。\n\nLinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。\n\n链表的一些变体：\n\n循环单链表：没有tail指针，head指向当前节点\n\n双向链表：还包含一个previous指针指向之前的节点，最后一个next为null\n\n循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点\n\n优点及应用等用到了再来记\n\n##### 栈\n\n栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）\n\n##### 队列\n\n队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）\n\n##### 哈希表\n\n#### 树型结构\n\n#### 图型结构\n\n#### 集合\n\n如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。\n\n子类在构造方法的第一行隐式的继承了超类的默认无参构造方法\n\n如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法\n\n抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。\n\n子类必须实现抽象父类中的所有方法，否则它也是抽象类\n\n### Java算法基础\n\n#### 算法中时间复杂度的注意事项\n\n#### 计算斐波那契数\n\n1.递归的方式（时间复杂度为O(2<sup>n</sup>))）\n\n```\npublic static int fib(Long index){\n        if(index==0)\n            return 0;\n        if (index==1)\n            return 1;\n        else\n            //最后都会到0或1\n            return fib(index-1)+fib(index-2);\n    }\n```\n\n2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）\n\n```\npublic static Long fib(Long index){\n        Long f0 = 0L;\n        Long f1 = 1L;\n        Long f2 = 1L;\n        if(index==0)\n            return f0;\n        if (index==1)\n            return f1;\n        else if (index==2)\n            return f2;\n        for(Long i=3L;i<=index;i++){\n            f0 = f1;\n            f1 = f2;\n            f2 = f1 + f0;\n        }\n        return f2;\n    }\n\n```\n\n#### 欧几里得算法求最大公约数\n\n1.普通求法\n\n```\nGCD(int m, int n){\n    int gcd = 1;\n    if(m%n==0)\n        return n;\n    for(int i=n/2; i>0; i--){\n        if(m%i==0&&n%i==0){\n            gcd = i;\n            break;\n        }\n    }\n    return gcd;\n}\n```\n\n2.欧几里得方法（辗转相除）\n\nm/n=k...r（k为商，r为余数）\n\n首先要明白的一点是gcd(m,n)=gcd(n,r)\n\n可以证明，设x为m,n的公约数(x能整除n,m)，r=m-nk,所以x也能整除r\n\n### 排序算法\n\n#### 选择排序\n\n#### 插入排序\n\n#### 冒泡排序\n\n#### 归并排序\n\n#### 快速排序\n\n#### 堆排序\n\n#### 桶排序和基数排序\n\n#### 外部排序","slug":"线性表、栈、队列","published":0,"updated":"2018-10-07T11:36:00.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v0000q7tcy5vlkg7tw","content":"<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h3><h4 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h4><h5 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h5><p>线性表中分为数组和链表</p>\n<p>比较ArrayList与LinkedList的优缺点：</p>\n<p>ArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)），增大了开销。</p>\n<p>LinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。</p>\n<p>链表的一些变体：</p>\n<p>循环单链表：没有tail指针，head指向当前节点</p>\n<p>双向链表：还包含一个previous指针指向之前的节点，最后一个next为null</p>\n<p>循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点</p>\n<p>优点及应用等用到了再来记</p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><p>栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）</p>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）</p>\n<h5 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h5><h4 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"树型结构\"></a>树型结构</h4><h4 id=\"图型结构\"><a href=\"#图型结构\" class=\"headerlink\" title=\"图型结构\"></a>图型结构</h4><h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。</p>\n<p>子类在构造方法的第一行隐式的继承了超类的默认无参构造方法</p>\n<p>如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法</p>\n<p>抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。</p>\n<p>子类必须实现抽象父类中的所有方法，否则它也是抽象类</p>\n<h3 id=\"Java算法基础\"><a href=\"#Java算法基础\" class=\"headerlink\" title=\"Java算法基础\"></a>Java算法基础</h3><h4 id=\"算法中时间复杂度的注意事项\"><a href=\"#算法中时间复杂度的注意事项\" class=\"headerlink\" title=\"算法中时间复杂度的注意事项\"></a>算法中时间复杂度的注意事项</h4><h4 id=\"计算斐波那契数\"><a href=\"#计算斐波那契数\" class=\"headerlink\" title=\"计算斐波那契数\"></a>计算斐波那契数</h4><p>1.递归的方式（时间复杂度为O(2<sup>n</sup>))）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int fib(Long index)&#123;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            //最后都会到0或1</span><br><span class=\"line\">            return fib(index-1)+fib(index-2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Long fib(Long index)&#123;</span><br><span class=\"line\">        Long f0 = 0L;</span><br><span class=\"line\">        Long f1 = 1L;</span><br><span class=\"line\">        Long f2 = 1L;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return f0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return f1;</span><br><span class=\"line\">        else if (index==2)</span><br><span class=\"line\">            return f2;</span><br><span class=\"line\">        for(Long i=3L;i&lt;=index;i++)&#123;</span><br><span class=\"line\">            f0 = f1;</span><br><span class=\"line\">            f1 = f2;</span><br><span class=\"line\">            f2 = f1 + f0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return f2;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"欧几里得算法求最大公约数\"><a href=\"#欧几里得算法求最大公约数\" class=\"headerlink\" title=\"欧几里得算法求最大公约数\"></a>欧几里得算法求最大公约数</h4><p>1.普通求法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GCD(int m, int n)&#123;</span><br><span class=\"line\">    int gcd = 1;</span><br><span class=\"line\">    if(m%n==0)</span><br><span class=\"line\">        return n;</span><br><span class=\"line\">    for(int i=n/2; i&gt;0; i--)&#123;</span><br><span class=\"line\">        if(m%i==0&amp;&amp;n%i==0)&#123;</span><br><span class=\"line\">            gcd = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return gcd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.欧几里得方法（辗转相除）</p>\n<p>m/n=k…r（k为商，r为余数）</p>\n<p>首先要明白的一点是gcd(m,n)=gcd(n,r)</p>\n<p>可以证明，设x为m,n的公约数(x能整除n,m)，r=m-nk,所以x也能整除r</p>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"桶排序和基数排序\"><a href=\"#桶排序和基数排序\" class=\"headerlink\" title=\"桶排序和基数排序\"></a>桶排序和基数排序</h4><h4 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h3><h4 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h4><h5 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h5><p>线性表中分为数组和链表</p>\n<p>比较ArrayList与LinkedList的优缺点：</p>\n<p>ArrayList：实现类RandomAccess（是一种标识接口，表示随机任意访问下标元素都比较快）接口，比较适合get与set操作，但不适合在数据结构中插值或者是删值，因为它每次这样操作，在它插入或删除位置后面的所有数据就得移动位置，并且初始容量固定，当插入一个值时超出容量还得扩容（newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)），增大了开销。</p>\n<p>LinkedList：实现了Deque（双端队列）接口，可以在链表的首尾两端进行插入和删除操作，效率比ArrayList要高，并且容量不固定。但是它是由一个一个节点串联起来的，初始化的开销要大于ArrayList。它通过index获得元素的方法是：循环遍历链表，将current指针一步一步挪到index的位置，所以效率比ArrayList低一些。</p>\n<p>链表的一些变体：</p>\n<p>循环单链表：没有tail指针，head指向当前节点</p>\n<p>双向链表：还包含一个previous指针指向之前的节点，最后一个next为null</p>\n<p>循环双向链表：和双向链表差不多，就是最后一个next指向第一个节点</p>\n<p>优点及应用等用到了再来记</p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><p>栈是一种特殊的线性表，只能在栈顶进行操作，符合后进先出的规则（可以通过ArrayList实现）</p>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>队列也是一种特殊的线性表，只能在队列首部删除，尾部添加，符合先进先出的规则（可以通过LinkedList实现）</p>\n<h5 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h5><h4 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"树型结构\"></a>树型结构</h4><h4 id=\"图型结构\"><a href=\"#图型结构\" class=\"headerlink\" title=\"图型结构\"></a>图型结构</h4><h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>如果Java类（包括抽象类）没有显式的定义构造方法，那么Java编译器会自动给该类添加上一个无参构造方法。</p>\n<p>子类在构造方法的第一行隐式的继承了超类的默认无参构造方法</p>\n<p>如果超类自定义了构造方法（不是默认无参构造方法），那么子类也得在自定义（为什么强调自定义？因为编译器给的无参构造方法是隐式继承父类的默认构造方法，而这里的超类没有）的构造方法第一行通过关键字super显式的继承超类的构造方法</p>\n<p>抽象类实现接口：当我们不需要一个类实现接口中所有的方法时，可以先让一个抽象类实现接口的部分方法，然后通过继承这个抽象类（尽管这些方法还是要继承下来，但是我们在需要使用方法的是在重写方法，避免了类实现接口必须实现接口中全部的方法），实现接口中剩下的方法。</p>\n<p>子类必须实现抽象父类中的所有方法，否则它也是抽象类</p>\n<h3 id=\"Java算法基础\"><a href=\"#Java算法基础\" class=\"headerlink\" title=\"Java算法基础\"></a>Java算法基础</h3><h4 id=\"算法中时间复杂度的注意事项\"><a href=\"#算法中时间复杂度的注意事项\" class=\"headerlink\" title=\"算法中时间复杂度的注意事项\"></a>算法中时间复杂度的注意事项</h4><h4 id=\"计算斐波那契数\"><a href=\"#计算斐波那契数\" class=\"headerlink\" title=\"计算斐波那契数\"></a>计算斐波那契数</h4><p>1.递归的方式（时间复杂度为O(2<sup>n</sup>))）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int fib(Long index)&#123;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            //最后都会到0或1</span><br><span class=\"line\">            return fib(index-1)+fib(index-2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>2.动态编程的方式（将问题分为一个一个子问题，然后将子问题结合起来得到问题答案，时间复杂度为O(n)）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Long fib(Long index)&#123;</span><br><span class=\"line\">        Long f0 = 0L;</span><br><span class=\"line\">        Long f1 = 1L;</span><br><span class=\"line\">        Long f2 = 1L;</span><br><span class=\"line\">        if(index==0)</span><br><span class=\"line\">            return f0;</span><br><span class=\"line\">        if (index==1)</span><br><span class=\"line\">            return f1;</span><br><span class=\"line\">        else if (index==2)</span><br><span class=\"line\">            return f2;</span><br><span class=\"line\">        for(Long i=3L;i&lt;=index;i++)&#123;</span><br><span class=\"line\">            f0 = f1;</span><br><span class=\"line\">            f1 = f2;</span><br><span class=\"line\">            f2 = f1 + f0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return f2;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"欧几里得算法求最大公约数\"><a href=\"#欧几里得算法求最大公约数\" class=\"headerlink\" title=\"欧几里得算法求最大公约数\"></a>欧几里得算法求最大公约数</h4><p>1.普通求法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GCD(int m, int n)&#123;</span><br><span class=\"line\">    int gcd = 1;</span><br><span class=\"line\">    if(m%n==0)</span><br><span class=\"line\">        return n;</span><br><span class=\"line\">    for(int i=n/2; i&gt;0; i--)&#123;</span><br><span class=\"line\">        if(m%i==0&amp;&amp;n%i==0)&#123;</span><br><span class=\"line\">            gcd = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return gcd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.欧几里得方法（辗转相除）</p>\n<p>m/n=k…r（k为商，r为余数）</p>\n<p>首先要明白的一点是gcd(m,n)=gcd(n,r)</p>\n<p>可以证明，设x为m,n的公约数(x能整除n,m)，r=m-nk,所以x也能整除r</p>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"桶排序和基数排序\"><a href=\"#桶排序和基数排序\" class=\"headerlink\" title=\"桶排序和基数排序\"></a>桶排序和基数排序</h4><h4 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h4>"},{"title":"项目开发注意事项","author":23,"date":"2018-09-04T12:07:00.000Z","tag":null,"_content":"\n\n### 权限控制\n\n横向越权：恶意修改同样角色的信息\n\n纵向越权：低级权限用户操纵高级权限的操作\n\n### Guava Cache\n\n### 请求重定向与转发\n\n### LRU算法\n\n### Java中的MD5\n\n为了防止MD5字典穷举，我们可以进行加盐值，提高MD5的复杂度。","source":"_drafts/项目开发注意事项.md","raw":"---\ntitle: 项目开发注意事项\nauthor: 0x17\ndate: 2018-09-04 20:07:00\ntag:\n---\n\n\n### 权限控制\n\n横向越权：恶意修改同样角色的信息\n\n纵向越权：低级权限用户操纵高级权限的操作\n\n### Guava Cache\n\n### 请求重定向与转发\n\n### LRU算法\n\n### Java中的MD5\n\n为了防止MD5字典穷举，我们可以进行加盐值，提高MD5的复杂度。","slug":"项目开发注意事项","published":0,"updated":"2018-10-05T02:39:15.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v2000r7tcykot0ld5i","content":"<h3 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h3><p>横向越权：恶意修改同样角色的信息</p>\n<p>纵向越权：低级权限用户操纵高级权限的操作</p>\n<h3 id=\"Guava-Cache\"><a href=\"#Guava-Cache\" class=\"headerlink\" title=\"Guava Cache\"></a>Guava Cache</h3><h3 id=\"请求重定向与转发\"><a href=\"#请求重定向与转发\" class=\"headerlink\" title=\"请求重定向与转发\"></a>请求重定向与转发</h3><h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><h3 id=\"Java中的MD5\"><a href=\"#Java中的MD5\" class=\"headerlink\" title=\"Java中的MD5\"></a>Java中的MD5</h3><p>为了防止MD5字典穷举，我们可以进行加盐值，提高MD5的复杂度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h3><p>横向越权：恶意修改同样角色的信息</p>\n<p>纵向越权：低级权限用户操纵高级权限的操作</p>\n<h3 id=\"Guava-Cache\"><a href=\"#Guava-Cache\" class=\"headerlink\" title=\"Guava Cache\"></a>Guava Cache</h3><h3 id=\"请求重定向与转发\"><a href=\"#请求重定向与转发\" class=\"headerlink\" title=\"请求重定向与转发\"></a>请求重定向与转发</h3><h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><h3 id=\"Java中的MD5\"><a href=\"#Java中的MD5\" class=\"headerlink\" title=\"Java中的MD5\"></a>Java中的MD5</h3><p>为了防止MD5字典穷举，我们可以进行加盐值，提高MD5的复杂度。</p>\n"},{"title":"Markdown学习笔记","author":"0x17","date":"2018-05-04T09:04:53.000Z","_content":"\n### Markdown简介\n\nMarkdown是一种文本标记语言，通过一些简洁、常用的符号修饰，使得文本具有一定的格式。\n\n### 基本语法\n\n#### 段落\n\n一行文字就是一个段落，如需换行，需要在两个段落之间隔一个空行\n\n#### 粗体、斜体\n\n可以使用下划线\\_和星号\\*表示粗体和斜体\n\n```\n_这是斜体_\n*这也是斜体_\n**这是粗体**\n***这是粗体和斜体***\n```\n\n会被解释为\n```\n<em>这是斜体</em>\n<em>这也是斜体</em>\n<strong>这是粗体</strong>\n<strong><em>这是粗体和斜体</em></strong>\n```\n\n#### 删除线\n\n使用波浪线\\~表示删除线\n\n```\n~这是删除线~\n```\n\n解释为\n\n```\n<strike>这是删除线</strike>\n```\n\n#### 标题\n\n使用#表示标题，总共支持六级标题\n\n```\n#h1#\n\n##h2##\n\n###h3###\n\n...\n\n######h6######\n```\n\n行尾可以加上任意数量\\#，可以不加，也可以加对称\\#\n\n#### 引用\n\n使用\\>表示引用，并且可以嵌套\n\n```\n>This is the first level of quoting.\n>\n>>This is nested blockquote.\n>\n>Back ot the first level.\n```\n\n#### 列表\n\n##### 无序列表\n\n列表使用\\*、\\+、\\-作为列表标记\n\n```\n*pig\n*dog\n*cat\n\n+pig\n+dog\n+cat\n\n-pig\n-dog\n-cat\n```\n\n##### 有序列表\n\n有序列表直接数字接一个英文\\.，数字并不影响输出的HTML中的序号\n\n#### 内联代码\n\n使用反引号\\`来标记内联代码，会被解释为`<code>`标签，如果代码中有反引号请用两个反引号包裹\n\n\t``aaa`bb`ccc``\n\n#### 分隔线\n\n在一行中使用三个及以上的\\*、\\-、\\_来表示分隔线，行内不能有其他东西但是可以有空格\n\n```\n*******\n* *** *****\n-------------\n_____________\n```\n\n#### 链接\n\n使用`[char](url)`来表示一个来表示一个链接\n\n```\n[江西](http://www.jiangxi.gov.cn/)`\n```\n\n[江西](http://www.jiangxi.gov.cn/)\n\n#### 图像\n\n插入图片\n\n```\n![Alt text]('url' 'description')\n```\n\n插入带连接的图片\n\n```\n[![Alt text]('picURI' 'description')](url){:target=\"_blank\"}\n```\n\n#### 自动连接\n\n就是指链接地址与名字重复，可以用**<>**将其简化\n\n```\n<http://example.com>\n\n相当于\n\n[http://example.com](http://example.com)\n```\n\n#### 转义\n\n以下字符添加反斜杠即可转义\n\n```\n\\\n`\n*\n_\n{}\n[]\n()\n#\n+\n-\n.\n!\n```\n\n#### 表格\n\n`:`向哪边就向哪边对齐（默认居左）\n\n```\n|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n|=========|===============|============|\n```\n\n| a | b | c |\n|:-:|:- | -:|\n| 居中 | 左对齐 | 右对齐 |\n|=|=|=|\n\n#### 内联HTML\n\nhtml原样输出\n\n#### 表情代码\n\n两个`:`中间引入表情代码\n\n:smile:\n\n\n","source":"_posts/Markdown学习笔记.md","raw":"---\ntitle: Markdown学习笔记\nauthor: \"0x17\"\ndate: 2018-05-04 17:04:53\ntags:\n---\n\n### Markdown简介\n\nMarkdown是一种文本标记语言，通过一些简洁、常用的符号修饰，使得文本具有一定的格式。\n\n### 基本语法\n\n#### 段落\n\n一行文字就是一个段落，如需换行，需要在两个段落之间隔一个空行\n\n#### 粗体、斜体\n\n可以使用下划线\\_和星号\\*表示粗体和斜体\n\n```\n_这是斜体_\n*这也是斜体_\n**这是粗体**\n***这是粗体和斜体***\n```\n\n会被解释为\n```\n<em>这是斜体</em>\n<em>这也是斜体</em>\n<strong>这是粗体</strong>\n<strong><em>这是粗体和斜体</em></strong>\n```\n\n#### 删除线\n\n使用波浪线\\~表示删除线\n\n```\n~这是删除线~\n```\n\n解释为\n\n```\n<strike>这是删除线</strike>\n```\n\n#### 标题\n\n使用#表示标题，总共支持六级标题\n\n```\n#h1#\n\n##h2##\n\n###h3###\n\n...\n\n######h6######\n```\n\n行尾可以加上任意数量\\#，可以不加，也可以加对称\\#\n\n#### 引用\n\n使用\\>表示引用，并且可以嵌套\n\n```\n>This is the first level of quoting.\n>\n>>This is nested blockquote.\n>\n>Back ot the first level.\n```\n\n#### 列表\n\n##### 无序列表\n\n列表使用\\*、\\+、\\-作为列表标记\n\n```\n*pig\n*dog\n*cat\n\n+pig\n+dog\n+cat\n\n-pig\n-dog\n-cat\n```\n\n##### 有序列表\n\n有序列表直接数字接一个英文\\.，数字并不影响输出的HTML中的序号\n\n#### 内联代码\n\n使用反引号\\`来标记内联代码，会被解释为`<code>`标签，如果代码中有反引号请用两个反引号包裹\n\n\t``aaa`bb`ccc``\n\n#### 分隔线\n\n在一行中使用三个及以上的\\*、\\-、\\_来表示分隔线，行内不能有其他东西但是可以有空格\n\n```\n*******\n* *** *****\n-------------\n_____________\n```\n\n#### 链接\n\n使用`[char](url)`来表示一个来表示一个链接\n\n```\n[江西](http://www.jiangxi.gov.cn/)`\n```\n\n[江西](http://www.jiangxi.gov.cn/)\n\n#### 图像\n\n插入图片\n\n```\n![Alt text]('url' 'description')\n```\n\n插入带连接的图片\n\n```\n[![Alt text]('picURI' 'description')](url){:target=\"_blank\"}\n```\n\n#### 自动连接\n\n就是指链接地址与名字重复，可以用**<>**将其简化\n\n```\n<http://example.com>\n\n相当于\n\n[http://example.com](http://example.com)\n```\n\n#### 转义\n\n以下字符添加反斜杠即可转义\n\n```\n\\\n`\n*\n_\n{}\n[]\n()\n#\n+\n-\n.\n!\n```\n\n#### 表格\n\n`:`向哪边就向哪边对齐（默认居左）\n\n```\n|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n|=========|===============|============|\n```\n\n| a | b | c |\n|:-:|:- | -:|\n| 居中 | 左对齐 | 右对齐 |\n|=|=|=|\n\n#### 内联HTML\n\nhtml原样输出\n\n#### 表情代码\n\n两个`:`中间引入表情代码\n\n:smile:\n\n\n","slug":"Markdown学习笔记","published":1,"updated":"2018-10-05T02:39:15.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v3000s7tcyq2qxriuc","content":"<h3 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h3><p>Markdown是一种文本标记语言，通过一些简洁、常用的符号修饰，使得文本具有一定的格式。</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h4><p>一行文字就是一个段落，如需换行，需要在两个段落之间隔一个空行</p>\n<h4 id=\"粗体、斜体\"><a href=\"#粗体、斜体\" class=\"headerlink\" title=\"粗体、斜体\"></a>粗体、斜体</h4><p>可以使用下划线_和星号*表示粗体和斜体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_这是斜体_</span><br><span class=\"line\">*这也是斜体_</span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是粗体和斜体***</span><br></pre></td></tr></table></figure>\n<p>会被解释为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;em&gt;这是斜体&lt;/em&gt;</span><br><span class=\"line\">&lt;em&gt;这也是斜体&lt;/em&gt;</span><br><span class=\"line\">&lt;strong&gt;这是粗体&lt;/strong&gt;</span><br><span class=\"line\">&lt;strong&gt;&lt;em&gt;这是粗体和斜体&lt;/em&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h4><p>使用波浪线~表示删除线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~这是删除线~</span><br></pre></td></tr></table></figure>\n<p>解释为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;strike&gt;这是删除线&lt;/strike&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p>使用#表示标题，总共支持六级标题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#h1#</span><br><span class=\"line\"></span><br><span class=\"line\">##h2##</span><br><span class=\"line\"></span><br><span class=\"line\">###h3###</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">######h6######</span><br></pre></td></tr></table></figure>\n<p>行尾可以加上任意数量#，可以不加，也可以加对称#</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>使用>表示引用，并且可以嵌套</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;&gt;This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;Back ot the first level.</span><br></pre></td></tr></table></figure>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><h5 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h5><p>列表使用*、+、-作为列表标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pig</span><br><span class=\"line\">*dog</span><br><span class=\"line\">*cat</span><br><span class=\"line\"></span><br><span class=\"line\">+pig</span><br><span class=\"line\">+dog</span><br><span class=\"line\">+cat</span><br><span class=\"line\"></span><br><span class=\"line\">-pig</span><br><span class=\"line\">-dog</span><br><span class=\"line\">-cat</span><br></pre></td></tr></table></figure>\n<h5 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h5><p>有序列表直接数字接一个英文.，数字并不影响输出的HTML中的序号</p>\n<h4 id=\"内联代码\"><a href=\"#内联代码\" class=\"headerlink\" title=\"内联代码\"></a>内联代码</h4><p>使用反引号`来标记内联代码，会被解释为<code>&lt;code&gt;</code>标签，如果代码中有反引号请用两个反引号包裹</p>\n<pre><code>``aaa`bb`ccc``\n</code></pre><h4 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h4><p>在一行中使用三个及以上的*、-、_来表示分隔线，行内不能有其他东西但是可以有空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*******</span><br><span class=\"line\">* *** *****</span><br><span class=\"line\">-------------</span><br><span class=\"line\">_____________</span><br></pre></td></tr></table></figure>\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>使用<code>[char](url)</code>来表示一个来表示一个链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[江西](http://www.jiangxi.gov.cn/)`</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.jiangxi.gov.cn/\" target=\"_blank\" rel=\"noopener\">江西</a></p>\n<h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](&apos;url&apos; &apos;description&apos;)</span><br></pre></td></tr></table></figure>\n<p>插入带连接的图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[![Alt text](&apos;picURI&apos; &apos;description&apos;)](url)&#123;:target=&quot;_blank&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动连接\"><a href=\"#自动连接\" class=\"headerlink\" title=\"自动连接\"></a>自动连接</h4><p>就是指链接地址与名字重复，可以用<strong>&lt;&gt;</strong>将其简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">相当于</span><br><span class=\"line\"></span><br><span class=\"line\">[http://example.com](http://example.com)</span><br></pre></td></tr></table></figure>\n<h4 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h4><p>以下字符添加反斜杠即可转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\</span><br><span class=\"line\">`</span><br><span class=\"line\">*</span><br><span class=\"line\">_</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\">[]</span><br><span class=\"line\">()</span><br><span class=\"line\">#</span><br><span class=\"line\">+</span><br><span class=\"line\">-</span><br><span class=\"line\">.</span><br><span class=\"line\">!</span><br></pre></td></tr></table></figure>\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p><code>:</code>向哪边就向哪边对齐（默认居左）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|    a    |       b       |      c     |</span><br><span class=\"line\">|:-------:|:------------- | ----------:|</span><br><span class=\"line\">|   居中  |     左对齐    |   右对齐   |</span><br><span class=\"line\">|=========|===============|============|</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">a</th>\n<th style=\"text-align:left\">b</th>\n<th style=\"text-align:right\">c</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">居中</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">=</td>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:right\">=</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"内联HTML\"><a href=\"#内联HTML\" class=\"headerlink\" title=\"内联HTML\"></a>内联HTML</h4><p>html原样输出</p>\n<h4 id=\"表情代码\"><a href=\"#表情代码\" class=\"headerlink\" title=\"表情代码\"></a>表情代码</h4><p>两个<code>:</code>中间引入表情代码</p>\n<p>:smile:</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h3><p>Markdown是一种文本标记语言，通过一些简洁、常用的符号修饰，使得文本具有一定的格式。</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h4><p>一行文字就是一个段落，如需换行，需要在两个段落之间隔一个空行</p>\n<h4 id=\"粗体、斜体\"><a href=\"#粗体、斜体\" class=\"headerlink\" title=\"粗体、斜体\"></a>粗体、斜体</h4><p>可以使用下划线_和星号*表示粗体和斜体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_这是斜体_</span><br><span class=\"line\">*这也是斜体_</span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是粗体和斜体***</span><br></pre></td></tr></table></figure>\n<p>会被解释为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;em&gt;这是斜体&lt;/em&gt;</span><br><span class=\"line\">&lt;em&gt;这也是斜体&lt;/em&gt;</span><br><span class=\"line\">&lt;strong&gt;这是粗体&lt;/strong&gt;</span><br><span class=\"line\">&lt;strong&gt;&lt;em&gt;这是粗体和斜体&lt;/em&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h4><p>使用波浪线~表示删除线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~这是删除线~</span><br></pre></td></tr></table></figure>\n<p>解释为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;strike&gt;这是删除线&lt;/strike&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p>使用#表示标题，总共支持六级标题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#h1#</span><br><span class=\"line\"></span><br><span class=\"line\">##h2##</span><br><span class=\"line\"></span><br><span class=\"line\">###h3###</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">######h6######</span><br></pre></td></tr></table></figure>\n<p>行尾可以加上任意数量#，可以不加，也可以加对称#</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>使用>表示引用，并且可以嵌套</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;&gt;This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;Back ot the first level.</span><br></pre></td></tr></table></figure>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><h5 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h5><p>列表使用*、+、-作为列表标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pig</span><br><span class=\"line\">*dog</span><br><span class=\"line\">*cat</span><br><span class=\"line\"></span><br><span class=\"line\">+pig</span><br><span class=\"line\">+dog</span><br><span class=\"line\">+cat</span><br><span class=\"line\"></span><br><span class=\"line\">-pig</span><br><span class=\"line\">-dog</span><br><span class=\"line\">-cat</span><br></pre></td></tr></table></figure>\n<h5 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h5><p>有序列表直接数字接一个英文.，数字并不影响输出的HTML中的序号</p>\n<h4 id=\"内联代码\"><a href=\"#内联代码\" class=\"headerlink\" title=\"内联代码\"></a>内联代码</h4><p>使用反引号`来标记内联代码，会被解释为<code>&lt;code&gt;</code>标签，如果代码中有反引号请用两个反引号包裹</p>\n<pre><code>``aaa`bb`ccc``\n</code></pre><h4 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h4><p>在一行中使用三个及以上的*、-、_来表示分隔线，行内不能有其他东西但是可以有空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*******</span><br><span class=\"line\">* *** *****</span><br><span class=\"line\">-------------</span><br><span class=\"line\">_____________</span><br></pre></td></tr></table></figure>\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>使用<code>[char](url)</code>来表示一个来表示一个链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[江西](http://www.jiangxi.gov.cn/)`</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.jiangxi.gov.cn/\" target=\"_blank\" rel=\"noopener\">江西</a></p>\n<h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><p>插入图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](&apos;url&apos; &apos;description&apos;)</span><br></pre></td></tr></table></figure>\n<p>插入带连接的图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[![Alt text](&apos;picURI&apos; &apos;description&apos;)](url)&#123;:target=&quot;_blank&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动连接\"><a href=\"#自动连接\" class=\"headerlink\" title=\"自动连接\"></a>自动连接</h4><p>就是指链接地址与名字重复，可以用<strong>&lt;&gt;</strong>将其简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">相当于</span><br><span class=\"line\"></span><br><span class=\"line\">[http://example.com](http://example.com)</span><br></pre></td></tr></table></figure>\n<h4 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h4><p>以下字符添加反斜杠即可转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\</span><br><span class=\"line\">`</span><br><span class=\"line\">*</span><br><span class=\"line\">_</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\">[]</span><br><span class=\"line\">()</span><br><span class=\"line\">#</span><br><span class=\"line\">+</span><br><span class=\"line\">-</span><br><span class=\"line\">.</span><br><span class=\"line\">!</span><br></pre></td></tr></table></figure>\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p><code>:</code>向哪边就向哪边对齐（默认居左）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|    a    |       b       |      c     |</span><br><span class=\"line\">|:-------:|:------------- | ----------:|</span><br><span class=\"line\">|   居中  |     左对齐    |   右对齐   |</span><br><span class=\"line\">|=========|===============|============|</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">a</th>\n<th style=\"text-align:left\">b</th>\n<th style=\"text-align:right\">c</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">居中</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">=</td>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:right\">=</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"内联HTML\"><a href=\"#内联HTML\" class=\"headerlink\" title=\"内联HTML\"></a>内联HTML</h4><p>html原样输出</p>\n<h4 id=\"表情代码\"><a href=\"#表情代码\" class=\"headerlink\" title=\"表情代码\"></a>表情代码</h4><p>两个<code>:</code>中间引入表情代码</p>\n<p>:smile:</p>\n"},{"title":"项目关键点","_content":"\n### 学习Guava\n\n### MD5\n\nJava中MD5的具体实现及加盐值\n\n### ","source":"_drafts/项目关键点.md","raw":"---\ntitle: 项目关键点\ntags:\n---\n\n### 学习Guava\n\n### MD5\n\nJava中MD5的具体实现及加盐值\n\n### ","slug":"项目关键点","published":0,"date":"2018-10-05T02:39:15.206Z","updated":"2018-10-05T02:39:15.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v5000t7tcyr1kpy4dx","content":"<h3 id=\"学习Guava\"><a href=\"#学习Guava\" class=\"headerlink\" title=\"学习Guava\"></a>学习Guava</h3><h3 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h3><p>Java中MD5的具体实现及加盐值</p>\n<p>### </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"学习Guava\"><a href=\"#学习Guava\" class=\"headerlink\" title=\"学习Guava\"></a>学习Guava</h3><h3 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h3><p>Java中MD5的具体实现及加盐值</p>\n<p>### </p>\n"},{"title":"","_content":"","source":"_drafts/部署描述符详解.md","raw":"---\ntitle: \n\n---\n","slug":"部署描述符详解","published":0,"date":"2018-10-27T13:59:32.366Z","updated":"2018-10-27T13:59:32.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v6000u7tcy0zb2456n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java学习笔记","author":"0x17","date":"2018-07-24T09:04:53.000Z","_content":"\n### 包装类\n\n首先了解java中的八种基本类型：\n```\nbyte(1byte),short(2bytes),int(4bytes),long(8bytes)\nfloat(4bytes),double(8bytes)\nchar(2bytes)\nboolean(暂未确定，依赖Java虚拟机具体实现)\n```\n[参考](https://www.jianshu.com/p/2f663dc820d0))\n\n#### 什么是包装类\n\n为了将基本类型封装面向对象，设计类时将八种基本类型设计了对应的类，这样的类称为包装类，位于java.lang包中。\n\n#### 包装类的作用\n\n1.有时候方法需要传递一个Object参数，这是就可以使用包装类。\n\n2.集合不允许存放基本类型数据。\n\n3.包装类中封装了一些方法和常量，比如类型最大值，类型转换方法。\n\n4.String可以和基本类型互相转换。\n\n#### 使用\n\n自动装箱：基本类型转包装类，自动装箱过程调用 valueOf() 方法,valueOf()查看该值是否存在缓存中\n```\npublic static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\nInteger i = 10;\n\n自动拆箱：包装类转基本类型\nInteger i = 10;\nint a = i;\n\n#### 注意\n\n包装类中除了Float与Double，都有缓存值，如果在缓存值的范围内，直接引用缓存值（-128-127）。[参考](https://blog.csdn.net/qq_29119581/article/details/78327759)\n\n### Singleton\n\n#### 为什么要使用单例模式\n\n1.控制资源的使用，通过线程同步来控制资源的并发访问；\n\n2.控制实例产生的数量，达到节约资源的目的。\n\n3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。\n\n[参考](https://www.cnblogs.com/andy-zhou/p/5363585.html)\n\n#### 饿汉模式\n\n```\npublic class Singleton{\n    private static Singleton singleton = new Singleton();\n    private Singleton(){}\n    public static Singleton getSingleton(){\n        return singleton;\n    }\n}\n```\n特点：简单安全，但是无法达到延迟加载\n\n#### 懒汉模式\n\n```\npublic class Singleton{\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getSingleton(){\n        if(singleton == null) singleton = new Singleton();\n        return singleton;\n    }\n}\n```\n特点：可以延迟加载但是线程不安全，会导致创建多个实例\n\n[其他优化模式](https://www.cnblogs.com/andy-zhou/p/5363585.html)\n\n### java中的封装、继承、多态与组合\n\n封装：将类中的属性定义为私有的，然后对象通过类中暴露公有的方法来对数据进行操作，这样我们通过自定义公有方法来控制数据的方法方式。\n\n继承：子类继承超类的属性和方法，还可以对超类进行拓展。\n\n多态：比如说一个接口可以有不同的实现，一个标准有不同的实现。\n\n组合：所以总结来说，“is-a ”（是一个）的关系是用继承来表达的，而“has-a\"（有一个）的关系则是用组合来表达的。比如说汽车属于一种交通工具，这是一种继承关系，而汽车拥有发动机，门窗等零部件，这是组合的关系。\n\n### java抽象类和接口\n\n只要类中有抽象方法那么这个类就是抽象类，或者直接被修饰为abstract。\n\n接口算是一个特殊的抽象类，其中所有的变量都为静态常量，所有方法都为静态方法，且没有静态方法。\n\n一个类如果继承抽象类，那么必须得实现抽象类中所有的抽象方法，否则它也是一个抽象类。\n\n一个类可以实现多个接口。\n\n### Java内部类，内部私有类的作用\n\n### java合集\n\n#### 搞清楚其中类和接口的关系关系\n\n![Please Wait](2018_9_6.gif)\n\n#### Iterator与Iterable\n\nIterator与Iterable都是接口，从字面上可以分别理解为迭代器和可迭代的。\n\nIterator中有hasNext(), next(), remove(), forEachRemaining()等方法。\n\nIterable中有一个iterator方法，用来返回一个iterator，也就是返回一个迭代器\n\n### comparable与comparator\n\n### 序列化与反序列化\n\n序列化：把对象转换为字节序列的过程称为对象的序列化\n\n反序列化：把字节序列恢复为对象的过程称为对象的反序列化\n\n作用：\n\n1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中　\n   \n如：在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。\n\n2.在网络上传送对象的字节序列\n   \n如：当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。\n\n### 面向接口编程\n\n### 异常处理\n\n### io中各种类的关系与作用\n\n### 多线程编程\n\n### tomcat与apache与nginx的区别\n\nApache HTTP服务器和Nginx服务器都是http服务器，用来存放静态资源，比如说image,css,html等文件，有一些编程语言中的类库也都可以实现一个简单的http服务器，比如说java或者node。Tomcat服务器除了以上功能还可以发送动态资源，比如说通过Java Server Pages技术可以添加Java语句，jsp本质上就是一个servlet，Tomcat是一个能够运行servlet的容器，管理servlet的生命周期、将url映射到servlet进行处理等。\n\nNginx除此之外还是一款优秀的反向代理服务器\n\n#### 反向代理与负载均衡\n\n[反向代理](https://www.zhihu.com/question/24723688/answer/128105528)：\n\n**正向代理**代理的是客户端，隐藏了客户端的信息\n\n**反向代理**代理的是服务器，隐藏了服务器的信息\n\n[负载均衡](https://zhuanlan.zhihu.com/p/32841479):\n\n将工作分布到多个服务器（能处理相同的请求）来提高应用的性能和可靠性，代理服务器能通过高效的算法将请求转发到性能良好的服务器中进行处理。\n\n### java中的内存管理\n\njava中的内存区域大致可分为CPU寄存器、栈、堆、静态域、常量池等。\n\n#### 字符串的两种创建方式\n\n```\n//第一种创建方式\nString s1 = \"hello\";\nString s2 = \"hello\";\nString s3 = \"world\";\n//第二种创建方式\nString str1 = new String(\"hello\");\nString str2 = new String(\"hello\");\n\nSystem.out.println(\"s1==s2:\"+(s1==s2));//true\nSystem.out.println(\"s1==str1:\"+(s1==str1));//false\nSystem.out.println(\"str1==str2:\"+(str1==str2));//false\n\nString s4 = \"hello\"+\" \"+\"world\";\nString s5 = s2+\" \"+s3;\nString s6 = \"hello world\";\nSystem.out.println(\"s4==s6:\"+(s4==s6));//ture\nSystem.out.println(\"s5==s6:\"+(s5==s6));//false\n```\n第一种创建字符串的时候，会在常量池中查找是否有该对象，如果有，直接指向该内存地址，如果没有，先在常量池中创建，然后再指向其地址。这个过程在编译期就执行好了。\n\n第二种创建字符串，使用String的构造方法，在堆中创建String对象，然后String中的value在常量池中查找是否有该常量，该过程在运行期执行。\n\n```\n//String的构造方法\npublic String(String original) {\n        this.value = original.value;\n        this.hash = original.hash;\n    }\n```\n\n\n### String StringBuilder StringBuffer\n\nString如上第一种声明的为字符串常量，所以随后对字符串的操作就是不断地创建与销毁对象。\nStringBuilder和StringBuffer为字符串变量，可以直接更改指向的内容。在线程安全上，StringBuilder是线程不安全的，StringBuffer是线程安全的，可以看到StringBuffer中的很多方法都是带有synchronized关键字的。\n\nString:适用于少量的字符串操作。\n\nStringBuilder:适用于单线程下在字符缓冲区进行大量操作的情况。\n\nStringBuffer:适用于多线程下在字符缓冲区进行大量操作的情况（线程安全）。\n\n#### 垃圾回收机制\n\n### java注解\n\n#### 元注解\n\n元注解也是注解，它是用来给自定义注解标识的信息的。\n\n### Java泛型（generic）\n\nJava泛型可以参数化类型，泛型存在于编译时期，如果泛型类型是安全的，就将泛型转换为原始类型，所以泛型的优点是可以在编译时检查类型错误，提高了代码的可靠性和可读性。\n\n**泛型类和泛型接口**：可以为类定义泛型，那么在创建对象或者是声明一个引用变量的时候就要指明其类型。\n\n**泛型方法**：可将类型作为参数传给方法，在方法前需要形式泛型类型，调用时再实例化泛型\n\n**泛型类**，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型（泛型方法调用形式object.<T>function(param),或者编译器通过传递的参数自动发现类型） 。\n\n**泛型方法与可变参数**\n\n```\npublic <N> void printMsg(N ...args){\n    for(N n : args){\n        System.out.println(\"typeof n is\" + n.getClass());\n    }\n}\n\nprintMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55);\n\n输出\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.Integer\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.Double\n```\n\n**通配泛型与受限泛型**\n\n非受限泛型:<T>  <<==>>  <T extends Object>\n受限泛型:<E extends T> 为T类型的子类\n非受限通配泛型:<?>  <<==>>  <? extends Object>\n受限通配泛型:<? extends T> 为T或为T的子类型\n下限通配泛型:<? super T> 为T或为T的父类型\n\n```\nA<Number>\nB<Integer>\n虽然Integer是Number的子类型，但是B<Integer>不是A<Number>的子类型，为了这个问题使用通配泛型\nA<? extends Number>\n或者A<?>\n举个例子\npublic class Generic {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        test1(list);\n        test2(list);\n        test3(list);\n        test4(list);\n        //test5(list);\n    }\n    public static void test1(ArrayList<?> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    //？为通配符，所以在这里可以不用声明方法为泛型方法，如果使用泛型T的话，就要声明为泛型方法，但是受限又冲突了\n    public static void test2(ArrayList<? extends Number> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    public static <T> void test3(ArrayList<T> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    public static <T extends Number> void test4(ArrayList<T> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    //这是错误的写法，编译不通过，(unexpected bound)因为已经给方法声明为泛型了，然后在传参的时候就不能让泛型受限了\n    /*public static <T> void test5(ArrayList<T extends Number> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }*/\n}\n```\n\n**注意事项**:\n\n泛型类的构造方法不用加<T>\n\n泛型必须是引用类型，所以在传递基本类型的时候都会自动装箱。\n\n如果泛型类中的静态方法使用泛型，那么一定要为该静态方法形式泛型类型（一定为泛型静态方法）。\n（有些不大明白）\n\n异常类不能是泛型，因为异常类是泛型的话，那么catch中的也是泛型，但这是运行时才知道的。\n\n**为什么不能定义泛型数组**\n\n\n\n\n","source":"_posts/java学习笔记.md","raw":"---\ntitle: java学习笔记\nauthor: \"0x17\"\ndate: 2018-07-24 17:04:53\ntags:\n---\n\n### 包装类\n\n首先了解java中的八种基本类型：\n```\nbyte(1byte),short(2bytes),int(4bytes),long(8bytes)\nfloat(4bytes),double(8bytes)\nchar(2bytes)\nboolean(暂未确定，依赖Java虚拟机具体实现)\n```\n[参考](https://www.jianshu.com/p/2f663dc820d0))\n\n#### 什么是包装类\n\n为了将基本类型封装面向对象，设计类时将八种基本类型设计了对应的类，这样的类称为包装类，位于java.lang包中。\n\n#### 包装类的作用\n\n1.有时候方法需要传递一个Object参数，这是就可以使用包装类。\n\n2.集合不允许存放基本类型数据。\n\n3.包装类中封装了一些方法和常量，比如类型最大值，类型转换方法。\n\n4.String可以和基本类型互相转换。\n\n#### 使用\n\n自动装箱：基本类型转包装类，自动装箱过程调用 valueOf() 方法,valueOf()查看该值是否存在缓存中\n```\npublic static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\nInteger i = 10;\n\n自动拆箱：包装类转基本类型\nInteger i = 10;\nint a = i;\n\n#### 注意\n\n包装类中除了Float与Double，都有缓存值，如果在缓存值的范围内，直接引用缓存值（-128-127）。[参考](https://blog.csdn.net/qq_29119581/article/details/78327759)\n\n### Singleton\n\n#### 为什么要使用单例模式\n\n1.控制资源的使用，通过线程同步来控制资源的并发访问；\n\n2.控制实例产生的数量，达到节约资源的目的。\n\n3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。\n\n[参考](https://www.cnblogs.com/andy-zhou/p/5363585.html)\n\n#### 饿汉模式\n\n```\npublic class Singleton{\n    private static Singleton singleton = new Singleton();\n    private Singleton(){}\n    public static Singleton getSingleton(){\n        return singleton;\n    }\n}\n```\n特点：简单安全，但是无法达到延迟加载\n\n#### 懒汉模式\n\n```\npublic class Singleton{\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getSingleton(){\n        if(singleton == null) singleton = new Singleton();\n        return singleton;\n    }\n}\n```\n特点：可以延迟加载但是线程不安全，会导致创建多个实例\n\n[其他优化模式](https://www.cnblogs.com/andy-zhou/p/5363585.html)\n\n### java中的封装、继承、多态与组合\n\n封装：将类中的属性定义为私有的，然后对象通过类中暴露公有的方法来对数据进行操作，这样我们通过自定义公有方法来控制数据的方法方式。\n\n继承：子类继承超类的属性和方法，还可以对超类进行拓展。\n\n多态：比如说一个接口可以有不同的实现，一个标准有不同的实现。\n\n组合：所以总结来说，“is-a ”（是一个）的关系是用继承来表达的，而“has-a\"（有一个）的关系则是用组合来表达的。比如说汽车属于一种交通工具，这是一种继承关系，而汽车拥有发动机，门窗等零部件，这是组合的关系。\n\n### java抽象类和接口\n\n只要类中有抽象方法那么这个类就是抽象类，或者直接被修饰为abstract。\n\n接口算是一个特殊的抽象类，其中所有的变量都为静态常量，所有方法都为静态方法，且没有静态方法。\n\n一个类如果继承抽象类，那么必须得实现抽象类中所有的抽象方法，否则它也是一个抽象类。\n\n一个类可以实现多个接口。\n\n### Java内部类，内部私有类的作用\n\n### java合集\n\n#### 搞清楚其中类和接口的关系关系\n\n![Please Wait](2018_9_6.gif)\n\n#### Iterator与Iterable\n\nIterator与Iterable都是接口，从字面上可以分别理解为迭代器和可迭代的。\n\nIterator中有hasNext(), next(), remove(), forEachRemaining()等方法。\n\nIterable中有一个iterator方法，用来返回一个iterator，也就是返回一个迭代器\n\n### comparable与comparator\n\n### 序列化与反序列化\n\n序列化：把对象转换为字节序列的过程称为对象的序列化\n\n反序列化：把字节序列恢复为对象的过程称为对象的反序列化\n\n作用：\n\n1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中　\n   \n如：在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。\n\n2.在网络上传送对象的字节序列\n   \n如：当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。\n\n### 面向接口编程\n\n### 异常处理\n\n### io中各种类的关系与作用\n\n### 多线程编程\n\n### tomcat与apache与nginx的区别\n\nApache HTTP服务器和Nginx服务器都是http服务器，用来存放静态资源，比如说image,css,html等文件，有一些编程语言中的类库也都可以实现一个简单的http服务器，比如说java或者node。Tomcat服务器除了以上功能还可以发送动态资源，比如说通过Java Server Pages技术可以添加Java语句，jsp本质上就是一个servlet，Tomcat是一个能够运行servlet的容器，管理servlet的生命周期、将url映射到servlet进行处理等。\n\nNginx除此之外还是一款优秀的反向代理服务器\n\n#### 反向代理与负载均衡\n\n[反向代理](https://www.zhihu.com/question/24723688/answer/128105528)：\n\n**正向代理**代理的是客户端，隐藏了客户端的信息\n\n**反向代理**代理的是服务器，隐藏了服务器的信息\n\n[负载均衡](https://zhuanlan.zhihu.com/p/32841479):\n\n将工作分布到多个服务器（能处理相同的请求）来提高应用的性能和可靠性，代理服务器能通过高效的算法将请求转发到性能良好的服务器中进行处理。\n\n### java中的内存管理\n\njava中的内存区域大致可分为CPU寄存器、栈、堆、静态域、常量池等。\n\n#### 字符串的两种创建方式\n\n```\n//第一种创建方式\nString s1 = \"hello\";\nString s2 = \"hello\";\nString s3 = \"world\";\n//第二种创建方式\nString str1 = new String(\"hello\");\nString str2 = new String(\"hello\");\n\nSystem.out.println(\"s1==s2:\"+(s1==s2));//true\nSystem.out.println(\"s1==str1:\"+(s1==str1));//false\nSystem.out.println(\"str1==str2:\"+(str1==str2));//false\n\nString s4 = \"hello\"+\" \"+\"world\";\nString s5 = s2+\" \"+s3;\nString s6 = \"hello world\";\nSystem.out.println(\"s4==s6:\"+(s4==s6));//ture\nSystem.out.println(\"s5==s6:\"+(s5==s6));//false\n```\n第一种创建字符串的时候，会在常量池中查找是否有该对象，如果有，直接指向该内存地址，如果没有，先在常量池中创建，然后再指向其地址。这个过程在编译期就执行好了。\n\n第二种创建字符串，使用String的构造方法，在堆中创建String对象，然后String中的value在常量池中查找是否有该常量，该过程在运行期执行。\n\n```\n//String的构造方法\npublic String(String original) {\n        this.value = original.value;\n        this.hash = original.hash;\n    }\n```\n\n\n### String StringBuilder StringBuffer\n\nString如上第一种声明的为字符串常量，所以随后对字符串的操作就是不断地创建与销毁对象。\nStringBuilder和StringBuffer为字符串变量，可以直接更改指向的内容。在线程安全上，StringBuilder是线程不安全的，StringBuffer是线程安全的，可以看到StringBuffer中的很多方法都是带有synchronized关键字的。\n\nString:适用于少量的字符串操作。\n\nStringBuilder:适用于单线程下在字符缓冲区进行大量操作的情况。\n\nStringBuffer:适用于多线程下在字符缓冲区进行大量操作的情况（线程安全）。\n\n#### 垃圾回收机制\n\n### java注解\n\n#### 元注解\n\n元注解也是注解，它是用来给自定义注解标识的信息的。\n\n### Java泛型（generic）\n\nJava泛型可以参数化类型，泛型存在于编译时期，如果泛型类型是安全的，就将泛型转换为原始类型，所以泛型的优点是可以在编译时检查类型错误，提高了代码的可靠性和可读性。\n\n**泛型类和泛型接口**：可以为类定义泛型，那么在创建对象或者是声明一个引用变量的时候就要指明其类型。\n\n**泛型方法**：可将类型作为参数传给方法，在方法前需要形式泛型类型，调用时再实例化泛型\n\n**泛型类**，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型（泛型方法调用形式object.<T>function(param),或者编译器通过传递的参数自动发现类型） 。\n\n**泛型方法与可变参数**\n\n```\npublic <N> void printMsg(N ...args){\n    for(N n : args){\n        System.out.println(\"typeof n is\" + n.getClass());\n    }\n}\n\nprintMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55);\n\n输出\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.Integer\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.String\ntypeof n isclass java.lang.Double\n```\n\n**通配泛型与受限泛型**\n\n非受限泛型:<T>  <<==>>  <T extends Object>\n受限泛型:<E extends T> 为T类型的子类\n非受限通配泛型:<?>  <<==>>  <? extends Object>\n受限通配泛型:<? extends T> 为T或为T的子类型\n下限通配泛型:<? super T> 为T或为T的父类型\n\n```\nA<Number>\nB<Integer>\n虽然Integer是Number的子类型，但是B<Integer>不是A<Number>的子类型，为了这个问题使用通配泛型\nA<? extends Number>\n或者A<?>\n举个例子\npublic class Generic {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        test1(list);\n        test2(list);\n        test3(list);\n        test4(list);\n        //test5(list);\n    }\n    public static void test1(ArrayList<?> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    //？为通配符，所以在这里可以不用声明方法为泛型方法，如果使用泛型T的话，就要声明为泛型方法，但是受限又冲突了\n    public static void test2(ArrayList<? extends Number> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    public static <T> void test3(ArrayList<T> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    public static <T extends Number> void test4(ArrayList<T> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }\n    //这是错误的写法，编译不通过，(unexpected bound)因为已经给方法声明为泛型了，然后在传参的时候就不能让泛型受限了\n    /*public static <T> void test5(ArrayList<T extends Number> list){\n        for (Object object: list){\n            System.out.println(object+\" type\"+object.getClass());\n        }\n    }*/\n}\n```\n\n**注意事项**:\n\n泛型类的构造方法不用加<T>\n\n泛型必须是引用类型，所以在传递基本类型的时候都会自动装箱。\n\n如果泛型类中的静态方法使用泛型，那么一定要为该静态方法形式泛型类型（一定为泛型静态方法）。\n（有些不大明白）\n\n异常类不能是泛型，因为异常类是泛型的话，那么catch中的也是泛型，但这是运行时才知道的。\n\n**为什么不能定义泛型数组**\n\n\n\n\n","slug":"java学习笔记","published":1,"updated":"2018-12-24T12:20:22.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v7000v7tcyqc4oe8la","content":"<h3 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h3><p>首先了解java中的八种基本类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte(1byte),short(2bytes),int(4bytes),long(8bytes)</span><br><span class=\"line\">float(4bytes),double(8bytes)</span><br><span class=\"line\">char(2bytes)</span><br><span class=\"line\">boolean(暂未确定，依赖Java虚拟机具体实现)</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.jianshu.com/p/2f663dc820d0\" target=\"_blank\" rel=\"noopener\">参考</a>)</p>\n<h4 id=\"什么是包装类\"><a href=\"#什么是包装类\" class=\"headerlink\" title=\"什么是包装类\"></a>什么是包装类</h4><p>为了将基本类型封装面向对象，设计类时将八种基本类型设计了对应的类，这样的类称为包装类，位于java.lang包中。</p>\n<h4 id=\"包装类的作用\"><a href=\"#包装类的作用\" class=\"headerlink\" title=\"包装类的作用\"></a>包装类的作用</h4><p>1.有时候方法需要传递一个Object参数，这是就可以使用包装类。</p>\n<p>2.集合不允许存放基本类型数据。</p>\n<p>3.包装类中封装了一些方法和常量，比如类型最大值，类型转换方法。</p>\n<p>4.String可以和基本类型互相转换。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>自动装箱：基本类型转包装类，自动装箱过程调用 valueOf() 方法,valueOf()查看该值是否存在缓存中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Integer i = 10;</p>\n<p>自动拆箱：包装类转基本类型<br>Integer i = 10;<br>int a = i;</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>包装类中除了Float与Double，都有缓存值，如果在缓存值的范围内，直接引用缓存值（-128-127）。<a href=\"https://blog.csdn.net/qq_29119581/article/details/78327759\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"Singleton\"><a href=\"#Singleton\" class=\"headerlink\" title=\"Singleton\"></a>Singleton</h3><h4 id=\"为什么要使用单例模式\"><a href=\"#为什么要使用单例模式\" class=\"headerlink\" title=\"为什么要使用单例模式\"></a>为什么要使用单例模式</h4><p>1.控制资源的使用，通过线程同步来控制资源的并发访问；</p>\n<p>2.控制实例产生的数量，达到节约资源的目的。</p>\n<p>3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。</p>\n<p><a href=\"https://www.cnblogs.com/andy-zhou/p/5363585.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h4 id=\"饿汉模式\"><a href=\"#饿汉模式\" class=\"headerlink\" title=\"饿汉模式\"></a>饿汉模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">    private static Singleton singleton = new Singleton();</span><br><span class=\"line\">    private Singleton()&#123;&#125;</span><br><span class=\"line\">    public static Singleton getSingleton()&#123;</span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>特点：简单安全，但是无法达到延迟加载</p>\n<h4 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">    private static Singleton singleton = null;</span><br><span class=\"line\">    private Singleton()&#123;&#125;</span><br><span class=\"line\">    public static Singleton getSingleton()&#123;</span><br><span class=\"line\">        if(singleton == null) singleton = new Singleton();</span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>特点：可以延迟加载但是线程不安全，会导致创建多个实例</p>\n<p><a href=\"https://www.cnblogs.com/andy-zhou/p/5363585.html\" target=\"_blank\" rel=\"noopener\">其他优化模式</a></p>\n<h3 id=\"java中的封装、继承、多态与组合\"><a href=\"#java中的封装、继承、多态与组合\" class=\"headerlink\" title=\"java中的封装、继承、多态与组合\"></a>java中的封装、继承、多态与组合</h3><p>封装：将类中的属性定义为私有的，然后对象通过类中暴露公有的方法来对数据进行操作，这样我们通过自定义公有方法来控制数据的方法方式。</p>\n<p>继承：子类继承超类的属性和方法，还可以对超类进行拓展。</p>\n<p>多态：比如说一个接口可以有不同的实现，一个标准有不同的实现。</p>\n<p>组合：所以总结来说，“is-a ”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。比如说汽车属于一种交通工具，这是一种继承关系，而汽车拥有发动机，门窗等零部件，这是组合的关系。</p>\n<h3 id=\"java抽象类和接口\"><a href=\"#java抽象类和接口\" class=\"headerlink\" title=\"java抽象类和接口\"></a>java抽象类和接口</h3><p>只要类中有抽象方法那么这个类就是抽象类，或者直接被修饰为abstract。</p>\n<p>接口算是一个特殊的抽象类，其中所有的变量都为静态常量，所有方法都为静态方法，且没有静态方法。</p>\n<p>一个类如果继承抽象类，那么必须得实现抽象类中所有的抽象方法，否则它也是一个抽象类。</p>\n<p>一个类可以实现多个接口。</p>\n<h3 id=\"Java内部类，内部私有类的作用\"><a href=\"#Java内部类，内部私有类的作用\" class=\"headerlink\" title=\"Java内部类，内部私有类的作用\"></a>Java内部类，内部私有类的作用</h3><h3 id=\"java合集\"><a href=\"#java合集\" class=\"headerlink\" title=\"java合集\"></a>java合集</h3><h4 id=\"搞清楚其中类和接口的关系关系\"><a href=\"#搞清楚其中类和接口的关系关系\" class=\"headerlink\" title=\"搞清楚其中类和接口的关系关系\"></a>搞清楚其中类和接口的关系关系</h4><p><img src=\"/2018/07/24/java学习笔记/2018_9_6.gif\" alt=\"Please Wait\"></p>\n<h4 id=\"Iterator与Iterable\"><a href=\"#Iterator与Iterable\" class=\"headerlink\" title=\"Iterator与Iterable\"></a>Iterator与Iterable</h4><p>Iterator与Iterable都是接口，从字面上可以分别理解为迭代器和可迭代的。</p>\n<p>Iterator中有hasNext(), next(), remove(), forEachRemaining()等方法。</p>\n<p>Iterable中有一个iterator方法，用来返回一个iterator，也就是返回一个迭代器</p>\n<h3 id=\"comparable与comparator\"><a href=\"#comparable与comparator\" class=\"headerlink\" title=\"comparable与comparator\"></a>comparable与comparator</h3><h3 id=\"序列化与反序列化\"><a href=\"#序列化与反序列化\" class=\"headerlink\" title=\"序列化与反序列化\"></a>序列化与反序列化</h3><p>序列化：把对象转换为字节序列的过程称为对象的序列化</p>\n<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p>\n<p>作用：</p>\n<p>1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中　</p>\n<p>如：在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>\n<p>2.在网络上传送对象的字节序列</p>\n<p>如：当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>\n<h3 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h3><h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><h3 id=\"io中各种类的关系与作用\"><a href=\"#io中各种类的关系与作用\" class=\"headerlink\" title=\"io中各种类的关系与作用\"></a>io中各种类的关系与作用</h3><h3 id=\"多线程编程\"><a href=\"#多线程编程\" class=\"headerlink\" title=\"多线程编程\"></a>多线程编程</h3><h3 id=\"tomcat与apache与nginx的区别\"><a href=\"#tomcat与apache与nginx的区别\" class=\"headerlink\" title=\"tomcat与apache与nginx的区别\"></a>tomcat与apache与nginx的区别</h3><p>Apache HTTP服务器和Nginx服务器都是http服务器，用来存放静态资源，比如说image,css,html等文件，有一些编程语言中的类库也都可以实现一个简单的http服务器，比如说java或者node。Tomcat服务器除了以上功能还可以发送动态资源，比如说通过Java Server Pages技术可以添加Java语句，jsp本质上就是一个servlet，Tomcat是一个能够运行servlet的容器，管理servlet的生命周期、将url映射到servlet进行处理等。</p>\n<p>Nginx除此之外还是一款优秀的反向代理服务器</p>\n<h4 id=\"反向代理与负载均衡\"><a href=\"#反向代理与负载均衡\" class=\"headerlink\" title=\"反向代理与负载均衡\"></a>反向代理与负载均衡</h4><p><a href=\"https://www.zhihu.com/question/24723688/answer/128105528\" target=\"_blank\" rel=\"noopener\">反向代理</a>：</p>\n<p><strong>正向代理</strong>代理的是客户端，隐藏了客户端的信息</p>\n<p><strong>反向代理</strong>代理的是服务器，隐藏了服务器的信息</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/32841479\" target=\"_blank\" rel=\"noopener\">负载均衡</a>:</p>\n<p>将工作分布到多个服务器（能处理相同的请求）来提高应用的性能和可靠性，代理服务器能通过高效的算法将请求转发到性能良好的服务器中进行处理。</p>\n<h3 id=\"java中的内存管理\"><a href=\"#java中的内存管理\" class=\"headerlink\" title=\"java中的内存管理\"></a>java中的内存管理</h3><p>java中的内存区域大致可分为CPU寄存器、栈、堆、静态域、常量池等。</p>\n<h4 id=\"字符串的两种创建方式\"><a href=\"#字符串的两种创建方式\" class=\"headerlink\" title=\"字符串的两种创建方式\"></a>字符串的两种创建方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种创建方式</span><br><span class=\"line\">String s1 = &quot;hello&quot;;</span><br><span class=\"line\">String s2 = &quot;hello&quot;;</span><br><span class=\"line\">String s3 = &quot;world&quot;;</span><br><span class=\"line\">//第二种创建方式</span><br><span class=\"line\">String str1 = new String(&quot;hello&quot;);</span><br><span class=\"line\">String str2 = new String(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;s1==s2:&quot;+(s1==s2));//true</span><br><span class=\"line\">System.out.println(&quot;s1==str1:&quot;+(s1==str1));//false</span><br><span class=\"line\">System.out.println(&quot;str1==str2:&quot;+(str1==str2));//false</span><br><span class=\"line\"></span><br><span class=\"line\">String s4 = &quot;hello&quot;+&quot; &quot;+&quot;world&quot;;</span><br><span class=\"line\">String s5 = s2+&quot; &quot;+s3;</span><br><span class=\"line\">String s6 = &quot;hello world&quot;;</span><br><span class=\"line\">System.out.println(&quot;s4==s6:&quot;+(s4==s6));//ture</span><br><span class=\"line\">System.out.println(&quot;s5==s6:&quot;+(s5==s6));//false</span><br></pre></td></tr></table></figure>\n<p>第一种创建字符串的时候，会在常量池中查找是否有该对象，如果有，直接指向该内存地址，如果没有，先在常量池中创建，然后再指向其地址。这个过程在编译期就执行好了。</p>\n<p>第二种创建字符串，使用String的构造方法，在堆中创建String对象，然后String中的value在常量池中查找是否有该常量，该过程在运行期执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//String的构造方法</span><br><span class=\"line\">public String(String original) &#123;</span><br><span class=\"line\">        this.value = original.value;</span><br><span class=\"line\">        this.hash = original.hash;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"String-StringBuilder-StringBuffer\"><a href=\"#String-StringBuilder-StringBuffer\" class=\"headerlink\" title=\"String StringBuilder StringBuffer\"></a>String StringBuilder StringBuffer</h3><p>String如上第一种声明的为字符串常量，所以随后对字符串的操作就是不断地创建与销毁对象。<br>StringBuilder和StringBuffer为字符串变量，可以直接更改指向的内容。在线程安全上，StringBuilder是线程不安全的，StringBuffer是线程安全的，可以看到StringBuffer中的很多方法都是带有synchronized关键字的。</p>\n<p>String:适用于少量的字符串操作。</p>\n<p>StringBuilder:适用于单线程下在字符缓冲区进行大量操作的情况。</p>\n<p>StringBuffer:适用于多线程下在字符缓冲区进行大量操作的情况（线程安全）。</p>\n<h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><h3 id=\"java注解\"><a href=\"#java注解\" class=\"headerlink\" title=\"java注解\"></a>java注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解也是注解，它是用来给自定义注解标识的信息的。</p>\n<h3 id=\"Java泛型（generic）\"><a href=\"#Java泛型（generic）\" class=\"headerlink\" title=\"Java泛型（generic）\"></a>Java泛型（generic）</h3><p>Java泛型可以参数化类型，泛型存在于编译时期，如果泛型类型是安全的，就将泛型转换为原始类型，所以泛型的优点是可以在编译时检查类型错误，提高了代码的可靠性和可读性。</p>\n<p><strong>泛型类和泛型接口</strong>：可以为类定义泛型，那么在创建对象或者是声明一个引用变量的时候就要指明其类型。</p>\n<p><strong>泛型方法</strong>：可将类型作为参数传给方法，在方法前需要形式泛型类型，调用时再实例化泛型</p>\n<p><strong>泛型类</strong>，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型（泛型方法调用形式object.<t>function(param),或者编译器通过传递的参数自动发现类型） 。</t></p>\n<p><strong>泛型方法与可变参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;N&gt; void printMsg(N ...args)&#123;</span><br><span class=\"line\">    for(N n : args)&#123;</span><br><span class=\"line\">        System.out.println(&quot;typeof n is&quot; + n.getClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</span><br><span class=\"line\"></span><br><span class=\"line\">输出</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.Integer</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.Double</span><br></pre></td></tr></table></figure>\n<p><strong>通配泛型与受限泛型</strong></p>\n<p>非受限泛型:<t>  &lt;&lt;==&gt;&gt;  <t extends=\"\" object=\"\"><br>受限泛型:<e extends=\"\" t=\"\"> 为T类型的子类<br>非受限通配泛型:&lt;?&gt;  &lt;&lt;==&gt;&gt;  &lt;? extends Object&gt;<br>受限通配泛型:&lt;? extends T&gt; 为T或为T的子类型<br>下限通配泛型:&lt;? super T&gt; 为T或为T的父类型</e></t></t></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A&lt;Number&gt;</span><br><span class=\"line\">B&lt;Integer&gt;</span><br><span class=\"line\">虽然Integer是Number的子类型，但是B&lt;Integer&gt;不是A&lt;Number&gt;的子类型，为了这个问题使用通配泛型</span><br><span class=\"line\">A&lt;? extends Number&gt;</span><br><span class=\"line\">或者A&lt;?&gt;</span><br><span class=\"line\">举个例子</span><br><span class=\"line\">public class Generic &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(1);</span><br><span class=\"line\">        list.add(2);</span><br><span class=\"line\">        list.add(3);</span><br><span class=\"line\">        test1(list);</span><br><span class=\"line\">        test2(list);</span><br><span class=\"line\">        test3(list);</span><br><span class=\"line\">        test4(list);</span><br><span class=\"line\">        //test5(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void test1(ArrayList&lt;?&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //？为通配符，所以在这里可以不用声明方法为泛型方法，如果使用泛型T的话，就要声明为泛型方法，但是受限又冲突了</span><br><span class=\"line\">    public static void test2(ArrayList&lt;? extends Number&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static &lt;T&gt; void test3(ArrayList&lt;T&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static &lt;T extends Number&gt; void test4(ArrayList&lt;T&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //这是错误的写法，编译不通过，(unexpected bound)因为已经给方法声明为泛型了，然后在传参的时候就不能让泛型受限了</span><br><span class=\"line\">    /*public static &lt;T&gt; void test5(ArrayList&lt;T extends Number&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意事项</strong>:</p>\n<p>泛型类的构造方法不用加<t></t></p>\n<p>泛型必须是引用类型，所以在传递基本类型的时候都会自动装箱。</p>\n<p>如果泛型类中的静态方法使用泛型，那么一定要为该静态方法形式泛型类型（一定为泛型静态方法）。<br>（有些不大明白）</p>\n<p>异常类不能是泛型，因为异常类是泛型的话，那么catch中的也是泛型，但这是运行时才知道的。</p>\n<p><strong>为什么不能定义泛型数组</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h3><p>首先了解java中的八种基本类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte(1byte),short(2bytes),int(4bytes),long(8bytes)</span><br><span class=\"line\">float(4bytes),double(8bytes)</span><br><span class=\"line\">char(2bytes)</span><br><span class=\"line\">boolean(暂未确定，依赖Java虚拟机具体实现)</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.jianshu.com/p/2f663dc820d0\" target=\"_blank\" rel=\"noopener\">参考</a>)</p>\n<h4 id=\"什么是包装类\"><a href=\"#什么是包装类\" class=\"headerlink\" title=\"什么是包装类\"></a>什么是包装类</h4><p>为了将基本类型封装面向对象，设计类时将八种基本类型设计了对应的类，这样的类称为包装类，位于java.lang包中。</p>\n<h4 id=\"包装类的作用\"><a href=\"#包装类的作用\" class=\"headerlink\" title=\"包装类的作用\"></a>包装类的作用</h4><p>1.有时候方法需要传递一个Object参数，这是就可以使用包装类。</p>\n<p>2.集合不允许存放基本类型数据。</p>\n<p>3.包装类中封装了一些方法和常量，比如类型最大值，类型转换方法。</p>\n<p>4.String可以和基本类型互相转换。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>自动装箱：基本类型转包装类，自动装箱过程调用 valueOf() 方法,valueOf()查看该值是否存在缓存中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Integer i = 10;</p>\n<p>自动拆箱：包装类转基本类型<br>Integer i = 10;<br>int a = i;</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>包装类中除了Float与Double，都有缓存值，如果在缓存值的范围内，直接引用缓存值（-128-127）。<a href=\"https://blog.csdn.net/qq_29119581/article/details/78327759\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"Singleton\"><a href=\"#Singleton\" class=\"headerlink\" title=\"Singleton\"></a>Singleton</h3><h4 id=\"为什么要使用单例模式\"><a href=\"#为什么要使用单例模式\" class=\"headerlink\" title=\"为什么要使用单例模式\"></a>为什么要使用单例模式</h4><p>1.控制资源的使用，通过线程同步来控制资源的并发访问；</p>\n<p>2.控制实例产生的数量，达到节约资源的目的。</p>\n<p>3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。</p>\n<p><a href=\"https://www.cnblogs.com/andy-zhou/p/5363585.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h4 id=\"饿汉模式\"><a href=\"#饿汉模式\" class=\"headerlink\" title=\"饿汉模式\"></a>饿汉模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">    private static Singleton singleton = new Singleton();</span><br><span class=\"line\">    private Singleton()&#123;&#125;</span><br><span class=\"line\">    public static Singleton getSingleton()&#123;</span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>特点：简单安全，但是无法达到延迟加载</p>\n<h4 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">    private static Singleton singleton = null;</span><br><span class=\"line\">    private Singleton()&#123;&#125;</span><br><span class=\"line\">    public static Singleton getSingleton()&#123;</span><br><span class=\"line\">        if(singleton == null) singleton = new Singleton();</span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>特点：可以延迟加载但是线程不安全，会导致创建多个实例</p>\n<p><a href=\"https://www.cnblogs.com/andy-zhou/p/5363585.html\" target=\"_blank\" rel=\"noopener\">其他优化模式</a></p>\n<h3 id=\"java中的封装、继承、多态与组合\"><a href=\"#java中的封装、继承、多态与组合\" class=\"headerlink\" title=\"java中的封装、继承、多态与组合\"></a>java中的封装、继承、多态与组合</h3><p>封装：将类中的属性定义为私有的，然后对象通过类中暴露公有的方法来对数据进行操作，这样我们通过自定义公有方法来控制数据的方法方式。</p>\n<p>继承：子类继承超类的属性和方法，还可以对超类进行拓展。</p>\n<p>多态：比如说一个接口可以有不同的实现，一个标准有不同的实现。</p>\n<p>组合：所以总结来说，“is-a ”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。比如说汽车属于一种交通工具，这是一种继承关系，而汽车拥有发动机，门窗等零部件，这是组合的关系。</p>\n<h3 id=\"java抽象类和接口\"><a href=\"#java抽象类和接口\" class=\"headerlink\" title=\"java抽象类和接口\"></a>java抽象类和接口</h3><p>只要类中有抽象方法那么这个类就是抽象类，或者直接被修饰为abstract。</p>\n<p>接口算是一个特殊的抽象类，其中所有的变量都为静态常量，所有方法都为静态方法，且没有静态方法。</p>\n<p>一个类如果继承抽象类，那么必须得实现抽象类中所有的抽象方法，否则它也是一个抽象类。</p>\n<p>一个类可以实现多个接口。</p>\n<h3 id=\"Java内部类，内部私有类的作用\"><a href=\"#Java内部类，内部私有类的作用\" class=\"headerlink\" title=\"Java内部类，内部私有类的作用\"></a>Java内部类，内部私有类的作用</h3><h3 id=\"java合集\"><a href=\"#java合集\" class=\"headerlink\" title=\"java合集\"></a>java合集</h3><h4 id=\"搞清楚其中类和接口的关系关系\"><a href=\"#搞清楚其中类和接口的关系关系\" class=\"headerlink\" title=\"搞清楚其中类和接口的关系关系\"></a>搞清楚其中类和接口的关系关系</h4><p><img src=\"/2018/07/24/java学习笔记/2018_9_6.gif\" alt=\"Please Wait\"></p>\n<h4 id=\"Iterator与Iterable\"><a href=\"#Iterator与Iterable\" class=\"headerlink\" title=\"Iterator与Iterable\"></a>Iterator与Iterable</h4><p>Iterator与Iterable都是接口，从字面上可以分别理解为迭代器和可迭代的。</p>\n<p>Iterator中有hasNext(), next(), remove(), forEachRemaining()等方法。</p>\n<p>Iterable中有一个iterator方法，用来返回一个iterator，也就是返回一个迭代器</p>\n<h3 id=\"comparable与comparator\"><a href=\"#comparable与comparator\" class=\"headerlink\" title=\"comparable与comparator\"></a>comparable与comparator</h3><h3 id=\"序列化与反序列化\"><a href=\"#序列化与反序列化\" class=\"headerlink\" title=\"序列化与反序列化\"></a>序列化与反序列化</h3><p>序列化：把对象转换为字节序列的过程称为对象的序列化</p>\n<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p>\n<p>作用：</p>\n<p>1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中　</p>\n<p>如：在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>\n<p>2.在网络上传送对象的字节序列</p>\n<p>如：当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>\n<h3 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h3><h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><h3 id=\"io中各种类的关系与作用\"><a href=\"#io中各种类的关系与作用\" class=\"headerlink\" title=\"io中各种类的关系与作用\"></a>io中各种类的关系与作用</h3><h3 id=\"多线程编程\"><a href=\"#多线程编程\" class=\"headerlink\" title=\"多线程编程\"></a>多线程编程</h3><h3 id=\"tomcat与apache与nginx的区别\"><a href=\"#tomcat与apache与nginx的区别\" class=\"headerlink\" title=\"tomcat与apache与nginx的区别\"></a>tomcat与apache与nginx的区别</h3><p>Apache HTTP服务器和Nginx服务器都是http服务器，用来存放静态资源，比如说image,css,html等文件，有一些编程语言中的类库也都可以实现一个简单的http服务器，比如说java或者node。Tomcat服务器除了以上功能还可以发送动态资源，比如说通过Java Server Pages技术可以添加Java语句，jsp本质上就是一个servlet，Tomcat是一个能够运行servlet的容器，管理servlet的生命周期、将url映射到servlet进行处理等。</p>\n<p>Nginx除此之外还是一款优秀的反向代理服务器</p>\n<h4 id=\"反向代理与负载均衡\"><a href=\"#反向代理与负载均衡\" class=\"headerlink\" title=\"反向代理与负载均衡\"></a>反向代理与负载均衡</h4><p><a href=\"https://www.zhihu.com/question/24723688/answer/128105528\" target=\"_blank\" rel=\"noopener\">反向代理</a>：</p>\n<p><strong>正向代理</strong>代理的是客户端，隐藏了客户端的信息</p>\n<p><strong>反向代理</strong>代理的是服务器，隐藏了服务器的信息</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/32841479\" target=\"_blank\" rel=\"noopener\">负载均衡</a>:</p>\n<p>将工作分布到多个服务器（能处理相同的请求）来提高应用的性能和可靠性，代理服务器能通过高效的算法将请求转发到性能良好的服务器中进行处理。</p>\n<h3 id=\"java中的内存管理\"><a href=\"#java中的内存管理\" class=\"headerlink\" title=\"java中的内存管理\"></a>java中的内存管理</h3><p>java中的内存区域大致可分为CPU寄存器、栈、堆、静态域、常量池等。</p>\n<h4 id=\"字符串的两种创建方式\"><a href=\"#字符串的两种创建方式\" class=\"headerlink\" title=\"字符串的两种创建方式\"></a>字符串的两种创建方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种创建方式</span><br><span class=\"line\">String s1 = &quot;hello&quot;;</span><br><span class=\"line\">String s2 = &quot;hello&quot;;</span><br><span class=\"line\">String s3 = &quot;world&quot;;</span><br><span class=\"line\">//第二种创建方式</span><br><span class=\"line\">String str1 = new String(&quot;hello&quot;);</span><br><span class=\"line\">String str2 = new String(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;s1==s2:&quot;+(s1==s2));//true</span><br><span class=\"line\">System.out.println(&quot;s1==str1:&quot;+(s1==str1));//false</span><br><span class=\"line\">System.out.println(&quot;str1==str2:&quot;+(str1==str2));//false</span><br><span class=\"line\"></span><br><span class=\"line\">String s4 = &quot;hello&quot;+&quot; &quot;+&quot;world&quot;;</span><br><span class=\"line\">String s5 = s2+&quot; &quot;+s3;</span><br><span class=\"line\">String s6 = &quot;hello world&quot;;</span><br><span class=\"line\">System.out.println(&quot;s4==s6:&quot;+(s4==s6));//ture</span><br><span class=\"line\">System.out.println(&quot;s5==s6:&quot;+(s5==s6));//false</span><br></pre></td></tr></table></figure>\n<p>第一种创建字符串的时候，会在常量池中查找是否有该对象，如果有，直接指向该内存地址，如果没有，先在常量池中创建，然后再指向其地址。这个过程在编译期就执行好了。</p>\n<p>第二种创建字符串，使用String的构造方法，在堆中创建String对象，然后String中的value在常量池中查找是否有该常量，该过程在运行期执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//String的构造方法</span><br><span class=\"line\">public String(String original) &#123;</span><br><span class=\"line\">        this.value = original.value;</span><br><span class=\"line\">        this.hash = original.hash;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"String-StringBuilder-StringBuffer\"><a href=\"#String-StringBuilder-StringBuffer\" class=\"headerlink\" title=\"String StringBuilder StringBuffer\"></a>String StringBuilder StringBuffer</h3><p>String如上第一种声明的为字符串常量，所以随后对字符串的操作就是不断地创建与销毁对象。<br>StringBuilder和StringBuffer为字符串变量，可以直接更改指向的内容。在线程安全上，StringBuilder是线程不安全的，StringBuffer是线程安全的，可以看到StringBuffer中的很多方法都是带有synchronized关键字的。</p>\n<p>String:适用于少量的字符串操作。</p>\n<p>StringBuilder:适用于单线程下在字符缓冲区进行大量操作的情况。</p>\n<p>StringBuffer:适用于多线程下在字符缓冲区进行大量操作的情况（线程安全）。</p>\n<h4 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h4><h3 id=\"java注解\"><a href=\"#java注解\" class=\"headerlink\" title=\"java注解\"></a>java注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解也是注解，它是用来给自定义注解标识的信息的。</p>\n<h3 id=\"Java泛型（generic）\"><a href=\"#Java泛型（generic）\" class=\"headerlink\" title=\"Java泛型（generic）\"></a>Java泛型（generic）</h3><p>Java泛型可以参数化类型，泛型存在于编译时期，如果泛型类型是安全的，就将泛型转换为原始类型，所以泛型的优点是可以在编译时检查类型错误，提高了代码的可靠性和可读性。</p>\n<p><strong>泛型类和泛型接口</strong>：可以为类定义泛型，那么在创建对象或者是声明一个引用变量的时候就要指明其类型。</p>\n<p><strong>泛型方法</strong>：可将类型作为参数传给方法，在方法前需要形式泛型类型，调用时再实例化泛型</p>\n<p><strong>泛型类</strong>，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型（泛型方法调用形式object.<t>function(param),或者编译器通过传递的参数自动发现类型） 。</t></p>\n<p><strong>泛型方法与可变参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;N&gt; void printMsg(N ...args)&#123;</span><br><span class=\"line\">    for(N n : args)&#123;</span><br><span class=\"line\">        System.out.println(&quot;typeof n is&quot; + n.getClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</span><br><span class=\"line\"></span><br><span class=\"line\">输出</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.Integer</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.String</span><br><span class=\"line\">typeof n isclass java.lang.Double</span><br></pre></td></tr></table></figure>\n<p><strong>通配泛型与受限泛型</strong></p>\n<p>非受限泛型:<t>  &lt;&lt;==&gt;&gt;  <t extends=\"\" object=\"\"><br>受限泛型:<e extends=\"\" t=\"\"> 为T类型的子类<br>非受限通配泛型:&lt;?&gt;  &lt;&lt;==&gt;&gt;  &lt;? extends Object&gt;<br>受限通配泛型:&lt;? extends T&gt; 为T或为T的子类型<br>下限通配泛型:&lt;? super T&gt; 为T或为T的父类型</e></t></t></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A&lt;Number&gt;</span><br><span class=\"line\">B&lt;Integer&gt;</span><br><span class=\"line\">虽然Integer是Number的子类型，但是B&lt;Integer&gt;不是A&lt;Number&gt;的子类型，为了这个问题使用通配泛型</span><br><span class=\"line\">A&lt;? extends Number&gt;</span><br><span class=\"line\">或者A&lt;?&gt;</span><br><span class=\"line\">举个例子</span><br><span class=\"line\">public class Generic &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(1);</span><br><span class=\"line\">        list.add(2);</span><br><span class=\"line\">        list.add(3);</span><br><span class=\"line\">        test1(list);</span><br><span class=\"line\">        test2(list);</span><br><span class=\"line\">        test3(list);</span><br><span class=\"line\">        test4(list);</span><br><span class=\"line\">        //test5(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void test1(ArrayList&lt;?&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //？为通配符，所以在这里可以不用声明方法为泛型方法，如果使用泛型T的话，就要声明为泛型方法，但是受限又冲突了</span><br><span class=\"line\">    public static void test2(ArrayList&lt;? extends Number&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static &lt;T&gt; void test3(ArrayList&lt;T&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static &lt;T extends Number&gt; void test4(ArrayList&lt;T&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //这是错误的写法，编译不通过，(unexpected bound)因为已经给方法声明为泛型了，然后在传参的时候就不能让泛型受限了</span><br><span class=\"line\">    /*public static &lt;T&gt; void test5(ArrayList&lt;T extends Number&gt; list)&#123;</span><br><span class=\"line\">        for (Object object: list)&#123;</span><br><span class=\"line\">            System.out.println(object+&quot; type&quot;+object.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意事项</strong>:</p>\n<p>泛型类的构造方法不用加<t></t></p>\n<p>泛型必须是引用类型，所以在传递基本类型的时候都会自动装箱。</p>\n<p>如果泛型类中的静态方法使用泛型，那么一定要为该静态方法形式泛型类型（一定为泛型静态方法）。<br>（有些不大明白）</p>\n<p>异常类不能是泛型，因为异常类是泛型的话，那么catch中的也是泛型，但这是运行时才知道的。</p>\n<p><strong>为什么不能定义泛型数组</strong></p>\n"},{"title":"大学毕业","author":23,"date":"2019-05-25T15:11:49.000Z","_content":"\n今天我哭了。\n\n当校车停到四年前我经常路过的酒店，我明白时间是多么的无情，四年的时光就这么不经意地从我的身边流逝。我和很多同学今天应该是最后一次聚会，今后各奔东西，不会再这么齐的聚在一起了。酒会上同学们的失声痛哭让我回想起了大学那些感动、美好与颓废的时光：还记得那是大一升大二的暑假，我和几位同学留校训练参加ACM,炎炎夏日里我们一起度过了一个多月，这一个月中我们一起吃饭、一起思考、一起逗猫逗狗、一起观看伦敦奥运会、一起开玩笑，那段时间我认为我交到了大学里最好的朋友——易小猪、骚弟、林林、智聪……，他们开朗活泼、幽默又上进。随后大二上学期的国庆节我和易小猪、林林去参加ICPC,三个人在酒店睡一张床，当时比赛的成绩十分羞耻，我们三个一结束就溜出比赛会场，然后买了一大堆零食早早回到酒店，虽然比赛的结果是羞耻的，但是把参加比赛当成去旅游还是蛮开心的，那年流行的“蓝瘦蓝瘦，香菇香菇”真是应景，真是一段难忘的回忆；还记得在隔壁寝室度过了欢乐又颓废的那段游戏时光，颓废是因为我没能控制住自己的游戏时间，过度放纵自己，但是我控制不住我自己，真的是很快乐啊；还记得大一和同学骑行几十公里跨越整个市区来到另一个大学，为了欣赏整个城市的景色，为了欣赏那个师范大学女生的颜值，为了感受骑行的快乐，为了感受自由的气息，但是我也忘不了那天回来后真的是累成狗了，还要参加班会；还记得大四实习，我和班上一个女生在同一家公司实习，每天就是在上班的地方和寝室之间来回，时间过得飞快，这也提前让我明白需要改变，如果每天只是工作，生活是多么无趣，这在今后是一定要改变的。\n\n有的同学说我高冷，有点同学说我闷骚，有的同学说我乐于助人，有的同学说我是一个好人。我一直也想改变，我想变得活泼开朗、我想变得脸皮厚一些、我想变得风趣幽默，虽然我很难做到性格上的改变，每次都是稍有改变却持续不了多久就回到原来的自己，但是改变还是要继续。我要坚持自己的初心，努力成为一个开朗大方的人。\n\n大学四年，我努力过、我优秀过、我快乐过、我颓废过、我胆怯过、我愤怒过、我痛苦过，但我丝毫没有后悔过。\n\n再见了我的大学，我亲爱的同学们！\n![Please Wait](2019-5-25.JPG)\n","source":"_posts/大学毕业.md","raw":"---\ntitle: 大学毕业\nauthor: 0x17\ndate: 2019-05-25 23:11:49\ntags:\n---\n\n今天我哭了。\n\n当校车停到四年前我经常路过的酒店，我明白时间是多么的无情，四年的时光就这么不经意地从我的身边流逝。我和很多同学今天应该是最后一次聚会，今后各奔东西，不会再这么齐的聚在一起了。酒会上同学们的失声痛哭让我回想起了大学那些感动、美好与颓废的时光：还记得那是大一升大二的暑假，我和几位同学留校训练参加ACM,炎炎夏日里我们一起度过了一个多月，这一个月中我们一起吃饭、一起思考、一起逗猫逗狗、一起观看伦敦奥运会、一起开玩笑，那段时间我认为我交到了大学里最好的朋友——易小猪、骚弟、林林、智聪……，他们开朗活泼、幽默又上进。随后大二上学期的国庆节我和易小猪、林林去参加ICPC,三个人在酒店睡一张床，当时比赛的成绩十分羞耻，我们三个一结束就溜出比赛会场，然后买了一大堆零食早早回到酒店，虽然比赛的结果是羞耻的，但是把参加比赛当成去旅游还是蛮开心的，那年流行的“蓝瘦蓝瘦，香菇香菇”真是应景，真是一段难忘的回忆；还记得在隔壁寝室度过了欢乐又颓废的那段游戏时光，颓废是因为我没能控制住自己的游戏时间，过度放纵自己，但是我控制不住我自己，真的是很快乐啊；还记得大一和同学骑行几十公里跨越整个市区来到另一个大学，为了欣赏整个城市的景色，为了欣赏那个师范大学女生的颜值，为了感受骑行的快乐，为了感受自由的气息，但是我也忘不了那天回来后真的是累成狗了，还要参加班会；还记得大四实习，我和班上一个女生在同一家公司实习，每天就是在上班的地方和寝室之间来回，时间过得飞快，这也提前让我明白需要改变，如果每天只是工作，生活是多么无趣，这在今后是一定要改变的。\n\n有的同学说我高冷，有点同学说我闷骚，有的同学说我乐于助人，有的同学说我是一个好人。我一直也想改变，我想变得活泼开朗、我想变得脸皮厚一些、我想变得风趣幽默，虽然我很难做到性格上的改变，每次都是稍有改变却持续不了多久就回到原来的自己，但是改变还是要继续。我要坚持自己的初心，努力成为一个开朗大方的人。\n\n大学四年，我努力过、我优秀过、我快乐过、我颓废过、我胆怯过、我愤怒过、我痛苦过，但我丝毫没有后悔过。\n\n再见了我的大学，我亲爱的同学们！\n![Please Wait](2019-5-25.JPG)\n","slug":"大学毕业","published":1,"updated":"2019-05-30T04:12:13.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v8000w7tcyghdzgd41","content":"<p>今天我哭了。</p>\n<p>当校车停到四年前我经常路过的酒店，我明白时间是多么的无情，四年的时光就这么不经意地从我的身边流逝。我和很多同学今天应该是最后一次聚会，今后各奔东西，不会再这么齐的聚在一起了。酒会上同学们的失声痛哭让我回想起了大学那些感动、美好与颓废的时光：还记得那是大一升大二的暑假，我和几位同学留校训练参加ACM,炎炎夏日里我们一起度过了一个多月，这一个月中我们一起吃饭、一起思考、一起逗猫逗狗、一起观看伦敦奥运会、一起开玩笑，那段时间我认为我交到了大学里最好的朋友——易小猪、骚弟、林林、智聪……，他们开朗活泼、幽默又上进。随后大二上学期的国庆节我和易小猪、林林去参加ICPC,三个人在酒店睡一张床，当时比赛的成绩十分羞耻，我们三个一结束就溜出比赛会场，然后买了一大堆零食早早回到酒店，虽然比赛的结果是羞耻的，但是把参加比赛当成去旅游还是蛮开心的，那年流行的“蓝瘦蓝瘦，香菇香菇”真是应景，真是一段难忘的回忆；还记得在隔壁寝室度过了欢乐又颓废的那段游戏时光，颓废是因为我没能控制住自己的游戏时间，过度放纵自己，但是我控制不住我自己，真的是很快乐啊；还记得大一和同学骑行几十公里跨越整个市区来到另一个大学，为了欣赏整个城市的景色，为了欣赏那个师范大学女生的颜值，为了感受骑行的快乐，为了感受自由的气息，但是我也忘不了那天回来后真的是累成狗了，还要参加班会；还记得大四实习，我和班上一个女生在同一家公司实习，每天就是在上班的地方和寝室之间来回，时间过得飞快，这也提前让我明白需要改变，如果每天只是工作，生活是多么无趣，这在今后是一定要改变的。</p>\n<p>有的同学说我高冷，有点同学说我闷骚，有的同学说我乐于助人，有的同学说我是一个好人。我一直也想改变，我想变得活泼开朗、我想变得脸皮厚一些、我想变得风趣幽默，虽然我很难做到性格上的改变，每次都是稍有改变却持续不了多久就回到原来的自己，但是改变还是要继续。我要坚持自己的初心，努力成为一个开朗大方的人。</p>\n<p>大学四年，我努力过、我优秀过、我快乐过、我颓废过、我胆怯过、我愤怒过、我痛苦过，但我丝毫没有后悔过。</p>\n<p>再见了我的大学，我亲爱的同学们！<br><img src=\"/2019/05/25/大学毕业/2019-5-25.JPG\" alt=\"Please Wait\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我哭了。</p>\n<p>当校车停到四年前我经常路过的酒店，我明白时间是多么的无情，四年的时光就这么不经意地从我的身边流逝。我和很多同学今天应该是最后一次聚会，今后各奔东西，不会再这么齐的聚在一起了。酒会上同学们的失声痛哭让我回想起了大学那些感动、美好与颓废的时光：还记得那是大一升大二的暑假，我和几位同学留校训练参加ACM,炎炎夏日里我们一起度过了一个多月，这一个月中我们一起吃饭、一起思考、一起逗猫逗狗、一起观看伦敦奥运会、一起开玩笑，那段时间我认为我交到了大学里最好的朋友——易小猪、骚弟、林林、智聪……，他们开朗活泼、幽默又上进。随后大二上学期的国庆节我和易小猪、林林去参加ICPC,三个人在酒店睡一张床，当时比赛的成绩十分羞耻，我们三个一结束就溜出比赛会场，然后买了一大堆零食早早回到酒店，虽然比赛的结果是羞耻的，但是把参加比赛当成去旅游还是蛮开心的，那年流行的“蓝瘦蓝瘦，香菇香菇”真是应景，真是一段难忘的回忆；还记得在隔壁寝室度过了欢乐又颓废的那段游戏时光，颓废是因为我没能控制住自己的游戏时间，过度放纵自己，但是我控制不住我自己，真的是很快乐啊；还记得大一和同学骑行几十公里跨越整个市区来到另一个大学，为了欣赏整个城市的景色，为了欣赏那个师范大学女生的颜值，为了感受骑行的快乐，为了感受自由的气息，但是我也忘不了那天回来后真的是累成狗了，还要参加班会；还记得大四实习，我和班上一个女生在同一家公司实习，每天就是在上班的地方和寝室之间来回，时间过得飞快，这也提前让我明白需要改变，如果每天只是工作，生活是多么无趣，这在今后是一定要改变的。</p>\n<p>有的同学说我高冷，有点同学说我闷骚，有的同学说我乐于助人，有的同学说我是一个好人。我一直也想改变，我想变得活泼开朗、我想变得脸皮厚一些、我想变得风趣幽默，虽然我很难做到性格上的改变，每次都是稍有改变却持续不了多久就回到原来的自己，但是改变还是要继续。我要坚持自己的初心，努力成为一个开朗大方的人。</p>\n<p>大学四年，我努力过、我优秀过、我快乐过、我颓废过、我胆怯过、我愤怒过、我痛苦过，但我丝毫没有后悔过。</p>\n<p>再见了我的大学，我亲爱的同学们！<br><img src=\"/2019/05/25/大学毕业/2019-5-25.JPG\" alt=\"Please Wait\"></p>\n"},{"title":"记录实习的前两个月","author":"0x17","date":"2018-12-24T12:19:14.000Z","_content":"\n今天是2018年平安夜，趁着提前下班多出来的这些时间记录一下实习两个多月来的感受。\n\n我是今年8月底投的简历，九月初的时候进行了一次电话面试，就录用了，说实话电话面试是真滴水，本来还是想看看10月的秋招怎么样，但是看了前几家感觉都不大好，其中有一家做企业邮箱的公司感觉不错，但是投了简历就没有下文了，所以当时就觉得我们学校互联网相关的校招机会太少、质量比较低，于是抱着先来大城市熟悉熟悉环境以后再找过工作的心态来到了这家公司。\n\n10月国庆节刚过完，我就来到的这家公司报道，那天火车没有晚点，我早上还没到6点钟就来到了这个陌生的城市，一个人在火车站，第一班公交车还没发车，虽然只是十月，但是我记得很清楚那天早晨特别冷。然后等到6.30坐公交车去公司，结果7.30左右就到了公司，当时公司没有人上班，我一个人拉着旅行箱在公司下面绕着街道走了一圈又一圈，直到路上从环卫阿姨变为一个一个的上班族，那时差不多9.30，公司才开门，然后报道完下午就去培训了，其实就是观看董事长致辞的视频，宣扬一下企业文化吧。\n\n大概在这公司总部呆了3天，就被外派到上海的一家公司开发一套系统，然后开始了我的工作正式开始了\n\n*********\n欸～，工作中的感受记在心里吧。难受\n*********\n\n我算是吸取了教训，以后坐的火车一定要在正常工作时间到达！\n\n对了，和我一起合住的有三位小姐姐（她们年龄确实都比我大），其中一个是我大学同班同学，一个是同学院同学，还有一个是学姐。虽然平时聊的不多，但是住在这一套房子里也算是一次难忘的体验吧！\n","source":"_posts/实习两个月的感受.md","raw":"---\ntitle: 记录实习的前两个月\nauthor: \"0x17\"\ndate: 2018-12-24 20:19:14\ntags:\n---\n\n今天是2018年平安夜，趁着提前下班多出来的这些时间记录一下实习两个多月来的感受。\n\n我是今年8月底投的简历，九月初的时候进行了一次电话面试，就录用了，说实话电话面试是真滴水，本来还是想看看10月的秋招怎么样，但是看了前几家感觉都不大好，其中有一家做企业邮箱的公司感觉不错，但是投了简历就没有下文了，所以当时就觉得我们学校互联网相关的校招机会太少、质量比较低，于是抱着先来大城市熟悉熟悉环境以后再找过工作的心态来到了这家公司。\n\n10月国庆节刚过完，我就来到的这家公司报道，那天火车没有晚点，我早上还没到6点钟就来到了这个陌生的城市，一个人在火车站，第一班公交车还没发车，虽然只是十月，但是我记得很清楚那天早晨特别冷。然后等到6.30坐公交车去公司，结果7.30左右就到了公司，当时公司没有人上班，我一个人拉着旅行箱在公司下面绕着街道走了一圈又一圈，直到路上从环卫阿姨变为一个一个的上班族，那时差不多9.30，公司才开门，然后报道完下午就去培训了，其实就是观看董事长致辞的视频，宣扬一下企业文化吧。\n\n大概在这公司总部呆了3天，就被外派到上海的一家公司开发一套系统，然后开始了我的工作正式开始了\n\n*********\n欸～，工作中的感受记在心里吧。难受\n*********\n\n我算是吸取了教训，以后坐的火车一定要在正常工作时间到达！\n\n对了，和我一起合住的有三位小姐姐（她们年龄确实都比我大），其中一个是我大学同班同学，一个是同学院同学，还有一个是学姐。虽然平时聊的不多，但是住在这一套房子里也算是一次难忘的体验吧！\n","slug":"实习两个月的感受","published":1,"updated":"2019-05-30T03:45:58.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9v9000x7tcy1gkpxw92","content":"<p>今天是2018年平安夜，趁着提前下班多出来的这些时间记录一下实习两个多月来的感受。</p>\n<p>我是今年8月底投的简历，九月初的时候进行了一次电话面试，就录用了，说实话电话面试是真滴水，本来还是想看看10月的秋招怎么样，但是看了前几家感觉都不大好，其中有一家做企业邮箱的公司感觉不错，但是投了简历就没有下文了，所以当时就觉得我们学校互联网相关的校招机会太少、质量比较低，于是抱着先来大城市熟悉熟悉环境以后再找过工作的心态来到了这家公司。</p>\n<p>10月国庆节刚过完，我就来到的这家公司报道，那天火车没有晚点，我早上还没到6点钟就来到了这个陌生的城市，一个人在火车站，第一班公交车还没发车，虽然只是十月，但是我记得很清楚那天早晨特别冷。然后等到6.30坐公交车去公司，结果7.30左右就到了公司，当时公司没有人上班，我一个人拉着旅行箱在公司下面绕着街道走了一圈又一圈，直到路上从环卫阿姨变为一个一个的上班族，那时差不多9.30，公司才开门，然后报道完下午就去培训了，其实就是观看董事长致辞的视频，宣扬一下企业文化吧。</p>\n<p>大概在这公司总部呆了3天，就被外派到上海的一家公司开发一套系统，然后开始了我的工作正式开始了</p>\n<hr>\n<p>欸～，工作中的感受记在心里吧。难受</p>\n<hr>\n<p>我算是吸取了教训，以后坐的火车一定要在正常工作时间到达！</p>\n<p>对了，和我一起合住的有三位小姐姐（她们年龄确实都比我大），其中一个是我大学同班同学，一个是同学院同学，还有一个是学姐。虽然平时聊的不多，但是住在这一套房子里也算是一次难忘的体验吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天是2018年平安夜，趁着提前下班多出来的这些时间记录一下实习两个多月来的感受。</p>\n<p>我是今年8月底投的简历，九月初的时候进行了一次电话面试，就录用了，说实话电话面试是真滴水，本来还是想看看10月的秋招怎么样，但是看了前几家感觉都不大好，其中有一家做企业邮箱的公司感觉不错，但是投了简历就没有下文了，所以当时就觉得我们学校互联网相关的校招机会太少、质量比较低，于是抱着先来大城市熟悉熟悉环境以后再找过工作的心态来到了这家公司。</p>\n<p>10月国庆节刚过完，我就来到的这家公司报道，那天火车没有晚点，我早上还没到6点钟就来到了这个陌生的城市，一个人在火车站，第一班公交车还没发车，虽然只是十月，但是我记得很清楚那天早晨特别冷。然后等到6.30坐公交车去公司，结果7.30左右就到了公司，当时公司没有人上班，我一个人拉着旅行箱在公司下面绕着街道走了一圈又一圈，直到路上从环卫阿姨变为一个一个的上班族，那时差不多9.30，公司才开门，然后报道完下午就去培训了，其实就是观看董事长致辞的视频，宣扬一下企业文化吧。</p>\n<p>大概在这公司总部呆了3天，就被外派到上海的一家公司开发一套系统，然后开始了我的工作正式开始了</p>\n<hr>\n<p>欸～，工作中的感受记在心里吧。难受</p>\n<hr>\n<p>我算是吸取了教训，以后坐的火车一定要在正常工作时间到达！</p>\n<p>对了，和我一起合住的有三位小姐姐（她们年龄确实都比我大），其中一个是我大学同班同学，一个是同学院同学，还有一个是学姐。虽然平时聊的不多，但是住在这一套房子里也算是一次难忘的体验吧！</p>\n"},{"title":"记第一次正式面试","author":"0x17","date":"2018-05-20T11:51:07.000Z","_content":"\n\n上个星期天我进行了人生中的第一次面试，结果是失败告终，不过也在预料之中，因为我实在是没有准备好。所以现在记下这次面试的过程，一方面是为以后做些准备，另一方面也算是纪念第一次失败的面试。\n\n### 笔试前的犹豫\n\n这是校园实习生招聘，这家公司本提前大半个月就发了招聘启事，我也很早就知道了，但是一直在犹豫到底去不去。一方面自己下定决心不考研，所以找工作是必须的，另一方面这段时间太忙了没时间，但是硬要抽时间还是有的，所以就一直犹豫到了面试的前两天（事实证明自己还是个拖延症患者），刚好发现笔试那天没事，于是就报了名。\n\n### 参加笔试\n\n笔试题目是数据结构选择题一部分，C语言基础和java基础选择题二选一，数据库一部分，编程题一道，算法题一道，还有附加题一道，最后是一些题可能是考察心里健康和逻辑思维。选择题很基础，大都是基础题、常识题，可能有一两道比较复杂；数据库我就写了前三条sql语句吧，因为调API调多了，sql语句中的稍微复杂些的查询都不会了（这部分还是要补回来啊），编程题是一道分离字符串中字符和数字的题，算法是一道求一个数的全部质因数，都较为简单，附加题忘记了，我也没写，剩下的题都是一些调查性的问题。笔试就这样，主要还是考察基础，我相信大部分校招也差不多如此，所以以后参加笔试，还是得多注重基础知识。\n\n### 面试前\n\n当天晚上，hr发短信通知我明天参加面试，一起通过的还有两个同学，一个同学是第二天早上9点面试，所以他直接放弃了，因为他说他起不来，我是第二天下午两点面试，所以我抱着试试看的心态参加了，当时根本没做任何准备。面试的地方是家五星级宾馆，这个地方我曾经从门口经过过，单从外面的装修来看还是很豪华的，对这种富贵之地，我内心还是有些胆怯地，有种不知为何产生的自卑感。但是那天当我刚踏入，我就再也没有这种感觉了，一进这家酒店，就听见类似大街上买衣服的店里放的那些歌一样，后面去到二楼才发现是婚庆现场，人来人往，十分嘈杂。并且当前天气很热，我的内心也比较急躁。\n\n### 参加面试\n\n我大概提前一个小时到达面试现场，所以我就先在宾馆临时抱佛脚，看了一些面试题，因为我的求职岗位是前端工程师，所以我一直在看前端的面试题。后面终于轮到我面试了，没想到是八个人同时被两个人面，这个竞争确实有点大了。我是那个组的第一个，当时就感觉凉凉，因为可能每次都是我最先回答问题，事实确实如此。两个面试官不苟言笑，其中年纪大的那位有点像楚云飞。首先是让我们先自我介绍一下，这个问题我是先简单介绍一下个人基本信息，然后说了一下求职意向，在校工作经历，平时的项目经验，还有专业成绩以及一些专业技能。总之自我感觉很平常，没有什么亮点。主要没有什么拿得出手的开源项目，和自己大学没有获得什么突出的奖（前者还可以改变，后者就没希望了），第二个问题是介绍一下这个学期在学习什么，获得了什么收获，给自我评价一下。我回答的是这个学期主要学习webapp开发，然后各种东西balabala说了一下,没有重点，对自己的学习的方向没有很深刻的了解，不好展开表达。第三个问题是你的成绩如何，给你的大学成绩做一个评价，这个问题我当时也没想好，傻不拉几的回答还好、不错，当时场面一度尴尬。第四个问题是你喜欢做什么事情，分享一下你印象深刻的一件事。总之感觉有点坑，如果在同学面前聊天，这种问题可以聊一天，但是当时不知为何，回答问题结结巴巴，没有重点，描述不清晰。\n\n### 吐槽\n\n+ 四个问题没有一个有关技术的（技术问题我可能更答不出来:) ）。\n+ 面试地点有些远，并且当天太热了。\n+ 为什么我这么容易紧张。。。\n\n### 总结\n\n虽然这次面试失败告终，但我的收获还是不少的。我就对这次面试来总结一下，希望以后的面试能够顺利些。\n\n遇到的问题有：\n1. 没有准备导致临场发挥非常紧张，口吐不清晰，表达不连贯。\n2. 回答问题较为简短，难以给面试官良好的印象。\n3. 回答的问题没有重点，自己都不知道自己说到哪了。\n\n目前认为有效的方法：\n1. 首先在面试一家公司前一定要提前在网上搜索他人分享的面试该公司的经验，作为参考是十分不错的。\n2. 另外就是要自信，或者说是厚点脸皮。平时比较低调的人可能很难表现自我，但是面试的时候如果不把自己的实例展示出来，如何才能在众多面试者中脱颖而出，但是也不要过分夸大自己的能力。\n3. 穿着整洁就行，没必要过于正式，做这行的总得有些个性。过于正式反而会蹩脚，影响自己发挥。\n4. 回答问题是最好分点回答，语速平缓，一方面可以缓解因说错而造成的紧张，另一方面也能让面试官也能对自己了解的更清晰些。\n5. 交流时最好看着面试官的眼部周围，一方面表现自己的自信，另一方面表示尊重，期间也可以配合手部动作。","source":"_posts/记第一次正式面试.md","raw":"---\ntitle: 记第一次正式面试\nauthor: \"0x17\"\ndate: 2018-05-20 19:51:07\ntags:\n---\n\n\n上个星期天我进行了人生中的第一次面试，结果是失败告终，不过也在预料之中，因为我实在是没有准备好。所以现在记下这次面试的过程，一方面是为以后做些准备，另一方面也算是纪念第一次失败的面试。\n\n### 笔试前的犹豫\n\n这是校园实习生招聘，这家公司本提前大半个月就发了招聘启事，我也很早就知道了，但是一直在犹豫到底去不去。一方面自己下定决心不考研，所以找工作是必须的，另一方面这段时间太忙了没时间，但是硬要抽时间还是有的，所以就一直犹豫到了面试的前两天（事实证明自己还是个拖延症患者），刚好发现笔试那天没事，于是就报了名。\n\n### 参加笔试\n\n笔试题目是数据结构选择题一部分，C语言基础和java基础选择题二选一，数据库一部分，编程题一道，算法题一道，还有附加题一道，最后是一些题可能是考察心里健康和逻辑思维。选择题很基础，大都是基础题、常识题，可能有一两道比较复杂；数据库我就写了前三条sql语句吧，因为调API调多了，sql语句中的稍微复杂些的查询都不会了（这部分还是要补回来啊），编程题是一道分离字符串中字符和数字的题，算法是一道求一个数的全部质因数，都较为简单，附加题忘记了，我也没写，剩下的题都是一些调查性的问题。笔试就这样，主要还是考察基础，我相信大部分校招也差不多如此，所以以后参加笔试，还是得多注重基础知识。\n\n### 面试前\n\n当天晚上，hr发短信通知我明天参加面试，一起通过的还有两个同学，一个同学是第二天早上9点面试，所以他直接放弃了，因为他说他起不来，我是第二天下午两点面试，所以我抱着试试看的心态参加了，当时根本没做任何准备。面试的地方是家五星级宾馆，这个地方我曾经从门口经过过，单从外面的装修来看还是很豪华的，对这种富贵之地，我内心还是有些胆怯地，有种不知为何产生的自卑感。但是那天当我刚踏入，我就再也没有这种感觉了，一进这家酒店，就听见类似大街上买衣服的店里放的那些歌一样，后面去到二楼才发现是婚庆现场，人来人往，十分嘈杂。并且当前天气很热，我的内心也比较急躁。\n\n### 参加面试\n\n我大概提前一个小时到达面试现场，所以我就先在宾馆临时抱佛脚，看了一些面试题，因为我的求职岗位是前端工程师，所以我一直在看前端的面试题。后面终于轮到我面试了，没想到是八个人同时被两个人面，这个竞争确实有点大了。我是那个组的第一个，当时就感觉凉凉，因为可能每次都是我最先回答问题，事实确实如此。两个面试官不苟言笑，其中年纪大的那位有点像楚云飞。首先是让我们先自我介绍一下，这个问题我是先简单介绍一下个人基本信息，然后说了一下求职意向，在校工作经历，平时的项目经验，还有专业成绩以及一些专业技能。总之自我感觉很平常，没有什么亮点。主要没有什么拿得出手的开源项目，和自己大学没有获得什么突出的奖（前者还可以改变，后者就没希望了），第二个问题是介绍一下这个学期在学习什么，获得了什么收获，给自我评价一下。我回答的是这个学期主要学习webapp开发，然后各种东西balabala说了一下,没有重点，对自己的学习的方向没有很深刻的了解，不好展开表达。第三个问题是你的成绩如何，给你的大学成绩做一个评价，这个问题我当时也没想好，傻不拉几的回答还好、不错，当时场面一度尴尬。第四个问题是你喜欢做什么事情，分享一下你印象深刻的一件事。总之感觉有点坑，如果在同学面前聊天，这种问题可以聊一天，但是当时不知为何，回答问题结结巴巴，没有重点，描述不清晰。\n\n### 吐槽\n\n+ 四个问题没有一个有关技术的（技术问题我可能更答不出来:) ）。\n+ 面试地点有些远，并且当天太热了。\n+ 为什么我这么容易紧张。。。\n\n### 总结\n\n虽然这次面试失败告终，但我的收获还是不少的。我就对这次面试来总结一下，希望以后的面试能够顺利些。\n\n遇到的问题有：\n1. 没有准备导致临场发挥非常紧张，口吐不清晰，表达不连贯。\n2. 回答问题较为简短，难以给面试官良好的印象。\n3. 回答的问题没有重点，自己都不知道自己说到哪了。\n\n目前认为有效的方法：\n1. 首先在面试一家公司前一定要提前在网上搜索他人分享的面试该公司的经验，作为参考是十分不错的。\n2. 另外就是要自信，或者说是厚点脸皮。平时比较低调的人可能很难表现自我，但是面试的时候如果不把自己的实例展示出来，如何才能在众多面试者中脱颖而出，但是也不要过分夸大自己的能力。\n3. 穿着整洁就行，没必要过于正式，做这行的总得有些个性。过于正式反而会蹩脚，影响自己发挥。\n4. 回答问题是最好分点回答，语速平缓，一方面可以缓解因说错而造成的紧张，另一方面也能让面试官也能对自己了解的更清晰些。\n5. 交流时最好看着面试官的眼部周围，一方面表现自己的自信，另一方面表示尊重，期间也可以配合手部动作。","slug":"记第一次正式面试","published":1,"updated":"2018-12-24T12:20:18.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9vg000y7tcy9rr2eva1","content":"<p>上个星期天我进行了人生中的第一次面试，结果是失败告终，不过也在预料之中，因为我实在是没有准备好。所以现在记下这次面试的过程，一方面是为以后做些准备，另一方面也算是纪念第一次失败的面试。</p>\n<h3 id=\"笔试前的犹豫\"><a href=\"#笔试前的犹豫\" class=\"headerlink\" title=\"笔试前的犹豫\"></a>笔试前的犹豫</h3><p>这是校园实习生招聘，这家公司本提前大半个月就发了招聘启事，我也很早就知道了，但是一直在犹豫到底去不去。一方面自己下定决心不考研，所以找工作是必须的，另一方面这段时间太忙了没时间，但是硬要抽时间还是有的，所以就一直犹豫到了面试的前两天（事实证明自己还是个拖延症患者），刚好发现笔试那天没事，于是就报了名。</p>\n<h3 id=\"参加笔试\"><a href=\"#参加笔试\" class=\"headerlink\" title=\"参加笔试\"></a>参加笔试</h3><p>笔试题目是数据结构选择题一部分，C语言基础和java基础选择题二选一，数据库一部分，编程题一道，算法题一道，还有附加题一道，最后是一些题可能是考察心里健康和逻辑思维。选择题很基础，大都是基础题、常识题，可能有一两道比较复杂；数据库我就写了前三条sql语句吧，因为调API调多了，sql语句中的稍微复杂些的查询都不会了（这部分还是要补回来啊），编程题是一道分离字符串中字符和数字的题，算法是一道求一个数的全部质因数，都较为简单，附加题忘记了，我也没写，剩下的题都是一些调查性的问题。笔试就这样，主要还是考察基础，我相信大部分校招也差不多如此，所以以后参加笔试，还是得多注重基础知识。</p>\n<h3 id=\"面试前\"><a href=\"#面试前\" class=\"headerlink\" title=\"面试前\"></a>面试前</h3><p>当天晚上，hr发短信通知我明天参加面试，一起通过的还有两个同学，一个同学是第二天早上9点面试，所以他直接放弃了，因为他说他起不来，我是第二天下午两点面试，所以我抱着试试看的心态参加了，当时根本没做任何准备。面试的地方是家五星级宾馆，这个地方我曾经从门口经过过，单从外面的装修来看还是很豪华的，对这种富贵之地，我内心还是有些胆怯地，有种不知为何产生的自卑感。但是那天当我刚踏入，我就再也没有这种感觉了，一进这家酒店，就听见类似大街上买衣服的店里放的那些歌一样，后面去到二楼才发现是婚庆现场，人来人往，十分嘈杂。并且当前天气很热，我的内心也比较急躁。</p>\n<h3 id=\"参加面试\"><a href=\"#参加面试\" class=\"headerlink\" title=\"参加面试\"></a>参加面试</h3><p>我大概提前一个小时到达面试现场，所以我就先在宾馆临时抱佛脚，看了一些面试题，因为我的求职岗位是前端工程师，所以我一直在看前端的面试题。后面终于轮到我面试了，没想到是八个人同时被两个人面，这个竞争确实有点大了。我是那个组的第一个，当时就感觉凉凉，因为可能每次都是我最先回答问题，事实确实如此。两个面试官不苟言笑，其中年纪大的那位有点像楚云飞。首先是让我们先自我介绍一下，这个问题我是先简单介绍一下个人基本信息，然后说了一下求职意向，在校工作经历，平时的项目经验，还有专业成绩以及一些专业技能。总之自我感觉很平常，没有什么亮点。主要没有什么拿得出手的开源项目，和自己大学没有获得什么突出的奖（前者还可以改变，后者就没希望了），第二个问题是介绍一下这个学期在学习什么，获得了什么收获，给自我评价一下。我回答的是这个学期主要学习webapp开发，然后各种东西balabala说了一下,没有重点，对自己的学习的方向没有很深刻的了解，不好展开表达。第三个问题是你的成绩如何，给你的大学成绩做一个评价，这个问题我当时也没想好，傻不拉几的回答还好、不错，当时场面一度尴尬。第四个问题是你喜欢做什么事情，分享一下你印象深刻的一件事。总之感觉有点坑，如果在同学面前聊天，这种问题可以聊一天，但是当时不知为何，回答问题结结巴巴，没有重点，描述不清晰。</p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><ul>\n<li>四个问题没有一个有关技术的（技术问题我可能更答不出来:) ）。</li>\n<li>面试地点有些远，并且当天太热了。</li>\n<li>为什么我这么容易紧张。。。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>虽然这次面试失败告终，但我的收获还是不少的。我就对这次面试来总结一下，希望以后的面试能够顺利些。</p>\n<p>遇到的问题有：</p>\n<ol>\n<li>没有准备导致临场发挥非常紧张，口吐不清晰，表达不连贯。</li>\n<li>回答问题较为简短，难以给面试官良好的印象。</li>\n<li>回答的问题没有重点，自己都不知道自己说到哪了。</li>\n</ol>\n<p>目前认为有效的方法：</p>\n<ol>\n<li>首先在面试一家公司前一定要提前在网上搜索他人分享的面试该公司的经验，作为参考是十分不错的。</li>\n<li>另外就是要自信，或者说是厚点脸皮。平时比较低调的人可能很难表现自我，但是面试的时候如果不把自己的实例展示出来，如何才能在众多面试者中脱颖而出，但是也不要过分夸大自己的能力。</li>\n<li>穿着整洁就行，没必要过于正式，做这行的总得有些个性。过于正式反而会蹩脚，影响自己发挥。</li>\n<li>回答问题是最好分点回答，语速平缓，一方面可以缓解因说错而造成的紧张，另一方面也能让面试官也能对自己了解的更清晰些。</li>\n<li>交流时最好看着面试官的眼部周围，一方面表现自己的自信，另一方面表示尊重，期间也可以配合手部动作。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>上个星期天我进行了人生中的第一次面试，结果是失败告终，不过也在预料之中，因为我实在是没有准备好。所以现在记下这次面试的过程，一方面是为以后做些准备，另一方面也算是纪念第一次失败的面试。</p>\n<h3 id=\"笔试前的犹豫\"><a href=\"#笔试前的犹豫\" class=\"headerlink\" title=\"笔试前的犹豫\"></a>笔试前的犹豫</h3><p>这是校园实习生招聘，这家公司本提前大半个月就发了招聘启事，我也很早就知道了，但是一直在犹豫到底去不去。一方面自己下定决心不考研，所以找工作是必须的，另一方面这段时间太忙了没时间，但是硬要抽时间还是有的，所以就一直犹豫到了面试的前两天（事实证明自己还是个拖延症患者），刚好发现笔试那天没事，于是就报了名。</p>\n<h3 id=\"参加笔试\"><a href=\"#参加笔试\" class=\"headerlink\" title=\"参加笔试\"></a>参加笔试</h3><p>笔试题目是数据结构选择题一部分，C语言基础和java基础选择题二选一，数据库一部分，编程题一道，算法题一道，还有附加题一道，最后是一些题可能是考察心里健康和逻辑思维。选择题很基础，大都是基础题、常识题，可能有一两道比较复杂；数据库我就写了前三条sql语句吧，因为调API调多了，sql语句中的稍微复杂些的查询都不会了（这部分还是要补回来啊），编程题是一道分离字符串中字符和数字的题，算法是一道求一个数的全部质因数，都较为简单，附加题忘记了，我也没写，剩下的题都是一些调查性的问题。笔试就这样，主要还是考察基础，我相信大部分校招也差不多如此，所以以后参加笔试，还是得多注重基础知识。</p>\n<h3 id=\"面试前\"><a href=\"#面试前\" class=\"headerlink\" title=\"面试前\"></a>面试前</h3><p>当天晚上，hr发短信通知我明天参加面试，一起通过的还有两个同学，一个同学是第二天早上9点面试，所以他直接放弃了，因为他说他起不来，我是第二天下午两点面试，所以我抱着试试看的心态参加了，当时根本没做任何准备。面试的地方是家五星级宾馆，这个地方我曾经从门口经过过，单从外面的装修来看还是很豪华的，对这种富贵之地，我内心还是有些胆怯地，有种不知为何产生的自卑感。但是那天当我刚踏入，我就再也没有这种感觉了，一进这家酒店，就听见类似大街上买衣服的店里放的那些歌一样，后面去到二楼才发现是婚庆现场，人来人往，十分嘈杂。并且当前天气很热，我的内心也比较急躁。</p>\n<h3 id=\"参加面试\"><a href=\"#参加面试\" class=\"headerlink\" title=\"参加面试\"></a>参加面试</h3><p>我大概提前一个小时到达面试现场，所以我就先在宾馆临时抱佛脚，看了一些面试题，因为我的求职岗位是前端工程师，所以我一直在看前端的面试题。后面终于轮到我面试了，没想到是八个人同时被两个人面，这个竞争确实有点大了。我是那个组的第一个，当时就感觉凉凉，因为可能每次都是我最先回答问题，事实确实如此。两个面试官不苟言笑，其中年纪大的那位有点像楚云飞。首先是让我们先自我介绍一下，这个问题我是先简单介绍一下个人基本信息，然后说了一下求职意向，在校工作经历，平时的项目经验，还有专业成绩以及一些专业技能。总之自我感觉很平常，没有什么亮点。主要没有什么拿得出手的开源项目，和自己大学没有获得什么突出的奖（前者还可以改变，后者就没希望了），第二个问题是介绍一下这个学期在学习什么，获得了什么收获，给自我评价一下。我回答的是这个学期主要学习webapp开发，然后各种东西balabala说了一下,没有重点，对自己的学习的方向没有很深刻的了解，不好展开表达。第三个问题是你的成绩如何，给你的大学成绩做一个评价，这个问题我当时也没想好，傻不拉几的回答还好、不错，当时场面一度尴尬。第四个问题是你喜欢做什么事情，分享一下你印象深刻的一件事。总之感觉有点坑，如果在同学面前聊天，这种问题可以聊一天，但是当时不知为何，回答问题结结巴巴，没有重点，描述不清晰。</p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><ul>\n<li>四个问题没有一个有关技术的（技术问题我可能更答不出来:) ）。</li>\n<li>面试地点有些远，并且当天太热了。</li>\n<li>为什么我这么容易紧张。。。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>虽然这次面试失败告终，但我的收获还是不少的。我就对这次面试来总结一下，希望以后的面试能够顺利些。</p>\n<p>遇到的问题有：</p>\n<ol>\n<li>没有准备导致临场发挥非常紧张，口吐不清晰，表达不连贯。</li>\n<li>回答问题较为简短，难以给面试官良好的印象。</li>\n<li>回答的问题没有重点，自己都不知道自己说到哪了。</li>\n</ol>\n<p>目前认为有效的方法：</p>\n<ol>\n<li>首先在面试一家公司前一定要提前在网上搜索他人分享的面试该公司的经验，作为参考是十分不错的。</li>\n<li>另外就是要自信，或者说是厚点脸皮。平时比较低调的人可能很难表现自我，但是面试的时候如果不把自己的实例展示出来，如何才能在众多面试者中脱颖而出，但是也不要过分夸大自己的能力。</li>\n<li>穿着整洁就行，没必要过于正式，做这行的总得有些个性。过于正式反而会蹩脚，影响自己发挥。</li>\n<li>回答问题是最好分点回答，语速平缓，一方面可以缓解因说错而造成的紧张，另一方面也能让面试官也能对自己了解的更清晰些。</li>\n<li>交流时最好看着面试官的眼部周围，一方面表现自己的自信，另一方面表示尊重，期间也可以配合手部动作。</li>\n</ol>\n"},{"title":"琐事","date":"2019-07-01T09:37:36.000Z","_content":"\n发现最近老是遇到一些消极的事情，记下来权当吐槽吧，这样心情才会好一些。\n\n今天被毕业生就业报到证给搞烦了，因为自己的就业单位不接受人事档案，所以讲道理档案打回原籍应该是最好的处理方法（或者是工作所在地的人才市场），相关文件中说档案应该按照报到证上面的地址也就是生源地来发放档案，但实际上档案打回原籍指的是寄回户籍所在地的相关单位，如果生源地与户籍所在地不一致，那么就要进行报到证改派，我就是处于需要报到证改派的这种情况。本来改派无非就是准备一些材料到生源地的相关单位处理一下，稍微麻烦一点，但是此刻的我已经在外省工作了，现在就非常麻烦了，在这几天中我要携带无效的这份报到证和本人省份证回到户籍所在地也就是家里，然后把户籍材料打印好，再来到生源地的相关单位进行改派，这期间不知道又会发生什么乱子，比如说材料准备不充足，相关单位相互推诿，总之到时候看看吧。\n\n这件事情之所以这么烦扰我主要有两点，第一是学校招就处３月１号就出了通知，学院直到今天才发通知，之前因为毕业答辩在学校本来可以一起处理的，现在的话搞得我就很烦。第二是既然教育部门是很重视大学生的就业，那么为什么不能为这种类似的情况开辟快速通道吗？设置这么多程序不光浪费了政府资源，费人又费钱","source":"_posts/琐事.md","raw":"---\ntitle: 琐事\ndate: 2019-07-01 17:37:36\ntags:\n---\n\n发现最近老是遇到一些消极的事情，记下来权当吐槽吧，这样心情才会好一些。\n\n今天被毕业生就业报到证给搞烦了，因为自己的就业单位不接受人事档案，所以讲道理档案打回原籍应该是最好的处理方法（或者是工作所在地的人才市场），相关文件中说档案应该按照报到证上面的地址也就是生源地来发放档案，但实际上档案打回原籍指的是寄回户籍所在地的相关单位，如果生源地与户籍所在地不一致，那么就要进行报到证改派，我就是处于需要报到证改派的这种情况。本来改派无非就是准备一些材料到生源地的相关单位处理一下，稍微麻烦一点，但是此刻的我已经在外省工作了，现在就非常麻烦了，在这几天中我要携带无效的这份报到证和本人省份证回到户籍所在地也就是家里，然后把户籍材料打印好，再来到生源地的相关单位进行改派，这期间不知道又会发生什么乱子，比如说材料准备不充足，相关单位相互推诿，总之到时候看看吧。\n\n这件事情之所以这么烦扰我主要有两点，第一是学校招就处３月１号就出了通知，学院直到今天才发通知，之前因为毕业答辩在学校本来可以一起处理的，现在的话搞得我就很烦。第二是既然教育部门是很重视大学生的就业，那么为什么不能为这种类似的情况开辟快速通道吗？设置这么多程序不光浪费了政府资源，费人又费钱","slug":"琐事","published":1,"updated":"2019-07-01T10:38:24.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9vi000z7tcy3agia997","content":"<p>发现最近老是遇到一些消极的事情，记下来权当吐槽吧，这样心情才会好一些。</p>\n<p>今天被毕业生就业报到证给搞烦了，因为自己的就业单位不接受人事档案，所以讲道理档案打回原籍应该是最好的处理方法（或者是工作所在地的人才市场），相关文件中说档案应该按照报到证上面的地址也就是生源地来发放档案，但实际上档案打回原籍指的是寄回户籍所在地的相关单位，如果生源地与户籍所在地不一致，那么就要进行报到证改派，我就是处于需要报到证改派的这种情况。本来改派无非就是准备一些材料到生源地的相关单位处理一下，稍微麻烦一点，但是此刻的我已经在外省工作了，现在就非常麻烦了，在这几天中我要携带无效的这份报到证和本人省份证回到户籍所在地也就是家里，然后把户籍材料打印好，再来到生源地的相关单位进行改派，这期间不知道又会发生什么乱子，比如说材料准备不充足，相关单位相互推诿，总之到时候看看吧。</p>\n<p>这件事情之所以这么烦扰我主要有两点，第一是学校招就处３月１号就出了通知，学院直到今天才发通知，之前因为毕业答辩在学校本来可以一起处理的，现在的话搞得我就很烦。第二是既然教育部门是很重视大学生的就业，那么为什么不能为这种类似的情况开辟快速通道吗？设置这么多程序不光浪费了政府资源，费人又费钱</p>\n","site":{"data":{}},"excerpt":"","more":"<p>发现最近老是遇到一些消极的事情，记下来权当吐槽吧，这样心情才会好一些。</p>\n<p>今天被毕业生就业报到证给搞烦了，因为自己的就业单位不接受人事档案，所以讲道理档案打回原籍应该是最好的处理方法（或者是工作所在地的人才市场），相关文件中说档案应该按照报到证上面的地址也就是生源地来发放档案，但实际上档案打回原籍指的是寄回户籍所在地的相关单位，如果生源地与户籍所在地不一致，那么就要进行报到证改派，我就是处于需要报到证改派的这种情况。本来改派无非就是准备一些材料到生源地的相关单位处理一下，稍微麻烦一点，但是此刻的我已经在外省工作了，现在就非常麻烦了，在这几天中我要携带无效的这份报到证和本人省份证回到户籍所在地也就是家里，然后把户籍材料打印好，再来到生源地的相关单位进行改派，这期间不知道又会发生什么乱子，比如说材料准备不充足，相关单位相互推诿，总之到时候看看吧。</p>\n<p>这件事情之所以这么烦扰我主要有两点，第一是学校招就处３月１号就出了通知，学院直到今天才发通知，之前因为毕业答辩在学校本来可以一起处理的，现在的话搞得我就很烦。第二是既然教育部门是很重视大学生的就业，那么为什么不能为这种类似的情况开辟快速通道吗？设置这么多程序不光浪费了政府资源，费人又费钱</p>\n"},{"_content":"","source":"_posts/每天一点ES6.md","raw":"","slug":"每天一点ES6","published":1,"date":"2019-07-11T15:34:06.543Z","updated":"2019-07-11T15:34:06.543Z","_id":"cjxype9vk00107tcyocw0x2xr","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"对tomcat的一些理解.md","date":"2019-06-30T09:20:56.000Z","_content":"\n\n### 架构分析\n\n### 源码分析\n\n以tomcat８源码为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。\n\n```bat\nset \"CATALINA_HOME=%CURRENT_DIR%\"\nset \"EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat\"\ncall \"%EXECUTABLE%\" start %CMD_LINE_ARGS% \n\n```\n\n#### startup.bat\n","source":"_posts/对tomcat的一些理解.md","raw":"---\ntitle: 对tomcat的一些理解.md\ndate: 2019-06-30 17:20:56\ntags:\n---\n\n\n### 架构分析\n\n### 源码分析\n\n以tomcat８源码为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。\n\n```bat\nset \"CATALINA_HOME=%CURRENT_DIR%\"\nset \"EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat\"\ncall \"%EXECUTABLE%\" start %CMD_LINE_ARGS% \n\n```\n\n#### startup.bat\n","slug":"对tomcat的一些理解","published":1,"updated":"2019-06-30T09:20:56.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxype9vl00117tcy4oep3w1v","content":"<h3 id=\"架构分析\"><a href=\"#架构分析\" class=\"headerlink\" title=\"架构分析\"></a>架构分析</h3><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>以tomcat８源码为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> \"CATALINA_HOME=<span class=\"variable\">%CURRENT_DIR%</span>\"</span><br><span class=\"line\"><span class=\"built_in\">set</span> \"EXECUTABLE=<span class=\"variable\">%CATALINA_HOME%</span>\\bin\\catalina.bat\"</span><br><span class=\"line\"><span class=\"keyword\">call</span> \"<span class=\"variable\">%EXECUTABLE%</span>\" <span class=\"built_in\">start</span> <span class=\"variable\">%CMD_LINE_ARGS%</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"startup-bat\"><a href=\"#startup-bat\" class=\"headerlink\" title=\"startup.bat\"></a>startup.bat</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"架构分析\"><a href=\"#架构分析\" class=\"headerlink\" title=\"架构分析\"></a>架构分析</h3><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>以tomcat８源码为例，首先是批处理文件startup.bat，主要是设置CATALINA_HOME并且查找是否有catalina.bat文件，如果有就执行。</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> \"CATALINA_HOME=<span class=\"variable\">%CURRENT_DIR%</span>\"</span><br><span class=\"line\"><span class=\"built_in\">set</span> \"EXECUTABLE=<span class=\"variable\">%CATALINA_HOME%</span>\\bin\\catalina.bat\"</span><br><span class=\"line\"><span class=\"keyword\">call</span> \"<span class=\"variable\">%EXECUTABLE%</span>\" <span class=\"built_in\">start</span> <span class=\"variable\">%CMD_LINE_ARGS%</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"startup-bat\"><a href=\"#startup-bat\" class=\"headerlink\" title=\"startup.bat\"></a>startup.bat</h4>"}],"PostAsset":[{"_id":"source/_drafts/学习jvm/JVM-Architecture.png","slug":"JVM-Architecture.png","post":"cjxype9up000i7tcyc66j1nmv","modified":0,"renderable":0},{"_id":"source/_posts/java学习笔记/2018_9_6.gif","slug":"2018_9_6.gif","post":"cjxype9v7000v7tcyqc4oe8la","modified":0,"renderable":0},{"_id":"source/_posts/大学毕业/2019-5-25.JPG","slug":"2019-5-25.JPG","post":"cjxype9v8000w7tcyghdzgd41","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}